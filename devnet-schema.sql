-- ============================================================
-- DEVNET REVIEW SCHEMA: Review Layer for External Database
-- ============================================================
-- Complete implementation with data collection tracking and mass operations
-- Focus: Flexible reviews for sales, permits, appeals with status-specific assignments

-- ============================================================
-- DEVNET ENUMS
-- ============================================================

DROP TYPE IF EXISTS public.devnet_review_kind CASCADE;
CREATE TYPE public.devnet_review_kind AS ENUM (
    'sale_review',
    'permit_review', 
    'appeal_review',
    'custom_review'
);

DROP TYPE IF EXISTS public.devnet_data_status CASCADE;
CREATE TYPE public.devnet_data_status AS ENUM (
    'not_collected',
    'in_field',
    'collected',
    'entered',
    'copied_to_devnet',
    'verified'
);

-- ============================================================
-- DEVNET EMPLOYEES (Simplified with roles)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_employees CASCADE;
CREATE TABLE public.devnet_employees (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid UNIQUE NULL, -- Links to Supabase auth
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text UNIQUE NULL,
    status text NOT NULL DEFAULT 'active',
    can_approve boolean NOT NULL DEFAULT false,
    
    -- Role information for assignments
    role text NULL, -- 'appraiser', 'supervisor', 'data_entry', 'reviewer'
    specialties text[] DEFAULT '{}', -- ['field_work', 'data_entry', 'commercial', 'residential']
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_employees_user_id_idx ON public.devnet_employees (user_id);
CREATE INDEX devnet_employees_status_idx ON public.devnet_employees (status);
CREATE INDEX devnet_employees_role_idx ON public.devnet_employees (role);

-- ============================================================
-- DEVNET DATA TABLES (Copied Daily)
-- ============================================================

-- Devnet parcels data
DROP TABLE IF EXISTS public.devnet_parcels CASCADE;
CREATE TABLE public.devnet_parcels (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_number text NOT NULL,
    start_year integer NULL,
    end_year integer NULL,
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL, -- Original ID from Devnet system
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_parcels_number_idx ON public.devnet_parcels (parcel_number);
CREATE INDEX devnet_parcels_years_idx ON public.devnet_parcels (start_year, end_year);
CREATE INDEX devnet_parcels_devnet_id_idx ON public.devnet_parcels (devnet_id);
CREATE INDEX devnet_parcels_data_gin_idx ON public.devnet_parcels USING gin (data);

-- Devnet neighborhood reports
DROP TABLE IF EXISTS public.devnet_neighborhood_report CASCADE;
CREATE TABLE public.devnet_neighborhood_report (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    neighborhood_name text NOT NULL,
    start_year integer NULL,
    end_year integer NULL,
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL,
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_neighborhood_report_name_idx ON public.devnet_neighborhood_report (neighborhood_name);
CREATE INDEX devnet_neighborhood_report_years_idx ON public.devnet_neighborhood_report (start_year, end_year);
CREATE INDEX devnet_neighborhood_report_data_gin_idx ON public.devnet_neighborhood_report USING gin (data);

-- Devnet sales data
DROP TABLE IF EXISTS public.devnet_sales CASCADE;
CREATE TABLE public.devnet_sales (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_price numeric(12,2) NULL,
    sale_date date NULL,
    sale_type text NULL,
    sale_status text NULL,
    
    -- Additional sale details in JSONB for flexibility
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL,
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_sales_date_idx ON public.devnet_sales (sale_date DESC);
CREATE INDEX devnet_sales_price_idx ON public.devnet_sales (sale_price);
CREATE INDEX devnet_sales_type_idx ON public.devnet_sales (sale_type);
CREATE INDEX devnet_sales_devnet_id_idx ON public.devnet_sales (devnet_id);
CREATE INDEX devnet_sales_data_gin_idx ON public.devnet_sales USING gin (data);

-- Junction table for many-to-many sales/parcels relationship
DROP TABLE IF EXISTS public.devnet_sale_parcels CASCADE;
CREATE TABLE public.devnet_sale_parcels (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id bigint NOT NULL REFERENCES public.devnet_sales (id) ON DELETE CASCADE,
    parcel_id bigint NOT NULL REFERENCES public.devnet_parcels (id) ON DELETE CASCADE,
    
    -- Additional relationship data
    data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (sale_id, parcel_id)
);

CREATE INDEX devnet_sale_parcels_sale_idx ON public.devnet_sale_parcels (sale_id);
CREATE INDEX devnet_sale_parcels_parcel_idx ON public.devnet_sale_parcels (parcel_id);

-- ============================================================
-- DEVNET REVIEW STATUSES
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_statuses CASCADE;
CREATE TABLE public.devnet_review_statuses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_kind public.devnet_review_kind NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    description text NULL,
    is_terminal boolean NOT NULL DEFAULT false,
    needs_approval boolean NOT NULL DEFAULT false,
    
    -- Assignment configuration
    requires_assignment boolean NOT NULL DEFAULT false,
    preferred_role text NULL, -- 'appraiser', 'supervisor', etc.
    required_specialties text[] DEFAULT '{}', -- Required employee specialties
    
    sort_order integer NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (review_kind, slug)
);

-- Insert enhanced review statuses with assignment requirements
INSERT INTO public.devnet_review_statuses (review_kind, slug, name, is_terminal, needs_approval, requires_assignment, preferred_role, required_specialties, sort_order) VALUES
-- Sale review statuses with specific assignment requirements
('sale_review', 'pending', 'Pending Review', false, false, false, NULL, '{}', 1),
('sale_review', 'field-assigned', 'Field Work Assigned', false, false, true, 'appraiser', '{field_work}', 2),
('sale_review', 'in-field', 'Field Work In Progress', false, false, false, NULL, '{}', 3),
('sale_review', 'data-collected', 'Data Collected', false, false, false, NULL, '{}', 4),
('sale_review', 'entry-assigned', 'Data Entry Assigned', false, false, true, 'supervisor', '{data_entry}', 5),
('sale_review', 'data-entered', 'Data Entered', false, false, false, NULL, '{}', 6),
('sale_review', 'needs-approval', 'Needs Approval', false, true, true, 'supervisor', '{approval}', 7),
('sale_review', 'approved-for-copy', 'Approved for Devnet Copy', false, false, false, NULL, '{}', 8),
('sale_review', 'copied-to-devnet', 'Copied to Devnet', false, false, false, NULL, '{}', 9),
('sale_review', 'completed', 'Completed', true, false, false, NULL, '{}', 10),
('sale_review', 'rejected', 'Rejected', true, false, false, NULL, '{}', 11),

-- Permit review statuses
('permit_review', 'pending', 'Pending Review', false, false, false, NULL, '{}', 1),
('permit_review', 'investigating', 'Investigating', false, false, true, 'appraiser', '{field_work}', 2),
('permit_review', 'needs-approval', 'Needs Approval', false, true, true, 'supervisor', '{approval}', 3),
('permit_review', 'approved', 'Approved', true, false, false, NULL, '{}', 4),
('permit_review', 'denied', 'Denied', true, false, false, NULL, '{}', 5),

-- Appeal review statuses
('appeal_review', 'filed', 'Filed', false, false, false, NULL, '{}', 1),
('appeal_review', 'under-review', 'Under Review', false, false, true, 'appraiser', '{review}', 2),
('appeal_review', 'needs-decision', 'Needs Decision', false, true, true, 'supervisor', '{approval}', 3),
('appeal_review', 'upheld', 'Upheld', true, false, false, NULL, '{}', 4),
('appeal_review', 'overturned', 'Overturned', true, false, false, NULL, '{}', 5),
('appeal_review', 'withdrawn', 'Withdrawn', true, false, false, NULL, '{}', 6),

-- Custom review statuses
('custom_review', 'open', 'Open', false, false, false, NULL, '{}', 1),
('custom_review', 'assigned', 'Assigned', false, false, true, NULL, '{}', 2),
('custom_review', 'in-progress', 'In Progress', false, false, false, NULL, '{}', 3),
('custom_review', 'needs-review', 'Needs Review', false, true, true, 'supervisor', '{approval}', 4),
('custom_review', 'completed', 'Completed', true, false, false, NULL, '{}', 5),
('custom_review', 'cancelled', 'Cancelled', true, false, false, NULL, '{}', 6)
ON CONFLICT (review_kind, slug) DO NOTHING;

-- ============================================================
-- DEVNET REVIEWS (Central workflow)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_reviews CASCADE;
CREATE TABLE public.devnet_reviews (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kind public.devnet_review_kind NOT NULL,
    current_status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    
    -- Current assignment (for backward compatibility and quick access)
    assigned_to_id bigint NULL REFERENCES public.devnet_employees (id),
    due_date date NULL,
    
    -- Entity references (flexible - reference different devnet tables)
    entity_type text NULL, -- 'devnet_parcel', 'devnet_sale', etc.
    entity_id bigint NULL,
    
    -- Data collection and copy tracking
    data_status public.devnet_data_status DEFAULT 'not_collected',
    data_collected_at timestamptz NULL,
    data_collected_by_id bigint NULL REFERENCES public.devnet_employees (id),
    copied_to_devnet_at timestamptz NULL,
    copied_to_devnet_by_id bigint NULL REFERENCES public.devnet_employees (id),
    devnet_copy_confirmed boolean DEFAULT false,
    
    -- Data requirements and validation
    requires_field_review boolean DEFAULT false,
    required_data_fields jsonb DEFAULT '{}',
    data_validation_rules jsonb DEFAULT '{}',
    completion_criteria jsonb DEFAULT '{}',
    
    -- Additional context and data
    title text NULL,
    description text NULL,
    priority text DEFAULT 'medium', -- 'low', 'medium', 'high', 'urgent'
    data jsonb NOT NULL DEFAULT '{}', -- Flexible storage for review-specific data
    
    -- Field data collection
    field_data jsonb NULL, -- Data collected in the field
    field_notes text NULL,
    
    -- Workflow tracking
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    completed_at timestamptz NULL
);

CREATE INDEX devnet_reviews_kind_idx ON public.devnet_reviews (kind, created_at DESC);
CREATE INDEX devnet_reviews_status_idx ON public.devnet_reviews (current_status_id);
CREATE INDEX devnet_reviews_assigned_idx ON public.devnet_reviews (assigned_to_id);
CREATE INDEX devnet_reviews_entity_idx ON public.devnet_reviews (entity_type, entity_id);
CREATE INDEX devnet_reviews_priority_idx ON public.devnet_reviews (priority);
CREATE INDEX devnet_reviews_due_date_idx ON public.devnet_reviews (due_date);
CREATE INDEX devnet_reviews_data_status_idx ON public.devnet_reviews (data_status);
CREATE INDEX devnet_reviews_field_required_idx ON public.devnet_reviews (requires_field_review);
CREATE INDEX devnet_reviews_data_gin_idx ON public.devnet_reviews USING gin (data);
CREATE INDEX devnet_reviews_field_data_gin_idx ON public.devnet_reviews USING gin (field_data);
CREATE INDEX devnet_reviews_required_data_gin_idx ON public.devnet_reviews USING gin (required_data_fields);

-- ============================================================
-- STATUS-SPECIFIC ASSIGNMENTS
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_assignments CASCADE;
CREATE TABLE public.devnet_review_assignments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.devnet_reviews (id) ON DELETE CASCADE,
    status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    employee_id bigint NOT NULL REFERENCES public.devnet_employees (id),
    
    -- Assignment details
    assigned_by_id bigint NULL REFERENCES public.devnet_employees (id),
    assigned_at timestamptz NOT NULL DEFAULT now(),
    due_date date NULL,
    notes text NULL,
    
    -- Completion tracking
    completed_at timestamptz NULL,
    completed_by_id bigint NULL REFERENCES public.devnet_employees (id),
    completion_notes text NULL,
    
    -- Status
    is_active boolean DEFAULT true,
    
    UNIQUE (review_id, status_id, employee_id)
);

CREATE INDEX devnet_review_assignments_review_idx ON public.devnet_review_assignments (review_id);
CREATE INDEX devnet_review_assignments_status_idx ON public.devnet_review_assignments (status_id);
CREATE INDEX devnet_review_assignments_employee_idx ON public.devnet_review_assignments (employee_id);
CREATE INDEX devnet_review_assignments_active_idx ON public.devnet_review_assignments (is_active) WHERE is_active = true;
CREATE INDEX devnet_review_assignments_due_date_idx ON public.devnet_review_assignments (due_date);

-- ============================================================
-- DEVNET REVIEW HISTORY (Status and Assignment Changes)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_history CASCADE;
CREATE TABLE public.devnet_review_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.devnet_reviews (id) ON DELETE CASCADE,
    
    -- Status change tracking
    from_status_id bigint NULL REFERENCES public.devnet_review_statuses (id),
    to_status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    
    -- Assignment change tracking
    from_employee_id bigint NULL REFERENCES public.devnet_employees (id),
    to_employee_id bigint NULL REFERENCES public.devnet_employees (id),
    
    -- Data status changes
    from_data_status public.devnet_data_status NULL,
    to_data_status public.devnet_data_status NULL,
    
    -- Change details
    changed_by_id bigint NULL REFERENCES public.devnet_employees (id),
    notes text NULL,
    change_reason text NULL,
    
    changed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_review_history_review_idx ON public.devnet_review_history (review_id, changed_at DESC);
CREATE INDEX devnet_review_history_changed_by_idx ON public.devnet_review_history (changed_by_id);

-- ============================================================
-- DEVNET AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-log review changes
DROP FUNCTION IF EXISTS log_devnet_review_changes();
CREATE OR REPLACE FUNCTION log_devnet_review_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Log status changes
    IF OLD.current_status_id IS DISTINCT FROM NEW.current_status_id THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_status_id,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.current_status_id,
            NEW.current_status_id,
            'Status changed via trigger'
        );
    END IF;
    
    -- Log assignment changes
    IF OLD.assigned_to_id IS DISTINCT FROM NEW.assigned_to_id THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_employee_id,
            to_employee_id,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.assigned_to_id,
            NEW.assigned_to_id,
            NEW.current_status_id,
            'Assignment changed via trigger'
        );
    END IF;
    
    -- Log data status changes
    IF OLD.data_status IS DISTINCT FROM NEW.data_status THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_data_status,
            to_data_status,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.data_status,
            NEW.data_status,
            NEW.current_status_id,
            'Data status changed via trigger'
        );
    END IF;
    
    -- Update timestamp
    NEW.updated_at = now();
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS devnet_review_changes_trigger ON public.devnet_reviews;
CREATE TRIGGER devnet_review_changes_trigger
    BEFORE UPDATE ON public.devnet_reviews
    FOR EACH ROW 
    EXECUTE FUNCTION log_devnet_review_changes();

-- ============================================================
-- DEVNET WORKFLOW FUNCTIONS
-- ============================================================

-- Create a review for a devnet entity
DROP FUNCTION IF EXISTS create_devnet_review(public.devnet_review_kind, text, bigint, text, text, bigint, jsonb);
CREATE OR REPLACE FUNCTION create_devnet_review(
    p_kind public.devnet_review_kind,
    p_entity_type text,
    p_entity_id bigint,
    p_title text DEFAULT NULL,
    p_description text DEFAULT NULL,
    p_assigned_to_id bigint DEFAULT NULL,
    p_data jsonb DEFAULT '{}'::jsonb
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_default_status_id bigint;
BEGIN
    -- Get default status for this review kind (lowest sort_order)
    SELECT id INTO v_default_status_id
    FROM public.devnet_review_statuses 
    WHERE review_kind = p_kind 
    ORDER BY sort_order ASC 
    LIMIT 1;
    
    IF v_default_status_id IS NULL THEN
        RAISE EXCEPTION 'No default status found for review kind: %', p_kind;
    END IF;
    
    -- Create the review
    INSERT INTO public.devnet_reviews (
        kind,
        current_status_id,
        entity_type,
        entity_id,
        title,
        description,
        assigned_to_id,
        data
    ) VALUES (
        p_kind,
        v_default_status_id,
        p_entity_type,
        p_entity_id,
        p_title,
        p_description,
        p_assigned_to_id,
        p_data
    ) RETURNING id INTO v_review_id;
    
    -- Log initial creation
    INSERT INTO public.devnet_review_history (
        review_id,
        to_status_id,
        to_employee_id,
        notes
    ) VALUES (
        v_review_id,
        v_default_status_id,
        p_assigned_to_id,
        'Review created'
    );
    
    RETURN v_review_id;
END;
$$;

-- Transition review status
DROP FUNCTION IF EXISTS transition_devnet_review_status(bigint, text, bigint, text);
CREATE OR REPLACE FUNCTION transition_devnet_review_status(
    p_review_id bigint,
    p_new_status_slug text,
    p_changed_by_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_kind public.devnet_review_kind;
    v_old_status_id bigint;
    v_new_status_id bigint;
    v_is_terminal boolean;
BEGIN
    -- Get current review details
    SELECT kind, current_status_id INTO v_review_kind, v_old_status_id
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review not found: %', p_review_id;
    END IF;
    
    -- Get new status
    SELECT id, is_terminal INTO v_new_status_id, v_is_terminal
    FROM public.devnet_review_statuses 
    WHERE review_kind = v_review_kind AND slug = p_new_status_slug;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid status % for review kind %', p_new_status_slug, v_review_kind;
    END IF;
    
    -- Update review
    UPDATE public.devnet_reviews 
    SET 
        current_status_id = v_new_status_id,
        completed_at = CASE WHEN v_is_terminal THEN now() ELSE completed_at END
    WHERE id = p_review_id;
    
    -- Log the change
    INSERT INTO public.devnet_review_history (
        review_id,
        from_status_id,
        to_status_id,
        changed_by_id,
        notes,
        change_reason
    ) VALUES (
        p_review_id,
        v_old_status_id,
        v_new_status_id,
        p_changed_by_id,
        p_notes,
        'Manual status transition'
    );
    
    RETURN true;
END;
$$;

-- Assign review to employee
DROP FUNCTION IF EXISTS assign_devnet_review(bigint, bigint, bigint, text);
CREATE OR REPLACE FUNCTION assign_devnet_review(
    p_review_id bigint,
    p_employee_id bigint,
    p_assigned_by_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_old_employee_id bigint;
    v_current_status_id bigint;
BEGIN
    -- Get current assignment
    SELECT assigned_to_id, current_status_id INTO v_old_employee_id, v_current_status_id
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review not found: %', p_review_id;
    END IF;
    
    -- Update assignment
    UPDATE public.devnet_reviews 
    SET assigned_to_id = p_employee_id
    WHERE id = p_review_id;
    
    -- Log the assignment change
    INSERT INTO public.devnet_review_history (
        review_id,
        from_employee_id,
        to_employee_id,
        to_status_id,
        changed_by_id,
        notes,
        change_reason
    ) VALUES (
        p_review_id,
        v_old_employee_id,
        p_employee_id,
        v_current_status_id,
        p_assigned_by_id,
        p_notes,
        'Manual assignment'
    );
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET MASS OPERATIONS FUNCTIONS
-- ============================================================

-- Mass create reviews with data requirements
DROP FUNCTION IF EXISTS mass_create_devnet_reviews(jsonb);
CREATE OR REPLACE FUNCTION mass_create_devnet_reviews(
    p_review_configs jsonb -- Array of review configurations
)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    review_config jsonb;
    review_id bigint;
    review_ids bigint[] := '{}';
    default_status_id bigint;
BEGIN
    FOR review_config IN SELECT jsonb_array_elements(p_review_configs)
    LOOP
        -- Get default status for review kind
        SELECT id INTO default_status_id
        FROM public.devnet_review_statuses 
        WHERE review_kind = (review_config->>'kind')::devnet_review_kind
        ORDER BY sort_order ASC 
        LIMIT 1;
        
        -- Create review
        INSERT INTO public.devnet_reviews (
            kind,
            current_status_id,
            entity_type,
            entity_id,
            title,
            description,
            priority,
            requires_field_review,
            required_data_fields,
            data_validation_rules,
            completion_criteria,
            data,
            due_date
        ) VALUES (
            (review_config->>'kind')::devnet_review_kind,
            default_status_id,
            review_config->>'entity_type',
            (review_config->>'entity_id')::bigint,
            review_config->>'title',
            review_config->>'description',
            COALESCE(review_config->>'priority', 'medium'),
            COALESCE((review_config->>'requires_field_review')::boolean, false),
            COALESCE(review_config->'required_data_fields', '{}'::jsonb),
            COALESCE(review_config->'data_validation_rules', '{}'::jsonb),
            COALESCE(review_config->'completion_criteria', '{}'::jsonb),
            COALESCE(review_config->'data', '{}'::jsonb),
            COALESCE((review_config->>'due_date')::date, NULL)
        ) RETURNING id INTO review_id;
        
        review_ids := review_ids || review_id;
        
        -- Auto-assign if specified
        IF review_config ? 'assigned_to_id' THEN
            PERFORM assign_devnet_review(
                review_id,
                (review_config->>'assigned_to_id')::bigint,
                NULL,
                'Auto-assigned during mass creation'
            );
        END IF;
    END LOOP;
    
    RETURN review_ids;
END;
$$;

-- Mass update review status
DROP FUNCTION IF EXISTS mass_update_devnet_review_status(bigint[], text, bigint, text);
CREATE OR REPLACE FUNCTION mass_update_devnet_review_status(
    p_review_ids bigint[],
    p_new_status_slug text,
    p_changed_by_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    success_count integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        BEGIN
            PERFORM transition_devnet_review_status(
                review_id,
                p_new_status_slug,
                p_changed_by_id,
                p_notes
            );
            success_count := success_count + 1;
        EXCEPTION WHEN OTHERS THEN
            -- Log error but continue with other reviews
            INSERT INTO public.devnet_review_history (
                review_id,
                to_status_id,
                changed_by_id,
                notes,
                change_reason
            ) VALUES (
                review_id,
                (SELECT current_status_id FROM public.devnet_reviews WHERE id = review_id),
                p_changed_by_id,
                'Failed to update: ' || SQLERRM,
                'Mass update error'
            );
        END;
    END LOOP;
    
    RETURN success_count = array_length(p_review_ids, 1);
END;
$$;

-- Mass assign reviews
DROP FUNCTION IF EXISTS mass_assign_devnet_reviews(bigint[], bigint, bigint, date);
CREATE OR REPLACE FUNCTION mass_assign_devnet_reviews(
    p_review_ids bigint[],
    p_employee_id bigint,
    p_assigned_by_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    current_status_id bigint;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        -- Get current status
        SELECT devnet_reviews.current_status_id INTO current_status_id
        FROM public.devnet_reviews 
        WHERE id = review_id;
        
        -- Update assignment
        UPDATE public.devnet_reviews 
        SET 
            assigned_to_id = p_employee_id,
            due_date = COALESCE(p_due_date, due_date)
        WHERE id = review_id;
        
        -- Create status-specific assignment if status requires it
        INSERT INTO public.devnet_review_assignments (
            review_id,
            status_id,
            employee_id,
            assigned_by_id,
            due_date,
            notes
        ) VALUES (
            review_id,
            current_status_id,
            p_employee_id,
            p_assigned_by_id,
            p_due_date,
            'Mass assignment'
        ) ON CONFLICT (review_id, status_id, employee_id) 
        DO UPDATE SET
            assigned_by_id = EXCLUDED.assigned_by_id,
            due_date = COALESCE(EXCLUDED.due_date, devnet_review_assignments.due_date),
            assigned_at = now();
    END LOOP;
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET DATA REQUIREMENTS AND VALIDATION FUNCTIONS
-- ============================================================

-- Set data requirements for reviews
DROP FUNCTION IF EXISTS set_review_data_requirements(bigint, jsonb, jsonb, jsonb);
CREATE OR REPLACE FUNCTION set_review_data_requirements(
    p_review_id bigint,
    p_required_fields jsonb,
    p_validation_rules jsonb DEFAULT '{}',
    p_completion_criteria jsonb DEFAULT '{}'
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews 
    SET 
        required_data_fields = p_required_fields,
        data_validation_rules = p_validation_rules,
        completion_criteria = p_completion_criteria,
        updated_at = now()
    WHERE id = p_review_id;
    
    RETURN FOUND;
END;
$$;

-- Check if review has required data
DROP FUNCTION IF EXISTS check_review_data_completeness(bigint);
CREATE OR REPLACE FUNCTION check_review_data_completeness(
    p_review_id bigint
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    review_record record;
    required_field text;
    missing_fields text[] := '{}';
    validation_errors text[] := '{}';
    result jsonb;
BEGIN
    -- Get review data
    SELECT 
        required_data_fields,
        field_data,
        data,
        data_validation_rules
    INTO review_record
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    -- Check required fields
    FOR required_field IN 
        SELECT jsonb_array_elements_text(review_record.required_data_fields->'fields')
    LOOP
        IF NOT (
            (review_record.field_data ? required_field AND review_record.field_data->>required_field IS NOT NULL) OR
            (review_record.data ? required_field AND review_record.data->>required_field IS NOT NULL)
        ) THEN
            missing_fields := missing_fields || required_field;
        END IF;
    END LOOP;
    
    -- Build result
    result := jsonb_build_object(
        'is_complete', array_length(missing_fields, 1) IS NULL,
        'missing_fields', to_jsonb(missing_fields),
        'validation_errors', to_jsonb(validation_errors),
        'checked_at', now()
    );
    
    RETURN result;
END;
$$;

-- Auto-assign based on field requirements
DROP FUNCTION IF EXISTS auto_assign_field_reviews();
CREATE OR REPLACE FUNCTION auto_assign_field_reviews()
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_record record;
    eligible_employee_id bigint;
    assignments_made integer := 0;
BEGIN
    -- Find reviews that need field assignment
    FOR review_record IN 
        SELECT 
            r.id,
            r.entity_type,
            r.entity_id,
            rs.preferred_role,
            rs.required_specialties
        FROM public.devnet_reviews r
        JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
        WHERE r.requires_field_review = true
        AND r.assigned_to_id IS NULL
        AND rs.requires_assignment = true
        AND rs.preferred_role = 'appraiser'
    LOOP
        -- Find eligible employee
        SELECT e.id INTO eligible_employee_id
        FROM public.devnet_employees e
        WHERE e.status = 'active'
        AND e.role = review_record.preferred_role
        AND (
            review_record.required_specialties = '{}' OR
            review_record.required_specialties <@ e.specialties
        )
        ORDER BY 
            -- Prefer employees with fewer active assignments
            (SELECT COUNT(*) FROM public.devnet_reviews WHERE assigned_to_id = e.id AND completed_at IS NULL)
        LIMIT 1;
        
        IF eligible_employee_id IS NOT NULL THEN
            PERFORM assign_devnet_review(
                review_record.id,
                eligible_employee_id,
                NULL,
                'Auto-assigned for field review'
            );
            assignments_made := assignments_made + 1;
        END IF;
    END LOOP;
    
    RETURN assignments_made;
END;
$$;

-- Mark data collection complete
DROP FUNCTION IF EXISTS mark_data_collected(bigint, jsonb, bigint, text);
CREATE OR REPLACE FUNCTION mark_data_collected(
    p_review_id bigint,
    p_field_data jsonb,
    p_employee_id bigint,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews
    SET 
        data_status = 'collected',
        field_data = p_field_data,
        field_notes = p_notes,
        data_collected_at = now(),
        data_collected_by_id = p_employee_id,
        updated_at = now()
    WHERE id = p_review_id;
    
    -- Auto-transition to data-collected status if available
    IF EXISTS (
        SELECT 1 FROM public.devnet_review_statuses rs
        JOIN public.devnet_reviews r ON r.kind = rs.review_kind
        WHERE r.id = p_review_id AND rs.slug = 'data-collected'
    ) THEN
        PERFORM transition_devnet_review_status(
            p_review_id,
            'data-collected',
            p_employee_id,
            'Data collection completed: ' || COALESCE(p_notes, '')
        );
    END IF;
    
    RETURN true;
END;
$$;

-- Mark copied to devnet
DROP FUNCTION IF EXISTS mark_copied_to_devnet(bigint, bigint, text);
CREATE OR REPLACE FUNCTION mark_copied_to_devnet(
    p_review_id bigint,
    p_employee_id bigint,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews
    SET 
        copied_to_devnet_at = now(),
        copied_to_devnet_by_id = p_employee_id,
        devnet_copy_confirmed = true,
        updated_at = now()
    WHERE id = p_review_id;
    
    -- Auto-transition to copied-to-devnet status if available
    IF EXISTS (
        SELECT 1 FROM public.devnet_review_statuses rs
        JOIN public.devnet_reviews r ON r.kind = rs.review_kind
        WHERE r.id = p_review_id AND rs.slug = 'copied-to-devnet'
    ) THEN
        PERFORM transition_devnet_review_status(
            p_review_id,
            'copied-to-devnet',
            p_employee_id,
            'Copied to Devnet: ' || COALESCE(p_notes, '')
        );
    END IF;
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET SEARCH AND FILTER FUNCTIONS
-- ============================================================

-- Comprehensive search function for devnet reviews
DROP FUNCTION IF EXISTS search_devnet_reviews(jsonb);
CREATE OR REPLACE FUNCTION search_devnet_reviews(
    p_filters jsonb DEFAULT '{}'::jsonb
)
RETURNS TABLE (
    id bigint,
    kind text,
    title text,
    description text,
    priority text,
    status_name text,
    status_slug text,
    assigned_to_name text,
    assigned_to_email text,
    assigned_to_role text,
    entity_type text,
    entity_id bigint,
    parcel_number text,
    parcel_address text,
    neighborhood_name text,
    sale_price numeric,
    sale_date date,
    requires_field_review boolean,
    data_status text,
    due_date date,
    days_until_due integer,
    created_at timestamptz,
    updated_at timestamptz,
    completed_at timestamptz
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH filtered_reviews AS (
        SELECT 
            r.id,
            r.kind::text,
            r.title,
            r.description,
            r.priority,
            rs.name as status_name,
            rs.slug as status_slug,
            COALESCE(e.first_name || ' ' || e.last_name, '') as assigned_to_name,
            e.email as assigned_to_email,
            e.role as assigned_to_role,
            r.entity_type,
            r.entity_id,
            
            -- Parcel information
            CASE WHEN r.entity_type = 'devnet_parcel' 
                 THEN p.parcel_number 
                 ELSE sp.parcel_number END as parcel_number,
            CASE WHEN r.entity_type = 'devnet_parcel' 
                 THEN COALESCE(p.data->>'address', p.data->>'property_address', '')
                 ELSE COALESCE(sp.data->>'address', sp.data->>'property_address', '') END as parcel_address,
            CASE WHEN r.entity_type = 'devnet_parcel' 
                 THEN COALESCE(p.data->>'neighborhood', p.data->>'neighborhood_name', '')
                 ELSE COALESCE(sp.data->>'neighborhood', sp.data->>'neighborhood_name', '') END as neighborhood_name,
            
            -- Sale information
            CASE WHEN r.entity_type = 'devnet_sale' THEN s.sale_price ELSE NULL END as sale_price,
            CASE WHEN r.entity_type = 'devnet_sale' THEN s.sale_date ELSE NULL END as sale_date,
            
            r.requires_field_review,
            r.data_status::text,
            r.due_date,
            CASE WHEN r.due_date IS NOT NULL 
                 THEN r.due_date - CURRENT_DATE 
                 ELSE NULL END as days_until_due,
            r.created_at,
            r.updated_at,
            r.completed_at
        FROM public.devnet_reviews r
        LEFT JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
        LEFT JOIN public.devnet_employees e ON r.assigned_to_id = e.id
        
        -- Join parcels for direct parcel reviews
        LEFT JOIN public.devnet_parcels p ON (r.entity_type = 'devnet_parcel' AND r.entity_id = p.id)
        
        -- Join sales and related parcels for sale reviews
        LEFT JOIN public.devnet_sales s ON (r.entity_type = 'devnet_sale' AND r.entity_id = s.id)
        LEFT JOIN public.devnet_sale_parcels salep ON (r.entity_type = 'devnet_sale' AND s.id = salep.sale_id)
        LEFT JOIN public.devnet_parcels sp ON salep.parcel_id = sp.id
        
        WHERE 1=1
        -- Filter by review kind
        AND (NOT p_filters ? 'kind' OR r.kind::text = p_filters->>'kind')
        
        -- Filter by status
        AND (NOT p_filters ? 'status' OR rs.slug = p_filters->>'status')
        
        -- Filter by assigned employee
        AND (NOT p_filters ? 'assigned_to_id' OR r.assigned_to_id = (p_filters->>'assigned_to_id')::bigint)
        
        -- Filter by assigned employee name (partial match)
        AND (NOT p_filters ? 'assigned_to_name' OR 
             (e.first_name || ' ' || e.last_name) ILIKE '%' || (p_filters->>'assigned_to_name') || '%')
        
        -- Filter by priority
        AND (NOT p_filters ? 'priority' OR r.priority = p_filters->>'priority')
        
        -- Filter by parcel number (partial match)
        AND (NOT p_filters ? 'parcel_number' OR 
             (p.parcel_number ILIKE '%' || (p_filters->>'parcel_number') || '%' OR
              sp.parcel_number ILIKE '%' || (p_filters->>'parcel_number') || '%'))
        
        -- Filter by address (partial match)
        AND (NOT p_filters ? 'address' OR 
             (COALESCE(p.data->>'address', p.data->>'property_address', '') ILIKE '%' || (p_filters->>'address') || '%' OR
              COALESCE(sp.data->>'address', sp.data->>'property_address', '') ILIKE '%' || (p_filters->>'address') || '%'))
        
        -- Filter by neighborhood (partial match)
        AND (NOT p_filters ? 'neighborhood' OR 
             (COALESCE(p.data->>'neighborhood', p.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%' OR
              COALESCE(sp.data->>'neighborhood', sp.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%'))
        
        -- Filter by data status
        AND (NOT p_filters ? 'data_status' OR r.data_status::text = p_filters->>'data_status')
        
        -- Filter by field review requirement
        AND (NOT p_filters ? 'requires_field_review' OR r.requires_field_review = (p_filters->>'requires_field_review')::boolean)
        
        -- Filter by terminal status
        AND (NOT p_filters ? 'is_terminal' OR rs.is_terminal = (p_filters->>'is_terminal')::boolean)
        
        -- Date range filters
        AND (NOT p_filters ? 'created_after' OR r.created_at >= (p_filters->>'created_after')::timestamptz)
        AND (NOT p_filters ? 'created_before' OR r.created_at <= (p_filters->>'created_before')::timestamptz)
        AND (NOT p_filters ? 'due_after' OR r.due_date >= (p_filters->>'due_after')::date)
        AND (NOT p_filters ? 'due_before' OR r.due_date <= (p_filters->>'due_before')::date)
        
        -- Sale price range filters
        AND (NOT p_filters ? 'min_sale_price' OR 
             (r.entity_type = 'devnet_sale' AND s.sale_price >= (p_filters->>'min_sale_price')::numeric))
        AND (NOT p_filters ? 'max_sale_price' OR 
             (r.entity_type = 'devnet_sale' AND s.sale_price <= (p_filters->>'max_sale_price')::numeric))
    )
    SELECT 
        fr.id,
        fr.kind,
        fr.title,
        fr.description,
        fr.priority,
        fr.status_name,
        fr.status_slug,
        fr.assigned_to_name,
        fr.assigned_to_email,
        fr.assigned_to_role,
        fr.entity_type,
        fr.entity_id,
        fr.parcel_number,
        fr.parcel_address,
        fr.neighborhood_name,
        fr.sale_price,
        fr.sale_date,
        fr.requires_field_review,
        fr.data_status,
        fr.due_date,
        fr.days_until_due,
        fr.created_at,
        fr.updated_at,
        fr.completed_at
    FROM filtered_reviews fr
    ORDER BY 
        CASE fr.priority 
            WHEN 'urgent' THEN 1 
            WHEN 'high' THEN 2 
            WHEN 'medium' THEN 3 
            WHEN 'low' THEN 4 
            ELSE 5 
        END,
        fr.due_date ASC NULLS LAST,
        fr.created_at DESC;
END;
$$;

-- Get review counts by status and kind
DROP FUNCTION IF EXISTS get_devnet_review_counts(jsonb);
CREATE OR REPLACE FUNCTION get_devnet_review_counts(
    p_filters jsonb DEFAULT '{}'::jsonb
)
RETURNS TABLE (
    kind text,
    status_name text,
    status_slug text,
    review_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.kind::text,
        rs.name as status_name,
        rs.slug as status_slug,
        COUNT(r.id) as review_count
    FROM public.devnet_reviews r
    LEFT JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
    LEFT JOIN public.devnet_employees e ON r.assigned_to_id = e.id
    LEFT JOIN public.devnet_parcels p ON (r.entity_type = 'devnet_parcel' AND r.entity_id = p.id)
    LEFT JOIN public.devnet_sales s ON (r.entity_type = 'devnet_sale' AND r.entity_id = s.id)
    LEFT JOIN public.devnet_sale_parcels salep ON (r.entity_type = 'devnet_sale' AND s.id = salep.sale_id)
    LEFT JOIN public.devnet_parcels sp ON salep.parcel_id = sp.id
    WHERE 1=1
    -- Apply same filters as search function
    AND (NOT p_filters ? 'kind' OR r.kind::text = p_filters->>'kind')
    AND (NOT p_filters ? 'assigned_to_id' OR r.assigned_to_id = (p_filters->>'assigned_to_id')::bigint)
    AND (NOT p_filters ? 'priority' OR r.priority = p_filters->>'priority')
    AND (NOT p_filters ? 'neighborhood' OR 
         (COALESCE(p.data->>'neighborhood', p.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%' OR
          COALESCE(sp.data->>'neighborhood', sp.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%'))
    GROUP BY r.kind::text, rs.name, rs.slug, rs.sort_order
    ORDER BY r.kind::text, rs.sort_order;
END;
$$;

-- Get available filter options
DROP FUNCTION IF EXISTS get_devnet_filter_options();
CREATE OR REPLACE FUNCTION get_devnet_filter_options()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'kinds', (SELECT jsonb_agg(DISTINCT kind::text) FROM public.devnet_reviews),
        'statuses', (
            SELECT jsonb_agg(jsonb_build_object('slug', slug, 'name', name, 'kind', review_kind::text)) 
            FROM public.devnet_review_statuses ORDER BY review_kind, sort_order
        ),
        'priorities', jsonb_build_array('low', 'medium', 'high', 'urgent'),
        'data_statuses', jsonb_build_array('not_collected', 'in_field', 'collected', 'entered', 'copied_to_devnet', 'verified'),
        'employees', (
            SELECT jsonb_agg(jsonb_build_object(
                'id', id, 
                'name', first_name || ' ' || last_name, 
                'email', email, 
                'role', role
            ))
            FROM public.devnet_employees 
            WHERE status = 'active'
            ORDER BY first_name, last_name
        ),
        'neighborhoods', (
            SELECT jsonb_agg(DISTINCT neighborhood) 
            FROM (
                SELECT COALESCE(data->>'neighborhood', data->>'neighborhood_name', '') as neighborhood
                FROM public.devnet_parcels
                WHERE COALESCE(data->>'neighborhood', data->>'neighborhood_name', '') != ''
                UNION
                SELECT DISTINCT neighborhood_name as neighborhood
                FROM public.devnet_neighborhood_report
                WHERE neighborhood_name IS NOT NULL AND neighborhood_name != ''
            ) neighborhoods
            WHERE neighborhood != ''
        )
    ) INTO result;
    
    RETURN result;
END;
$$;

-- ============================================================
-- ENHANCED MASS ASSIGNMENT FUNCTIONS
-- ============================================================

-- Mass create assignments for specific statuses
DROP FUNCTION IF EXISTS mass_create_devnet_assignments(bigint[], bigint[], bigint, bigint, date, text);
CREATE OR REPLACE FUNCTION mass_create_devnet_assignments(
    p_review_ids bigint[],
    p_status_ids bigint[],
    p_employee_id bigint,
    p_assigned_by_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    status_id bigint;
    assignments_created integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        FOREACH status_id IN ARRAY p_status_ids
        LOOP
            INSERT INTO public.devnet_review_assignments (
                review_id,
                status_id,
                employee_id,
                assigned_by_id,
                due_date,
                notes
            ) VALUES (
                review_id,
                status_id,
                p_employee_id,
                p_assigned_by_id,
                p_due_date,
                p_notes
            ) ON CONFLICT (review_id, status_id, employee_id) 
            DO UPDATE SET
                assigned_by_id = EXCLUDED.assigned_by_id,
                due_date = COALESCE(EXCLUDED.due_date, devnet_review_assignments.due_date),
                assigned_at = now(),
                is_active = true;
            
            assignments_created := assignments_created + 1;
        END LOOP;
    END LOOP;
    
    RETURN assignments_created;
END;
$$;

-- Mass reassign reviews (update current assignment and create new status-specific assignments)
DROP FUNCTION IF EXISTS mass_reassign_devnet_reviews(bigint[], bigint, bigint, bigint, date, text);
CREATE OR REPLACE FUNCTION mass_reassign_devnet_reviews(
    p_review_ids bigint[],
    p_from_employee_id bigint,
    p_to_employee_id bigint,
    p_assigned_by_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_notes text DEFAULT 'Mass reassignment'
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    current_status_id bigint;
    reassignments_made integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        -- Only reassign if currently assigned to the from_employee
        SELECT devnet_reviews.current_status_id INTO current_status_id
        FROM public.devnet_reviews 
        WHERE id = review_id 
        AND assigned_to_id = p_from_employee_id;
        
        IF FOUND THEN
            -- Update main assignment
            UPDATE public.devnet_reviews 
            SET 
                assigned_to_id = p_to_employee_id,
                due_date = COALESCE(p_due_date, due_date),
                updated_at = now()
            WHERE id = review_id;
            
            -- Deactivate old status-specific assignments for the from_employee
            UPDATE public.devnet_review_assignments
            SET is_active = false
            WHERE review_id = review_id 
            AND employee_id = p_from_employee_id
            AND is_active = true;
            
            -- Create new status-specific assignment
            INSERT INTO public.devnet_review_assignments (
                review_id,
                status_id,
                employee_id,
                assigned_by_id,
                due_date,
                notes
            ) VALUES (
                review_id,
                current_status_id,
                p_to_employee_id,
                p_assigned_by_id,
                p_due_date,
                p_notes
            ) ON CONFLICT (review_id, status_id, employee_id) 
            DO UPDATE SET
                assigned_by_id = EXCLUDED.assigned_by_id,
                due_date = COALESCE(EXCLUDED.due_date, devnet_review_assignments.due_date),
                assigned_at = now(),
                is_active = true;
            
            reassignments_made := reassignments_made + 1;
        END IF;
    END LOOP;
    
    RETURN reassignments_made;
END;
$$;

-- Mass update assignment completion
DROP FUNCTION IF EXISTS mass_complete_devnet_assignments(bigint[], bigint, text);
CREATE OR REPLACE FUNCTION mass_complete_devnet_assignments(
    p_assignment_ids bigint[],
    p_completed_by_id bigint,
    p_completion_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    assignment_id bigint;
    completions_made integer := 0;
BEGIN
    FOREACH assignment_id IN ARRAY p_assignment_ids
    LOOP
        UPDATE public.devnet_review_assignments
        SET 
            completed_at = now(),
            completed_by_id = p_completed_by_id,
            completion_notes = p_completion_notes,
            is_active = false
        WHERE id = assignment_id
        AND completed_at IS NULL;
        
        IF FOUND THEN
            completions_made := completions_made + 1;
        END IF;
    END LOOP;
    
    RETURN completions_made;
END;
$$;

-- Mass update assignment due dates
DROP FUNCTION IF EXISTS mass_update_assignment_due_dates(bigint[], date, bigint, text);
CREATE OR REPLACE FUNCTION mass_update_assignment_due_dates(
    p_assignment_ids bigint[],
    p_new_due_date date,
    p_updated_by_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    assignment_id bigint;
    updates_made integer := 0;
BEGIN
    FOREACH assignment_id IN ARRAY p_assignment_ids
    LOOP
        UPDATE public.devnet_review_assignments
        SET 
            due_date = p_new_due_date,
            notes = COALESCE(p_notes, notes)
        WHERE id = assignment_id;
        
        IF FOUND THEN
            updates_made := updates_made + 1;
        END IF;
    END LOOP;
    
    RETURN updates_made;
END;
$$;

-- ============================================================
-- SEED DATA FOR TESTING
-- ============================================================

-- Insert sample employees
INSERT INTO public.devnet_employees (first_name, last_name, email, role, specialties, can_approve) VALUES
('John', 'Smith', 'john.smith@example.com', 'appraiser', '{field_work, residential}', false),
('Sarah', 'Johnson', 'sarah.johnson@example.com', 'supervisor', '{approval, data_entry}', true),
('Mike', 'Davis', 'mike.davis@example.com', 'appraiser', '{field_work, commercial}', false),
('Lisa', 'Wilson', 'lisa.wilson@example.com', 'data_entry', '{data_entry, residential}', false),
('Tom', 'Brown', 'tom.brown@example.com', 'supervisor', '{approval, review}', true)
ON CONFLICT (email) DO NOTHING;

-- Sample parcels and sales
INSERT INTO public.devnet_parcels (parcel_number, start_year, end_year, data, devnet_id) VALUES
('123-456-789', 2023, 2024, '{"owner": "Test Owner 1", "address": "123 Main St"}', 'DEV001'),
('987-654-321', 2023, 2024, '{"owner": "Test Owner 2", "address": "456 Oak Ave"}', 'DEV002'),
('555-123-456', 2023, 2024, '{"owner": "Test Owner 3", "address": "789 Pine Rd"}', 'DEV003')
ON CONFLICT DO NOTHING;

INSERT INTO public.devnet_sales (sale_price, sale_date, sale_type, data, devnet_id) VALUES
(250000, '2024-01-15', 'arms_length', '{"buyer": "Jane Doe", "seller": "John Doe"}', 'SALE001'),
(180000, '2024-02-20', 'arms_length', '{"buyer": "Bob Smith", "seller": "Alice Johnson"}', 'SALE002'),
(320000, '2024-03-10', 'arms_length', '{"buyer": "Mike Wilson", "seller": "Sarah Davis"}', 'SALE003')
ON CONFLICT DO NOTHING;

-- ============================================================
-- EXAMPLE USAGE QUERIES
-- ============================================================

/*
-- Create a new sale review with data requirements
SELECT create_devnet_review(
    'sale_review',
    'devnet_sale',
    1,
    'Review Sale #1',
    'Verify sale price and conditions',
    1,
    '{"priority": "high"}'::jsonb
);

-- Set data requirements for a review
SELECT set_review_data_requirements(
    1,
    '{"fields": ["verified_price", "condition_rating", "market_analysis"]}'::jsonb,
    '{"verified_price": {"min": 0, "required": true}}'::jsonb,
    '{"completion_threshold": 0.95}'::jsonb
);

-- Mass create reviews
SELECT mass_create_devnet_reviews('[
    {
        "kind": "sale_review",
        "entity_type": "devnet_sale", 
        "entity_id": 1,
        "title": "Sale Review #1",
        "priority": "high",
        "requires_field_review": true,
        "required_data_fields": {"fields": ["verified_price", "condition"]},
        "due_date": "2024-02-01"
    },
    {
        "kind": "sale_review",
        "entity_type": "devnet_sale",
        "entity_id": 2, 
        "title": "Sale Review #2",
        "priority": "medium",
        "requires_field_review": false
    }
]'::jsonb);

-- Search reviews with filters
SELECT * FROM search_devnet_reviews(
    '{"kind": "sale_review", "priority": "high", "neighborhood": "Downtown"}'::jsonb
) LIMIT 25;

-- Search by assigned employee
SELECT * FROM search_devnet_reviews(
    '{"assigned_to_name": "John", "status": "in-field"}'::jsonb
) LIMIT 50;

-- Search by address
SELECT * FROM search_devnet_reviews(
    '{"address": "Main St", "requires_field_review": true}'::jsonb
) LIMIT 100;

-- Search by parcel number
SELECT * FROM search_devnet_reviews(
    '{"parcel_number": "123-456"}'::jsonb
) LIMIT 25;

-- Search with date ranges
SELECT * FROM search_devnet_reviews(
    '{
        "created_after": "2024-01-01T00:00:00Z",
        "due_before": "2024-03-01",
        "is_terminal": false
    }'::jsonb
) LIMIT 50;

-- Search sale reviews with price range
SELECT * FROM search_devnet_reviews(
    '{
        "kind": "sale_review",
        "min_sale_price": 100000,
        "max_sale_price": 500000
    }'::jsonb
) LIMIT 25;

-- Get review counts by status
SELECT * FROM get_devnet_review_counts('{"kind": "sale_review"}'::jsonb);

-- Get all available filter options
SELECT get_devnet_filter_options();

-- Mass operations examples

-- Mass create assignments for multiple reviews and statuses
SELECT mass_create_devnet_assignments(
    ARRAY[1, 2, 3], -- review_ids
    ARRAY[2, 5], -- status_ids (field-assigned, entry-assigned)
    1, -- employee_id
    2, -- assigned_by_id
    '2024-02-01', -- due_date
    'Bulk assignment for priority reviews'
);

-- Mass reassign reviews from one employee to another
SELECT mass_reassign_devnet_reviews(
    ARRAY[1, 2, 3, 4], -- review_ids
    1, -- from_employee_id
    2, -- to_employee_id
    3, -- assigned_by_id
    '2024-02-15', -- new_due_date
    'Reassigned due to workload balancing'
);

-- Complete multiple assignments at once
SELECT mass_complete_devnet_assignments(
    ARRAY[10, 11, 12], -- assignment_ids
    1, -- completed_by_id
    'Completed field work for all assignments'
);

-- Update due dates for multiple assignments
SELECT mass_update_assignment_due_dates(
    ARRAY[5, 6, 7, 8], -- assignment_ids
    '2024-02-20', -- new_due_date
    2, -- updated_by_id
    'Extended due to complexity'
);

-- Complex search with custom sorting and limiting
SELECT 
    id,
    kind,
    title,
    status_name,
    assigned_to_name,
    neighborhood_name,
    parcel_address,
    priority,
    days_until_due,
    created_at
FROM search_devnet_reviews(
    '{
        "neighborhood": "Downtown",
        "priority": "high",
        "is_terminal": false,
        "requires_field_review": true
    }'::jsonb
) 
ORDER BY days_until_due ASC NULLS LAST, created_at DESC
LIMIT 100;
*/