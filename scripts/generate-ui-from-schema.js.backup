#!/usr/bin/env node

/**
 * Database Types UI Generator
 *
 * Generates a complete Next.js UI with CRUD operations based on database-types.ts
 * Follows the devnet-reviews pattern with shadcn/ui components and Tailwind CSS.
 *
 * Usage:
 *   node scripts/generate-ui-from-schema.js [database-types.ts] [options]
 *
 * Options:
 *   --tables=table1,table2  Generate only for specific tables
 *   --force                 Overwrite existing files
 *   --dry-run              Show what would be generated without creating files
 *   --skip=api,details     Skip specific component types
 *   --output-dir=path      Custom output directory (default: app)
 *   --functions=func1,func2 Generate UI for specific functions
 */

const fs = require("fs");
const path = require("path");

// ============================================================
// CLI ARGUMENT PARSING
// ============================================================

const args = process.argv.slice(2);
const typesFile = args.find((arg) => !arg.startsWith("--")) || "database-types.ts";
const options = {
  force: args.includes("--force"),
  dryRun: args.includes("--dry-run"),
  tables:
    args
      .find((arg) => arg.startsWith("--tables="))
      ?.split("=")[1]
      ?.split(",") || [],
  functions:
    args
      .find((arg) => arg.startsWith("--functions="))
      ?.split("=")[1]
      ?.split(",") || [],
  skip:
    args
      .find((arg) => arg.startsWith("--skip="))
      ?.split("=")[1]
      ?.split(",") || [],
  outputDir:
    args.find((arg) => arg.startsWith("--output-dir="))?.split("=")[1] || "app",
};

// Resolve types file path
const resolvedTypesFile = path.isAbsolute(typesFile)
  ? typesFile
  : path.resolve(process.cwd(), typesFile);

if (!fs.existsSync(resolvedTypesFile)) {
  console.error(`Error: Types file not found: ${resolvedTypesFile}`);
  console.log(
    "Usage: node scripts/generate-ui-from-schema.js [database-types.ts] [options]"
  );
  process.exit(1);
}

// ============================================================
// TYPESCRIPT TYPES PARSER
// ============================================================

class DatabaseTypesParser {
  constructor(typesContent) {
    this.typesContent = typesContent;
    this.enums = [];
    this.tables = [];
    this.functions = [];
  }

  parse() {
    this.parseEnums();
    this.parseTables();
    this.parseFunctions();
    return {
      enums: this.enums,
      tables: this.tables,
      functions: this.functions,
    };
  }

  parseEnums() {
    // Parse enums from the Enums section
    const enumsMatch = this.typesContent.match(/Enums:\s*\{([\s\S]*?)\n\s{4}\}/);
    if (!enumsMatch) return;

    const enumsSection = enumsMatch[1];
    const enumRegex = /(\w+):\s*\n\s*\|?\s*"([^"]+)"(?:\s*\|\s*"([^"]+)")*/g;
    
    let match;
    while ((match = enumRegex.exec(enumsSection)) !== null) {
      const name = match[1];
      const fullMatch = enumsSection.substring(
        match.index,
        enumsSection.indexOf('\n', match.index + name.length + 100)
      );
      
      const values = [...fullMatch.matchAll(/"([^"]+)"/g)].map(m => m[1]);
      
      if (values.length > 0) {
        this.enums.push({ name, values });
      }
    }
  }

  parseTables() {
    // Parse tables from the Tables section
    const tablesMatch = this.typesContent.match(/Tables:\s*\{([\s\S]*?)(?=\n\s{4}Views:|Enums:|Functions:|\n\s{2}\})/);
    if (!tablesMatch) return;

    const tablesSection = tablesMatch[1];
    const tableRegex = /(\w+):\s*\{[\s\S]*?Row:\s*\{([\s\S]*?)\n\s{8}\}/g;
    
    let match;
    while ((match = tableRegex.exec(tablesSection)) !== null) {
      const tableName = match[1];
      const rowSection = match[2];
      
      const columns = [];
      const columnRegex = /(\w+):\s*([\w\[\]\s|]+)/g;
      let colMatch;
      
      while ((colMatch = columnRegex.exec(rowSection)) !== null) {
        const name = colMatch[1];
        let type = colMatch[2].trim();
        
        // Convert TypeScript types to our internal representation
        const tsType = type;
        const nullable = type.includes('null');
        type = type.replace(/\s*\|\s*null/g, '');
        
        columns.push({
          name,
          type: this.mapTypeScriptTypeToSQL(type),
          nullable,
          tsType
        });
      }
      
      this.tables.push({
        name: tableName,
        columns
      });
    }
  }

  parseFunctions() {
    // Parse functions from the Functions section
    const functionsMatch = this.typesContent.match(/Functions:\s*\{([\s\S]*?)(?=\n\s{4}Enums:|\n\s{2}\})/);
    if (!functionsMatch) return;

    const functionsSection = functionsMatch[1];
    const functionRegex = /(\w+):\s*\{[\s\S]*?Args:\s*\{([^}]*)\}[\s\S]*?Returns:\s*([\s\S]*?)(?=\n\s{6}\})/g;
    
    let match;
    while ((match = functionRegex.exec(functionsSection)) !== null) {
      const name = match[1];
      const argsSection = match[2];
      const returnsSection = match[3];
      
      // Parse parameters
      const parameters = [];
      const paramRegex = /(\w+)\??:\s*([\w\[\]<>|\s]+)/g;
      let paramMatch;
      
      while ((paramMatch = paramRegex.exec(argsSection)) !== null) {
        const paramName = paramMatch[1];
        let paramType = paramMatch[2].trim();
        const optional = argsSection.includes(`${paramName}?:`);
        
        parameters.push({
          name: paramName,
          type: paramType,
          optional
        });
      }
      
      // Determine return type
      const returnsArray = returnsSection.includes('[]');
      const returnsTable = returnsArray || returnsSection.includes('{');
      
      let returnColumns = [];
      if (returnsTable && returnsArray) {
        // Parse return columns from object definition
        const returnObjMatch = returnsSection.match(/\{([\s\S]*?)\}/);
        if (returnObjMatch) {
          const returnColRegex = /(\w+):\s*([\w\[\]|]+)/g;
          let retColMatch;
          while ((retColMatch = returnColRegex.exec(returnObjMatch[1])) !== null) {
            returnColumns.push({
              name: retColMatch[1],
              type: retColMatch[2].trim()
            });
          }
        }
      }
      
      // Classify function type
      const isMutation = 
        name.startsWith('create_') ||
        name.startsWith('update_') ||
        name.startsWith('delete_') ||
        name.startsWith('insert_') ||
        name.startsWith('assign_') ||
        name.startsWith('approve_') ||
        name.startsWith('reject_') ||
        name.startsWith('complete_') ||
        name.includes('_update_') ||
        name.includes('_delete_') ||
        name.includes('_insert_');
      
      const isQuery = !isMutation;
      
      this.functions.push({
        name,
        parameters,
        returnType: returnsSection.trim(),
        returnsTable,
        returnColumns,
        isMutation,
        isQuery
      });
    }
  }

  mapTypeScriptTypeToSQL(tsType) {
    const typeMap = {
      'string': 'text',
      'number': 'integer',
      'boolean': 'boolean',
      'Json': 'jsonb',
      'Database["public"]["Enums"]': 'text'
    };
    
    // Handle arrays
    if (tsType.endsWith('[]')) {
      return 'array';
    }
    
    // Check if it's an enum reference
    if (tsType.includes('Enums')) {
      return 'enum';
    }
    
    return typeMap[tsType] || 'text';
  }
}

// ============================================================
// FILE WRITER HELPER
// ============================================================

class FileWriter {
  constructor(options) {
    this.options = options;
  }

  write(filePath, content) {
    if (this.options.dryRun) {
      console.log(`[DRY RUN] Would create: ${filePath}`);
      return;
    }

    if (!this.options.force && this.fileExists(filePath)) {
      console.log(`[SKIP] File exists: ${filePath}`);
      return;
    }

    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(filePath, content, "utf8");
    console.log(`[CREATE] ${filePath}`);
  }

  fileExists(filePath) {
    return fs.existsSync(filePath);
  }
}

// ============================================================
// TEMPLATE GENERATORS
// ============================================================

class TemplateGenerator {
  constructor(schema, options) {
    this.schema = schema;
    this.options = options;
  }

  // Generate TypeScript interface for a table
  generateTableInterface(table) {
    const interfaceName = this.toPascalCase(table.name);
    const lines = [`export interface ${interfaceName} {`];

    for (const col of table.columns) {
      const optional =
        col.isNullable || col.hasDefault || col.isGenerated ? "?" : "";
      const type = this.getTypeScriptType(col);
      lines.push(`  ${col.name}${optional}: ${type};`);
    }

    lines.push("}");
    return lines.join("\n");
  }
    const lines = columnsStr
      .split("\n")
      .map((l) => l.trim())
      .filter(Boolean);

    for (const line of lines) {
      // Skip constraints and indexes
      if (
        line.startsWith("CONSTRAINT") ||
        line.startsWith("UNIQUE") ||
        line.startsWith("CHECK") ||
        line.startsWith("FOREIGN KEY")
      ) {
        continue;
      }

      // Parse column definition
      const columnMatch = line.match(/^(\w+)\s+([^\s,]+)(?:\s+(.*?))?(?:,|$)/);
      if (!columnMatch) continue;

      const [, name, rawType, constraints = ""] = columnMatch;

      const column = {
        name,
        rawType,
        type: this.normalizeType(rawType),
        isPrimary: constraints.includes("PRIMARY KEY"),
        isNullable:
          !constraints.includes("NOT NULL") &&
          !constraints.includes("PRIMARY KEY"),
        isUnique: constraints.includes("UNIQUE"),
        defaultValue: this.extractDefault(constraints),
        isArray: rawType.includes("[]"),
        isGenerated: constraints.includes("GENERATED"),
      };

      columns.push(column);
    }

    return columns;
  }

  normalizeType(rawType) {
    const typeMap = {
      bigint: "number",
      integer: "number",
      int: "number",
      smallint: "number",
      real: "number",
      "double precision": "number",
      numeric: "number",
      text: "string",
      varchar: "string",
      char: "string",
      boolean: "boolean",
      bool: "boolean",
      date: "string",
      timestamp: "string",
      timestamptz: "string",
      jsonb: "object",
      json: "object",
      uuid: "string",
    };

    const baseType = rawType.replace(/\[\]$/, "").toLowerCase();
    return typeMap[baseType] || "any";
  }

  extractDefault(constraints) {
    const defaultMatch = constraints.match(/DEFAULT\s+(.+?)(?:\s|,|$)/i);
    if (!defaultMatch) return null;

    let defaultValue = defaultMatch[1].trim();
    // Remove trailing comma if present
    defaultValue = defaultValue.replace(/,$/, "");
    return defaultValue;
  }

  parseFunctions() {
    const funcRegex =
      /CREATE OR REPLACE FUNCTION (?:public\.)?(\w+)\s*\(([\s\S]*?)\)\s*RETURNS\s+(TABLE|SETOF|void|boolean|bigint|integer|text|jsonb|timestamptz|date|numeric)/gi;
    let match;

    while ((match = funcRegex.exec(this.sqlContent)) !== null) {
      const name = match[1];
      const paramsStr = match[2];
      const returnType = match[3];

      const parameters = this.parseParameters(paramsStr);

      // Determine if function returns a table (query) or is a mutation
      const returnsTable =
        returnType.toUpperCase() === "TABLE" ||
        returnType.toUpperCase() === "SETOF";
      const isMutation =
        returnType.toLowerCase() === "void" ||
        returnType.toLowerCase() === "boolean" ||
        returnType.toLowerCase() === "bigint" ||
        name.startsWith("create_") ||
        name.startsWith("update_") ||
        name.startsWith("delete_") ||
        name.startsWith("mass_") ||
        name.startsWith("set_") ||
        name.startsWith("mark_") ||
        name.startsWith("assign_") ||
        name.startsWith("transition_");

      this.functions.push({
        name,
        parameters,
        returnType,
        returnsTable,
        isMutation,
        isQuery: !isMutation,
        isMassOperation: name.startsWith("mass_"),
        isSearch: name.startsWith("search_"),
        isGetter: name.startsWith("get_"),
      });
    }
  }

  // Generate TypeScript interface for a table
  generateTableInterface(table) {
    if (!paramsStr.trim()) return [];

    const parameters = [];
    const lines = paramsStr
      .split("\n")
      .map((l) => l.trim())
      .filter(Boolean);

    for (const line of lines) {
      // Skip comments
      if (line.startsWith("--")) continue;

      const paramMatch = line.match(
        /^(\w+)\s+(.+?)(?:\s+DEFAULT\s+(.+?))?(?:,|$)/i
      );
      if (!paramMatch) continue;

      const [, name, rawType, defaultValue] = paramMatch;

      parameters.push({
        name,
        rawType: rawType.trim(),
        type: this.normalizeType(rawType),
        hasDefault: !!defaultValue,
        defaultValue: defaultValue?.trim(),
        isOptional: !!defaultValue,
      });
    }

    return parameters;
  }
}

// ============================================================
// TEMPLATE GENERATORS
// ============================================================

class TemplateGenerator {
  constructor(schema, options) {
    this.schema = schema;
    this.options = options;
  }

  // Generate TypeScript interface for a table
  generateTableInterface(table) {
    const interfaceName = this.toPascalCase(table.name);
    const lines = [`export interface ${interfaceName} {`];

    for (const col of table.columns) {
      const optional =
        col.isNullable || col.hasDefault || col.isGenerated ? "?" : "";
      const type = this.getTypeScriptType(col);
      lines.push(`  ${col.name}${optional}: ${type};`);
    }

    lines.push("}");
    return lines.join("\n");
  }

  // Generate TypeScript interface for a function
  generateFunctionInterface(func) {
    const params = func.parameters
      .map((p) => `${p.name}: ${this.getTypeScriptType(p)}`)
      .join(", ");

    const returnType =
      func.returnType === "void"
        ? "void"
        : func.returnType.includes("[]")
          ? "any[]"
          : func.returnType === "boolean"
            ? "boolean"
            : func.returnType === "bigint"
              ? "number"
              : func.returnType === "jsonb"
                ? "Record<string, any>"
                : "any";

    return `export async function ${this.toCamelCase(func.name)}(${params}): Promise<${returnType}>`;
  }

  getTypeScriptType(column) {
    let type = column.type;

    // Check for custom enum types
    const enumType = this.schema.enums.find((e) =>
      column.rawType.includes(e.name)
    );

    if (enumType) {
      type = enumType.values.map((v) => `"${v}"`).join(" | ");
    }

    if (column.isArray) {
      type = `${type}[]`;
    }

    return type;
  }

  toPascalCase(str) {
    return str
      .split("_")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join("");
  }

  toCamelCase(str) {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  toKebabCase(str) {
    return str.replace(/_/g, "-");
  }

  toTitleCase(str) {
    return str
      .split("_")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(" ");
  }

  // Generate FormData extraction code with proper type handling
  generateFormDataExtraction(column) {
    const fieldName = column.name;

    // Skip auto-generated timestamp fields
    if (fieldName === "created_at" || fieldName === "updated_at") {
      return null;
    }

    if (column.type === "boolean") {
      return `      ${fieldName}: formData.get("${fieldName}") === "true" || formData.get("${fieldName}") === "on",`;
    } else if (column.isArray) {
      return `      ${fieldName}: formData.get("${fieldName}") ? (formData.get("${fieldName}") as string).split(",").map(s => s.trim()).filter(Boolean) : [],`;
    } else if (column.isNullable) {
      if (column.type === "number") {
        return `      ${fieldName}: formData.get("${fieldName}") ? Number(formData.get("${fieldName}")) : undefined,`;
      } else {
        return `      ${fieldName}: (formData.get("${fieldName}") as string) || undefined,`;
      }
    } else {
      if (column.type === "number") {
        return `      ${fieldName}: Number(formData.get("${fieldName}")),`;
      } else {
        return `      ${fieldName}: formData.get("${fieldName}") as string,`;
      }
    }
  }

  // Generate types file
  generateTypesFile(table) {
    const interfaceName = this.toPascalCase(table.name);
    const tableName = table.name;
    
    const lines = [
      "// Auto-generated type exports",
      "// Types are sourced from database-types.ts",
      "",
      `import type { Database } from "@/database-types";`,
      "",
      `export type ${interfaceName} = Database["public"]["Tables"]["${tableName}"]["Row"];`,
      `export type ${interfaceName}Insert = Database["public"]["Tables"]["${tableName}"]["Insert"];`,
      `export type ${interfaceName}Update = Database["public"]["Tables"]["${tableName}"]["Update"];`,
      "",
    ];

    // Add enum type exports
    for (const col of table.columns) {
      const enumType = this.schema.enums.find((e) =>
        col.rawType.includes(e.name)
      );
      if (enumType) {
        const enumName = this.toPascalCase(enumType.name);
        lines.push(`export type ${enumName} = Database["public"]["Enums"]["${enumType.name}"];`);
      }
    }

    return lines.join("\n");
  }

  // Generate server actions file
  generateActionsFile(table) {
    const interfaceName = this.toPascalCase(table.name);
    const tableName = table.name;

    return `"use server";

import { revalidatePath as rp } from "next/cache";
import { createClient } from "@/lib/supabase/server";
import type { Database } from "@/database-types";

type ${interfaceName} = Database["public"]["Tables"]["${tableName}"]["Row"];

// ============================================================
// CRUD OPERATIONS FOR ${tableName.toUpperCase()}
// ============================================================

export async function create${interfaceName}(
  prevState: { error: string; success: string },
  formData: FormData
): Promise<{ error: string; success: string }> {
  try {
    const supabase = await createClient();
    
    const data: Partial<${interfaceName}> = {
${table.columns
  .filter((col) => !col.isGenerated && !col.isPrimary)
  .map((col) => this.generateFormDataExtraction(col))
  .filter(Boolean)
  .join("\n")}
    };

    const { error } = await supabase
      .from("${tableName}")
      .insert(data);

    if (error) {
      console.error("Create error:", error);
      return { error: error.message, success: "" };
    }

    const revalidatePath = formData.get("revalidate_path") as string;
    if (revalidatePath) {
      rp(revalidatePath);
    }

    return { error: "", success: "Created successfully" };
  } catch (err) {
    console.error("Create error:", err);
    return { error: "Failed to create record", success: "" };
  }
}

export async function update${interfaceName}(
  id: number,
  prevState: { error: string; success: string },
  formData: FormData
): Promise<{ error: string; success: string }> {
  try {
    const supabase = await createClient();
    
    const data: Partial<${interfaceName}> = {
${table.columns
  .filter((col) => !col.isGenerated && !col.isPrimary)
  .map((col) => this.generateFormDataExtraction(col))
  .filter(Boolean)
  .join("\n")}
    };

    const { error } = await supabase
      .from("${tableName}")
      .update(data)
      .eq("id", id);

    if (error) {
      console.error("Update error:", error);
      return { error: error.message, success: "" };
    }

    const revalidatePath = formData.get("revalidate_path") as string;
    if (revalidatePath) {
      rp(revalidatePath);
    }

    return { error: "", success: "Updated successfully" };
  } catch (err) {
    console.error("Update error:", err);
    return { error: "Failed to update record", success: "" };
  }
}

export async function delete${interfaceName}(
  id: number
): Promise<{ error: string; success: string }> {
  try {
    const supabase = await createClient();
    
    const { error } = await supabase
      .from("${tableName}")
      .delete()
      .eq("id", id);

    if (error) {
      console.error("Delete error:", error);
      return { error: error.message, success: "" };
    }

    return { error: "", success: "Deleted successfully" };
  } catch (err) {
    console.error("Delete error:", err);
    return { error: "Failed to delete record", success: "" };
  }
}

export async function get${interfaceName}ById(
  id: number
): Promise<${interfaceName} | null> {
  try {
    const supabase = await createClient();
    
    const { data, error } = await supabase
      .from("${tableName}")
      .select("*")
      .eq("id", id)
      .single();

    if (error) {
      console.error("Get error:", error);
      return null;
    }

    return data as ${interfaceName};
  } catch (err) {
    console.error("Get error:", err);
    return null;
  }
}
`;
  }

  // Generate API route
  generateApiRoute(table) {
    const tableName = table.name;

    return `import { createClient } from "@supabase/supabase-js";
import { NextRequest } from "next/server";

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1");
    const pageSize = parseInt(searchParams.get("page_size") || "25");
    
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    let query = supabase
      .from("${tableName}")
      .select("*", { count: "exact" });

${table.columns
  .filter((col) => col.type === "string" && !col.name.endsWith("_id"))
  .slice(0, 3)
  .map(
    (col) => `    const ${col.name} = searchParams.get("${col.name}");
    if (${col.name}) {
      query = query.ilike("${col.name}", \`%\${${col.name}}%\`);
    }
`
  )
  .join("\n")}

    const { data, error, count } = await query
      .range((page - 1) * pageSize, page * pageSize - 1)
      .order("id", { ascending: false });

    if (error) {
      console.error("Query error:", error);
      return Response.json(
        { error: "Database query failed" },
        { status: 500 }
      );
    }

    return Response.json({
      data,
      total: count || 0,
      page,
      pageSize,
      totalPages: Math.ceil((count || 0) / pageSize),
    });
  } catch (error) {
    console.error("API error:", error);
    return Response.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
`;
  }

  // Generate main page
  generateMainPage(table) {
    const interfaceName = this.toPascalCase(table.name);
    const title = this.toTitleCase(table.name);
    const routeName = this.toKebabCase(table.name);

    return `import { Suspense } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { ${interfaceName}Table } from "./table";
import { ${interfaceName}Filters } from "./filters";

function PageHeader() {
  return (
    <div className="space-y-4">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">${title}</h1>
        <p className="text-muted-foreground">
          Manage ${title.toLowerCase()} records
        </p>
      </div>
    </div>
  );
}

function LoadingState() {
  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-48" />
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {Array.from({ length: 5 }).map((_, i) => (
              <Skeleton key={i} className="h-12 w-full" />
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

interface ${interfaceName}PageProps {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}

export default async function ${interfaceName}Page({
  searchParams,
}: ${interfaceName}PageProps) {
  const params = await searchParams;
  
  return (
    <div className="container mx-auto py-6 space-y-6">
      <PageHeader />
      
      <div className="flex gap-4">
        <${interfaceName}Filters />
      </div>

      <Suspense fallback={<LoadingState />}>
        <${interfaceName}Table searchParams={params} />
      </Suspense>
    </div>
  );
}
`;
  }

  // Generate loading page
  generateLoadingPage() {
    return `import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";

export default function Loading() {
  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="space-y-2">
        <Skeleton className="h-8 w-64" />
        <Skeleton className="h-4 w-96" />
      </div>
      
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-48" />
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {Array.from({ length: 5 }).map((_, i) => (
              <Skeleton key={i} className="h-12 w-full" />
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
`;
  }

  // Generate details page
  generateDetailsPage(table) {
    const interfaceName = this.toPascalCase(table.name);
    const title = this.toTitleCase(table.name);
    const routeName = this.toKebabCase(table.name);

    return `import { notFound } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { get${interfaceName}ById } from "../actions";

interface ${interfaceName}DetailsPageProps {
  params: Promise<{ id: string }>;
}

export default async function ${interfaceName}DetailsPage({
  params,
}: ${interfaceName}DetailsPageProps) {
  const { id } = await params;
  const record = await get${interfaceName}ById(parseInt(id));

  if (!record) {
    notFound();
  }

  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/${routeName}">
          <Button variant="ghost" size="icon">
            <ArrowLeft className="h-4 w-4" />
          </Button>
        </Link>
        <div>
          <h1 className="text-3xl font-bold tracking-tight">
            ${title} Details
          </h1>
          <p className="text-muted-foreground">ID: {record.id}</p>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Information</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
${table.columns
  .filter((col) => !col.name.includes("data") || col.type !== "object")
  .map(
    (col) => `            <div>
              <dt className="text-sm font-medium text-muted-foreground">
                ${this.toTitleCase(col.name)}
              </dt>
              <dd className="mt-1 text-sm">
                {record.${col.name} !== null && record.${col.name} !== undefined
                  ? String(record.${col.name})
                  : "—"}
              </dd>
            </div>`
  )
  .join("\n")}
          </dl>
        </CardContent>
      </Card>
${
  table.hasJsonb
    ? `
      <Card>
        <CardHeader>
          <CardTitle>Additional Data</CardTitle>
        </CardHeader>
        <CardContent>
          <pre className="bg-muted p-4 rounded-lg overflow-auto text-xs">
            {JSON.stringify(record.data || {}, null, 2)}
          </pre>
        </CardContent>
      </Card>`
    : ""
}
    </div>
  );
}
`;
  }

  // Generate table component
  generateTableComponent(table) {
    const interfaceName = this.toPascalCase(table.name);
    const routeName = this.toKebabCase(table.name);
    const displayColumns = table.columns
      .filter((col) => !col.name.includes("data") && col.type !== "object")
      .slice(0, 6);

    return `"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Eye, Edit, Trash } from "lucide-react";
import Link from "next/link";
import type { Database } from "@/database-types";
import { delete${interfaceName} } from "./actions";
import { toast } from "sonner";

type ${interfaceName} = Database["public"]["Tables"]["${tableName}"]["Row"];

interface ${interfaceName}TableProps {
  searchParams: { [key: string]: string | string[] | undefined };
}

export function ${interfaceName}Table({ searchParams }: ${interfaceName}TableProps) {
  const [data, setData] = useState<${interfaceName}[]>([]);
  const [loading, setLoading] = useState(true);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  useEffect(() => {
    async function fetchData() {
      setLoading(true);
      try {
        const params = new URLSearchParams();
        params.set("page", page.toString());
        params.set("page_size", "25");
        
        Object.entries(searchParams).forEach(([key, value]) => {
          if (value) params.set(key, String(value));
        });

        const response = await fetch(\`/${routeName}/api?\${params.toString()}\`);
        const result = await response.json();

        if (result.error) {
          toast.error(result.error);
        } else {
          setData(result.data || []);
          setTotal(result.total || 0);
          setTotalPages(result.totalPages || 1);
        }
      } catch (error) {
        console.error("Fetch error:", error);
        toast.error("Failed to load data");
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [searchParams, page]);

  const handleDelete = async (id: number) => {
    if (!confirm("Are you sure you want to delete this record?")) return;

    const result = await delete${interfaceName}(id);
    if (result.error) {
      toast.error(result.error);
    } else {
      toast.success(result.success);
      // Refresh data
      setPage(page);
    }
  };

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-48" />
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {Array.from({ length: 5 }).map((_, i) => (
              <Skeleton key={i} className="h-12 w-full" />
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>
          Records ({total})
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="rounded-md border">
          <table className="w-full text-sm">
            <thead className="border-b bg-muted/50">
              <tr>
                <th className="p-3 text-left font-medium">ID</th>
${displayColumns.map((col) => `                <th className="p-3 text-left font-medium">${this.toTitleCase(col.name)}</th>`).join("\n")}
                <th className="p-3 text-right font-medium">Actions</th>
              </tr>
            </thead>
            <tbody>
              {data.length === 0 ? (
                <tr>
                  <td colSpan={${displayColumns.length + 2}} className="p-8 text-center text-muted-foreground">
                    No records found
                  </td>
                </tr>
              ) : (
                data.map((record) => (
                  <tr key={record.id} className="border-b hover:bg-muted/50">
                    <td className="p-3">{record.id}</td>
${displayColumns
  .map(
    (col) => `                    <td className="p-3">
                      {record.${col.name} !== null && record.${col.name} !== undefined
                        ? String(record.${col.name})
                        : "—"}
                    </td>`
  )
  .join("\n")}
                    <td className="p-3">
                      <div className="flex justify-end gap-2">
                        <Link href={\`/${routeName}/\${record.id}\`}>
                          <Button variant="ghost" size="icon">
                            <Eye className="h-4 w-4" />
                          </Button>
                        </Link>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleDelete(record.id)}
                        >
                          <Trash className="h-4 w-4" />
                        </Button>
                      </div>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>

        {totalPages > 1 && (
          <div className="mt-4 flex items-center justify-between">
            <p className="text-sm text-muted-foreground">
              Page {page} of {totalPages}
            </p>
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                disabled={page === 1}
                onClick={() => setPage(page - 1)}
              >
                Previous
              </Button>
              <Button
                variant="outline"
                size="sm"
                disabled={page === totalPages}
                onClick={() => setPage(page + 1)}
              >
                Next
              </Button>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
`;
  }

  // Generate filters component
  generateFiltersComponent(table) {
    const interfaceName = this.toPascalCase(table.name);
    const filterColumns = table.columns
      .filter((col) => col.type === "string" && !col.name.endsWith("_id"))
      .slice(0, 3);

    return `"use client";

import { useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Filter, X } from "lucide-react";
import { useState } from "react";

export function ${interfaceName}Filters() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [open, setOpen] = useState(false);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const params = new URLSearchParams();

    formData.forEach((value, key) => {
      if (value) {
        params.set(key, value.toString());
      }
    });

    router.push(\`?\${params.toString()}\`);
    setOpen(false);
  };

  const handleClear = () => {
    router.push(window.location.pathname);
    setOpen(false);
  };

  const hasFilters = Array.from(searchParams.keys()).length > 0;

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant={hasFilters ? "default" : "outline"}>
          <Filter className="h-4 w-4 mr-2" />
          Filters
          {hasFilters && (
            <span className="ml-2 bg-background text-foreground rounded-full px-2 py-0.5 text-xs">
              {Array.from(searchParams.keys()).length}
            </span>
          )}
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Filter Records</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
${filterColumns
  .map(
    (col) => `          <div>
            <Label htmlFor="${col.name}">${this.toTitleCase(col.name)}</Label>
            <Input
              id="${col.name}"
              name="${col.name}"
              defaultValue={searchParams.get("${col.name}") || ""}
              placeholder="Filter by ${col.name.replace(/_/g, " ")}..."
            />
          </div>`
  )
  .join("\n")}

          <div className="flex gap-2 justify-end">
            <Button type="button" variant="outline" onClick={handleClear}>
              <X className="h-4 w-4 mr-2" />
              Clear
            </Button>
            <Button type="submit">Apply Filters</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
`;
  }

  // Generate create form component
  generateCreateFormComponent(table) {
    const interfaceName = this.toPascalCase(table.name);
    const routeName = this.toKebabCase(table.name);
    const editableColumns = table.columns.filter(
      (col) => !col.isGenerated && !col.isPrimary
    );

    return `"use client";

import { useActionState, useEffect } from "react";
import { create${interfaceName} } from "./actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";

const initialState = { error: "", success: "" };

export function Create${interfaceName}Form({
  onSuccess,
}: {
  onSuccess?: () => void;
}) {
  const [state, action, pending] = useActionState(
    create${interfaceName},
    initialState
  );

  useEffect(() => {
    if (state.success) {
      toast.success(state.success);
      if (onSuccess) onSuccess();
    }
    if (state.error) {
      toast.error(state.error);
    }
  }, [state.success, state.error, onSuccess]);

  return (
    <form action={action} className="space-y-4">
${editableColumns
  .filter((col) => col.name !== "created_at" && col.name !== "updated_at")
  .map((col) => {
    const isTextarea =
      col.type === "string" &&
      (col.name.includes("description") || col.name.includes("notes"));
    const inputType =
      col.type === "number"
        ? "number"
        : col.type === "boolean"
          ? "checkbox"
          : col.rawType.includes("date") || col.rawType.includes("timestamp")
            ? "datetime-local"
            : "text";

    if (isTextarea) {
      return `      <div>
        <Label htmlFor="${col.name}">
          ${this.toTitleCase(col.name)}${!col.isNullable ? " *" : ""}
        </Label>
        <Textarea
          id="${col.name}"
          name="${col.name}"
          ${!col.isNullable ? "required" : ""}
          rows={3}
        />
      </div>`;
    } else {
      return `      <div>
        <Label htmlFor="${col.name}">
          ${this.toTitleCase(col.name)}${!col.isNullable ? " *" : ""}
        </Label>
        <Input
          id="${col.name}"
          name="${col.name}"
          type="${inputType}"
          ${!col.isNullable ? "required" : ""}
        />
      </div>`;
    }
  })
  .join("\n")}

      <div className="flex gap-2 justify-end">
        <Button type="submit" disabled={pending}>
          {pending ? "Creating..." : "Create"}
        </Button>
      </div>

      {state.error && (
        <p className="text-sm text-destructive">{state.error}</p>
      )}
    </form>
  );
}
`;
  }

  // Generate component index
  generateComponentIndex(table) {
    const interfaceName = this.toPascalCase(table.name);

    return `export * from "./table";
export * from "./filters";
export * from "./create-form";
`;
  }

  // ============================================================
  // FUNCTION TEMPLATES
  // ============================================================

  generateFunctionTypes(func) {
    const interfaceName = this.toPascalCase(func.name);
    const paramsInterface = `${interfaceName}Params`;
    const resultInterface = `${interfaceName}Result`;

    // Generate parameters interface
    const paramFields = func.parameters
      .map((p) => {
        const tsType = this.getTypeScriptType(p);
        const optional = p.nullable ? "?" : "";
        return `  ${p.name}${optional}: ${tsType};`;
      })
      .join("\n");

    // For functions that return tables, we need to define the result type
    // This is a simplification - you may need to adjust based on actual return type
    return `// Generated types for ${func.name} function

export interface ${paramsInterface} {
${paramFields}
}

export interface ${resultInterface} {
  [key: string]: any;  // Adjust based on your function's return type
}
`;
  }

  generateFunctionActions(func) {
    const interfaceName = this.toPascalCase(func.name);
    const paramsInterface = `${interfaceName}Params`;
    const resultInterface = `${interfaceName}Result`;
    const isPaginated = func.returnsTable && func.isQuery;

    return `"use server";

import { createClient } from "@/lib/supabase/server";
import { ${paramsInterface}, ${resultInterface} } from "./types";

export async function execute${interfaceName}(
  prevState: { error: string; success: string },
  formData: FormData
): Promise<{ error: string; success: string; data?: ${resultInterface}[]${isPaginated ? "; totalCount?: number" : ""} }> {
  try {
    const supabase = await createClient();

    // Extract parameters from FormData
    const params: ${paramsInterface} = {
${func.parameters
  .map((p) => {
    if (p.type === "boolean") {
      return `      ${p.name}: formData.get("${p.name}") === "true" || formData.get("${p.name}") === "on",`;
    } else if (p.isArray) {
      return `      ${p.name}: formData.get("${p.name}")?.toString().split(",").map((v) => v.trim()).filter(Boolean) || [],`;
    } else if (p.type === "number" || p.type === "bigint") {
      return `      ${p.name}: formData.get("${p.name}") ? Number(formData.get("${p.name}")) : ${p.nullable ? "undefined" : "0"},`;
    } else if (p.rawType.includes("jsonb")) {
      return `      ${p.name}: formData.get("${p.name}") ? JSON.parse(formData.get("${p.name}")!.toString()) : ${p.nullable ? "undefined" : "{}"},`;
    } else {
      return `      ${p.name}: formData.get("${p.name}")?.toString()${p.nullable ? " || undefined" : ""},`;
    }
  })
  .join("\n")}
    };

    ${
      isPaginated
        ? `// Add pagination to params if present
    const page = formData.get("page") ? Number(formData.get("page")) : 1;
    const pageSize = formData.get("page_size") ? Number(formData.get("page_size")) : 25;
    
    // If function accepts filters as JSONB, add pagination there
    if (params.p_filters && typeof params.p_filters === 'object') {
      params.p_filters = { ...params.p_filters, page, page_size: pageSize };
    }`
        : ""
    }

    const { data, error } = await supabase.rpc("${func.name}", params);

    if (error) {
      return { error: error.message, success: "" };
    }

    ${
      isPaginated
        ? `// For paginated queries, count total results
    const totalCount = Array.isArray(data) ? data.length : 0;
    
    return { error: "", success: "", data, totalCount };`
        : `return { error: "", success: "${func.isMutation ? "Operation completed successfully" : "Query executed successfully"}", data };`
    }
  } catch (error: any) {
    return { error: error.message || "An error occurred", success: "" };
  }
}

export async function execute${interfaceName}WithParams(
  params: ${paramsInterface}
): Promise<{ error: string; data?: ${resultInterface}[] }> {
  try {
    const supabase = await createClient();
    const { data, error } = await supabase.rpc("${func.name}", params);

    if (error) {
      return { error: error.message };
    }

    return { error: "", data };
  } catch (error: any) {
    return { error: error.message || "An error occurred" };
  }
}
`;
  }

  generateFunctionPage(func) {
    const interfaceName = this.toPascalCase(func.name);
    const routeName = this.toKebabCase(func.name);

    return `import { Suspense } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { ParametersForm } from "./parameters-form";
import { Skeleton } from "@/components/ui/skeleton";

export default function ${interfaceName}Page() {
  return (
    <div className="container mx-auto py-8">
      <Card>
        <CardHeader>
          <CardTitle>${func.name.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase())}</CardTitle>
          <CardDescription>
            Execute the ${func.name} database function
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Suspense fallback={<Skeleton className="h-[400px] w-full" />}>
            <ParametersForm />
          </Suspense>
        </CardContent>
      </Card>
    </div>
  );
}
`;
  }

  generateParametersForm(func) {
    const interfaceName = this.toPascalCase(func.name);
    const isPaginated = func.returnsTable && func.isQuery;

    return `"use client";

import { useActionState, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card } from "@/components/ui/card";
import { execute${interfaceName} } from "./actions";
import { ${interfaceName}Result } from "./types";
import { ResultsTable } from "./results-table";
import { toast } from "sonner";

const initialState = { error: "", success: "" };

export function ParametersForm() {
  const [state, formAction] = useActionState(execute${interfaceName}, initialState);
  const [results, setResults] = useState<${interfaceName}Result[]>([]);
  ${isPaginated ? "const [totalCount, setTotalCount] = useState(0);" : ""}
  ${isPaginated ? "const [currentPage, setCurrentPage] = useState(1);" : ""}
  ${isPaginated ? "const [pageSize, setPageSize] = useState(25);" : ""}
  const [lastFormData, setLastFormData] = useState<FormData | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>, page = 1) => {
    e.preventDefault();
    const form = e.currentTarget;
    const formData = new FormData(form);
    
    setIsLoading(true);
    ${isPaginated ? 'formData.set("page", page.toString());' : ""}
    ${isPaginated ? 'formData.set("page_size", pageSize.toString());' : ""}
    
    try {
      const result = await execute${interfaceName}(initialState, formData);
      
      if (result.error) {
        toast.error(result.error);
      } else if (result.success) {
        ${func.isMutation ? "toast.success(result.success);" : ""}
        if (result.data) {
          setResults(result.data);
          ${isPaginated ? "setTotalCount(result.totalCount || result.data.length);" : ""}
          ${isPaginated ? "setCurrentPage(page);" : ""}
        }
      }
      setLastFormData(formData);
    } finally {
      setIsLoading(false);
    }
  };

  ${
    isPaginated
      ? `const handlePageChange = (newPage: number) => {
    if (lastFormData) {
      const fakeEvent = {
        preventDefault: () => {},
        currentTarget: document.querySelector('form') as HTMLFormElement
      } as React.FormEvent<HTMLFormElement>;
      
      // Restore the form data
      const form = document.querySelector('form');
      if (form) {
        for (const [key, value] of Array.from(lastFormData.entries())) {
          const input = form.elements.namedItem(key) as HTMLInputElement | HTMLTextAreaElement;
          if (input && key !== 'page' && key !== 'page_size') {
            input.value = value.toString();
          }
        }
      }
      
      handleSubmit(fakeEvent, newPage);
    }
  };`
      : ""
  }

  return (
    <div className="space-y-6">
      <form onSubmit={(e) => handleSubmit(e, 1)} className="space-y-4">
${func.parameters
  .map((p) => {
    const label = p.name
      .replace(/_/g, " ")
      .replace(/\b\w/g, (l) => l.toUpperCase());
    if (p.type === "boolean") {
      return `        <div className="space-y-2">
          <Label htmlFor="${p.name}">${label}</Label>
          <input
            type="checkbox"
            id="${p.name}"
            name="${p.name}"
            className="ml-2"
          />
        </div>`;
    } else if (p.rawType.includes("jsonb")) {
      return `        <div className="space-y-2">
          <Label htmlFor="${p.name}">${label}</Label>
          <textarea
            id="${p.name}"
            name="${p.name}"
            className="w-full min-h-[100px] p-2 border rounded"
            placeholder='{"key": "value"}'
          />
        </div>`;
    } else {
      return `        <div className="space-y-2">
          <Label htmlFor="${p.name}">${label}</Label>
          <Input
            type="${p.type === "number" || p.type === "bigint" ? "number" : "text"}"
            id="${p.name}"
            name="${p.name}"
            ${!p.nullable ? "required" : ""}
          />
        </div>`;
    }
  })
  .join("\n")}
        
        <Button type="submit" disabled={isLoading}>
          {isLoading ? "${func.isMutation ? "Executing" : "Searching"}..." : "${func.isMutation ? "Execute" : "Search"}"}
        </Button>
      </form>

      ${
        func.returnsTable && func.isQuery
          ? `{results.length > 0 && (
        <div className="space-y-4">
          <ResultsTable results={results} />
          
          {/* Pagination Controls */}
          <div className="flex items-center justify-between">
            <div className="text-sm text-muted-foreground">
              Showing {Math.min((currentPage - 1) * pageSize + 1, totalCount)} to {Math.min(currentPage * pageSize, totalCount)} of {totalCount} results
            </div>
            <div className="flex items-center space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => handlePageChange(currentPage - 1)}
                disabled={currentPage === 1}
              >
                Previous
              </Button>
              <div className="text-sm">
                Page {currentPage} of {Math.ceil(totalCount / pageSize)}
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => handlePageChange(currentPage + 1)}
                disabled={currentPage >= Math.ceil(totalCount / pageSize)}
              >
                Next
              </Button>
            </div>
          </div>
        </div>
      )}`
          : func.isMutation
            ? `{state.success && (
        <div className="p-4 bg-green-50 dark:bg-green-950 border border-green-200 dark:border-green-800 rounded-md">
          <p className="text-green-800 dark:text-green-200">{state.success}</p>
        </div>
      )}
      {state.error && (
        <div className="p-4 bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 rounded-md">
          <p className="text-red-800 dark:text-red-200">{state.error}</p>
        </div>
      )}`
            : `{results.length > 0 && (
        <ResultsTable results={results} />
      )}`
      }
    </div>
  );
}
`;
  }

  generateFunctionResultsTable(func) {
    const interfaceName = this.toPascalCase(func.name);

    return `"use client";

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { ${interfaceName}Result } from "./types";

interface ResultsTableProps {
  results: ${interfaceName}Result[];
}

export function ResultsTable({ results }: ResultsTableProps) {
  if (results.length === 0) {
    return <p className="text-muted-foreground">No results found.</p>;
  }

  // Get column headers from the first result
  const columns = Object.keys(results[0]);

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            {columns.map((col) => (
              <TableHead key={col}>
                {col.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase())}
              </TableHead>
            ))}
          </TableRow>
        </TableHeader>
        <TableBody>
          {results.map((row, idx) => (
            <TableRow key={idx}>
              {columns.map((col) => (
                <TableCell key={col}>
                  {typeof row[col] === "object"
                    ? JSON.stringify(row[col])
                    : String(row[col] ?? "")}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
`;
  }

  generateFunctionApiRoute(func) {
    const interfaceName = this.toPascalCase(func.name);

    return `import { createClient } from "@/lib/supabase/server";
import { NextRequest, NextResponse } from "next/server";

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const params = await request.json();

    const { data, error } = await supabase.rpc("${func.name}", params);

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(data);
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message || "An error occurred" },
      { status: 500 }
    );
  }
}
`;
  }

  generateFunctionComponentIndex(func) {
    return `export * from "./parameters-form";
export * from "./results-table";
`;
  }
}

// ============================================================
// FILE SYSTEM UTILITIES
// ============================================================

class FileSystemManager {
  constructor(options) {
    this.options = options;
  }

  ensureDirectory(dirPath) {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }

  writeFile(filePath, content) {
    if (this.options.dryRun) {
      console.log(`[DRY RUN] Would create: ${filePath}`);
      return;
    }

    if (fs.existsSync(filePath) && !this.options.force) {
      console.log(`[SKIP] File exists: ${filePath}`);
      return;
    }

    this.ensureDirectory(path.dirname(filePath));
    fs.writeFileSync(filePath, content, "utf8");
    console.log(`[CREATE] ${filePath}`);
  }

  fileExists(filePath) {
    return fs.existsSync(filePath);
  }
}

// ============================================================
// MAIN GENERATOR
// ============================================================

class UIGenerator {
  constructor(schema, options) {
    this.schema = schema;
    this.options = options;
    this.templateGen = new TemplateGenerator(schema, options);
    this.fsManager = new FileSystemManager(options);
  }

  generate() {
    console.log("\n=== SQL Schema UI Generator ===\n");
    console.log(`Schema: ${schemaFile}`);
    console.log(`Tables: ${this.schema.tables.length}`);
    console.log(`Functions: ${this.schema.functions.length}`);
    console.log(`Enums: ${this.schema.enums.length}\n`);

    if (this.options.dryRun) {
      console.log("[DRY RUN MODE - No files will be created]\n");
    }

    // Generate table UIs
    for (const table of this.schema.tables) {
      if (
        this.options.tables.length > 0 &&
        !this.options.tables.includes(table.name)
      ) {
        continue;
      }

      console.log(`\nGenerating UI for table: ${table.name}`);
      this.generateTableUI(table);
    }

    // Generate function UIs
    for (const func of this.schema.functions) {
      if (
        this.options.functions.length > 0 &&
        !this.options.functions.includes(func.name)
      ) {
        continue;
      }

      console.log(`\nGenerating UI for function: ${func.name}`);
      this.generateFunctionUI(func);
    }

    console.log("\n=== Generation Complete ===\n");
  }

  generateTableUI(table) {
    const routeName = this.templateGen.toKebabCase(table.name);
    const basePath = path.join(
      process.cwd(),
      this.options.outputDir,
      routeName
    );
    // Components now go in the same folder as the app routes
    const componentPath = basePath;

    // App routes
    if (!this.options.skip.includes("page")) {
      this.fsManager.writeFile(
        path.join(basePath, "page.tsx"),
        this.templateGen.generateMainPage(table)
      );
    }

    if (!this.options.skip.includes("loading")) {
      this.fsManager.writeFile(
        path.join(basePath, "loading.tsx"),
        this.templateGen.generateLoadingPage()
      );
    }

    if (!this.options.skip.includes("types")) {
      this.fsManager.writeFile(
        path.join(basePath, "types.ts"),
        this.templateGen.generateTypesFile(table)
      );
    }

    if (!this.options.skip.includes("actions")) {
      this.fsManager.writeFile(
        path.join(basePath, "actions.ts"),
        this.templateGen.generateActionsFile(table)
      );
    }

    // API routes
    if (!this.options.skip.includes("api")) {
      this.fsManager.writeFile(
        path.join(basePath, "api", "route.ts"),
        this.templateGen.generateApiRoute(table)
      );
    }

    // Details page
    if (!this.options.skip.includes("details")) {
      this.fsManager.writeFile(
        path.join(basePath, "[id]", "page.tsx"),
        this.templateGen.generateDetailsPage(table)
      );
    }

    // Components
    if (!this.options.skip.includes("components")) {
      this.fsManager.writeFile(
        path.join(componentPath, "table.tsx"),
        this.templateGen.generateTableComponent(table)
      );

      this.fsManager.writeFile(
        path.join(componentPath, "filters.tsx"),
        this.templateGen.generateFiltersComponent(table)
      );

      this.fsManager.writeFile(
        path.join(componentPath, "create-form.tsx"),
        this.templateGen.generateCreateFormComponent(table)
      );

      this.fsManager.writeFile(
        path.join(componentPath, "index.ts"),
        this.templateGen.generateComponentIndex(table)
      );
    }
  }

  generateFunctionUI(func) {
    const routeName = this.templateGen.toKebabCase(func.name);
    const basePath = path.join(
      process.cwd(),
      this.options.outputDir,
      routeName
    );

    // Generate main page with parameters form
    if (!this.options.skip.includes("page")) {
      this.fsManager.writeFile(
        path.join(basePath, "page.tsx"),
        this.templateGen.generateFunctionPage(func)
      );

      this.fsManager.writeFile(
        path.join(basePath, "loading.tsx"),
        this.templateGen.generateLoadingPage(func.name)
      );
    }

    // Generate types
    if (!this.options.skip.includes("types")) {
      this.fsManager.writeFile(
        path.join(basePath, "types.ts"),
        this.templateGen.generateFunctionTypes(func)
      );
    }

    // Generate actions
    if (!this.options.skip.includes("actions")) {
      this.fsManager.writeFile(
        path.join(basePath, "actions.ts"),
        this.templateGen.generateFunctionActions(func)
      );
    }

    // Generate API route
    if (!this.options.skip.includes("api")) {
      this.fsManager.writeFile(
        path.join(basePath, "api", "route.ts"),
        this.templateGen.generateFunctionApiRoute(func)
      );
    }

    // Generate components
    if (!this.options.skip.includes("components")) {
      this.fsManager.writeFile(
        path.join(basePath, "parameters-form.tsx"),
        this.templateGen.generateParametersForm(func)
      );

      this.fsManager.writeFile(
        path.join(basePath, "results-table.tsx"),
        this.templateGen.generateFunctionResultsTable(func)
      );

      this.fsManager.writeFile(
        path.join(basePath, "index.ts"),
        this.templateGen.generateFunctionComponentIndex(func)
      );
    }
  }
}

// ============================================================
// MAIN EXECUTION
// ============================================================

try {
  // Read database types file
  console.log(`Reading types from: ${resolvedTypesFile}`);
  const typesContent = fs.readFileSync(resolvedTypesFile, "utf8");

  // Parse types
  console.log("Parsing database types...");
  const parser = new DatabaseTypesParser(typesContent);
  const schema = parser.parse();

  console.log(`Found ${schema.tables.length} tables, ${schema.enums.length} enums, ${schema.functions.length} functions`);

  // Generate UI
  const generator = new UIGenerator(schema, options);
  generator.generate();
  
  console.log("\n✓ Generation complete!");
} catch (error) {
  console.error("Error:", error.message);
  console.error(error.stack);
  process.exit(1);
}
