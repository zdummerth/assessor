-- ============================================================
-- DEVNET REVIEW SCHEMA: Review Layer for External Database
-- ============================================================
-- Complete implementation with data collection tracking and mass operations
-- Focus: Flexible reviews for sales, permits, appeals with status-specific assignments

-- ============================================================
-- DEVNET ENUMS
-- ============================================================

DROP TYPE IF EXISTS public.devnet_review_kind CASCADE;
CREATE TYPE public.devnet_review_kind AS ENUM (
    'sale_review',
    'permit_review', 
    'appeal_review',
    'custom_review'
);

DROP TYPE IF EXISTS public.devnet_data_status CASCADE;
CREATE TYPE public.devnet_data_status AS ENUM (
    'not_collected',
    'in_field',
    'collected',
    'entered',
    'copied_to_devnet',
    'verified'
);

-- ============================================================
-- DEVNET EMPLOYEES (Simplified with roles)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_employees CASCADE;
CREATE TABLE public.devnet_employees (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid UNIQUE NULL, -- Links to Supabase auth
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text UNIQUE NULL,
    status text NOT NULL DEFAULT 'active',
    can_approve boolean NOT NULL DEFAULT false,
    
    -- Role information for assignments
    role text NULL, -- 'appraiser', 'supervisor', 'data_entry', 'reviewer'
    specialties text[] DEFAULT '{}', -- ['field_work', 'data_entry', 'commercial', 'residential']
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_employees_user_id_idx ON public.devnet_employees (user_id);
CREATE INDEX devnet_employees_status_idx ON public.devnet_employees (status);
CREATE INDEX devnet_employees_role_idx ON public.devnet_employees (role);

-- ============================================================
-- DEVNET DATA TABLES (Copied Daily)
-- ============================================================

-- Devnet parcels data
DROP TABLE IF EXISTS public.devnet_parcels CASCADE;
CREATE TABLE public.devnet_parcels (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_number text NOT NULL,
    start_year integer NULL,
    end_year integer NULL,
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL, -- Original ID from Devnet system
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_parcels_number_idx ON public.devnet_parcels (parcel_number);
CREATE INDEX devnet_parcels_years_idx ON public.devnet_parcels (start_year, end_year);
CREATE INDEX devnet_parcels_devnet_id_idx ON public.devnet_parcels (devnet_id);
CREATE INDEX devnet_parcels_data_gin_idx ON public.devnet_parcels USING gin (data);

-- Devnet neighborhood reports
DROP TABLE IF EXISTS public.devnet_neighborhood_report CASCADE;
CREATE TABLE public.devnet_neighborhood_report (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    neighborhood_name text NOT NULL,
    start_year integer NULL,
    end_year integer NULL,
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL,
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_neighborhood_report_name_idx ON public.devnet_neighborhood_report (neighborhood_name);
CREATE INDEX devnet_neighborhood_report_years_idx ON public.devnet_neighborhood_report (start_year, end_year);
CREATE INDEX devnet_neighborhood_report_data_gin_idx ON public.devnet_neighborhood_report USING gin (data);

-- Devnet sales data
DROP TABLE IF EXISTS public.devnet_sales CASCADE;
CREATE TABLE public.devnet_sales (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_price numeric(12,2) NULL,
    sale_date date NULL,
    sale_type text NULL,
    sale_status text NULL,
    
    -- Additional sale details in JSONB for flexibility
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL,
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_sales_date_idx ON public.devnet_sales (sale_date DESC);
CREATE INDEX devnet_sales_price_idx ON public.devnet_sales (sale_price);
CREATE INDEX devnet_sales_type_idx ON public.devnet_sales (sale_type);
CREATE INDEX devnet_sales_devnet_id_idx ON public.devnet_sales (devnet_id);
CREATE INDEX devnet_sales_data_gin_idx ON public.devnet_sales USING gin (data);

-- Junction table for many-to-many sales/parcels relationship
DROP TABLE IF EXISTS public.devnet_sale_parcels CASCADE;
CREATE TABLE public.devnet_sale_parcels (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id bigint NOT NULL REFERENCES public.devnet_sales (id) ON DELETE CASCADE,
    parcel_id bigint NOT NULL REFERENCES public.devnet_parcels (id) ON DELETE CASCADE,
    
    -- Additional relationship data
    data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (sale_id, parcel_id)
);

CREATE INDEX devnet_sale_parcels_sale_idx ON public.devnet_sale_parcels (sale_id);
CREATE INDEX devnet_sale_parcels_parcel_idx ON public.devnet_sale_parcels (parcel_id);

-- ============================================================
-- VIN LOOKUP AND GUIDE TABLES
-- ============================================================

-- Enable pg_trgm extension for text similarity searches
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Enable http extension for external API calls
CREATE EXTENSION IF NOT EXISTS http;

-- VIN lookup table for 2026
DROP TABLE IF EXISTS public.vin_lookup_2026 CASCADE;
CREATE TABLE public.vin_lookup_2026 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vin text NOT NULL,
    model_year text NULL,
    type text NULL,
    description text NULL,
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for VIN lookup table
CREATE INDEX vin_lookup_2026_vin_idx ON public.vin_lookup_2026 (vin);
CREATE INDEX vin_lookup_2026_model_year_idx ON public.vin_lookup_2026 (model_year);
CREATE INDEX vin_lookup_2026_type_idx ON public.vin_lookup_2026 (type);
-- GIN index for trigram text similarity search on description
CREATE INDEX vin_lookup_2026_description_trgm_idx ON public.vin_lookup_2026 USING gin (description gin_trgm_ops);

-- Normalized guide structure: vehicles and their values
DROP TABLE IF EXISTS public.guide_vehicle_values CASCADE;
DROP TABLE IF EXISTS public.guide_vehicles CASCADE;

-- Guide vehicles table - unique vehicle descriptions
CREATE TABLE public.guide_vehicles (
    vehicle_id text PRIMARY KEY,
    type text,
    make text NOT NULL,
    model text NOT NULL,
    "trim" text,
    description text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for guide vehicles table
CREATE INDEX guide_vehicles_type_idx ON public.guide_vehicles (type);
CREATE INDEX guide_vehicles_make_idx ON public.guide_vehicles (make);
CREATE INDEX guide_vehicles_model_idx ON public.guide_vehicles (model);
CREATE INDEX guide_vehicles_description_trgm_idx ON public.guide_vehicles USING gin (description gin_trgm_ops);
-- GIN index for trigram text similarity search on make/model/trim
CREATE INDEX guide_vehicles_make_trgm_idx ON public.guide_vehicles USING gin (make gin_trgm_ops);
CREATE INDEX guide_vehicles_model_trgm_idx ON public.guide_vehicles USING gin (model gin_trgm_ops);
CREATE INDEX guide_vehicles_trim_trgm_idx ON public.guide_vehicles USING gin (trim gin_trgm_ops);

-- Guide vehicle values table - year/value pairs by guide year
CREATE TABLE public.guide_vehicle_values (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vehicle_id text NOT NULL REFERENCES public.guide_vehicles(vehicle_id) ON DELETE CASCADE,
    guide_year integer NOT NULL,
    year integer NOT NULL,
    value numeric(10, 2) NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (vehicle_id, guide_year, year)
);

-- Indexes for guide vehicle values table
CREATE INDEX guide_vehicle_values_vehicle_idx ON public.guide_vehicle_values (vehicle_id);
CREATE INDEX guide_vehicle_values_guide_year_idx ON public.guide_vehicle_values (guide_year);
CREATE INDEX guide_vehicle_values_year_idx ON public.guide_vehicle_values (year);
CREATE INDEX guide_vehicle_values_value_idx ON public.guide_vehicle_values (value);

-- Account vehicles table - vehicles from devnet reports with guide value matches
DROP TABLE IF EXISTS public.account_vehicles CASCADE;
CREATE TABLE public.account_vehicles (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    account_number text NOT NULL,
    vehicle_id text NOT NULL REFERENCES public.guide_vehicles(vehicle_id),
    account_year integer NOT NULL,
    model_year integer NOT NULL,
    description text NOT NULL,
    vin_number text,
    current_value numeric,
    guide_value numeric,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for account vehicles table
CREATE INDEX account_vehicles_account_number_idx ON public.account_vehicles (account_number);
CREATE INDEX account_vehicles_vehicle_id_idx ON public.account_vehicles (vehicle_id);
CREATE INDEX account_vehicles_account_year_idx ON public.account_vehicles (account_year);
CREATE INDEX account_vehicles_model_year_idx ON public.account_vehicles (model_year);
CREATE INDEX account_vehicles_vin_idx ON public.account_vehicles (vin_number);
CREATE INDEX account_vehicles_current_value_idx ON public.account_vehicles (current_value);
CREATE INDEX account_vehicles_description_trgm_idx ON public.account_vehicles USING gin (description gin_trgm_ops);

-- ============================================================
-- VIN SEARCH FUNCTION WITH GUIDE MATCHING
-- ============================================================

-- Decode VIN using NHTSA API and find matching guide vehicles with weighted scoring
DROP FUNCTION IF EXISTS decode_vin_nhtsa CASCADE;
CREATE OR REPLACE FUNCTION decode_vin_nhtsa(
    p_vin text,
    p_year_tolerance integer DEFAULT 1,
    p_match_threshold numeric DEFAULT 0.4,
    p_make_threshold numeric DEFAULT 0.1,
    p_model_threshold numeric DEFAULT 0.6,
    p_trim_threshold numeric DEFAULT 0.3,
    p_limit integer DEFAULT 10,
    p_guide_year integer DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    v_url text;
    v_response http_response;
    v_api_result jsonb;
    v_make text;
    v_model text;
    v_model_year text;
    v_trim text;
    v_displacement text;
    v_body_class text;
    v_drive_type text;
    v_fuel_type text;
    v_vehicle_type text;
    v_series text;
    v_series2 text;
    v_trailer_length text;
    v_trailer_type text;
    v_search_string text;
    v_guide_matches jsonb;
    v_model_year_int integer;
BEGIN
    -- Build API URL
    v_url := 'https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVinValues/' || p_vin || '?format=json';
    
    -- Make HTTP GET request
    BEGIN
        v_response := http_get(v_url);
        
        -- Parse JSON response
        v_api_result := v_response.content::jsonb->'Results'->0;
        
        -- Extract vehicle fields from API response and replace 'Not Applicable' with empty string
        v_make := NULLIF(v_api_result->>'Make', 'Not Applicable');
        v_model := NULLIF(v_api_result->>'Model', 'Not Applicable');
        v_model_year := NULLIF(v_api_result->>'ModelYear', 'Not Applicable');
        v_trim := NULLIF(v_api_result->>'Trim', 'Not Applicable');
        v_displacement := NULLIF(v_api_result->>'DisplacementL', 'Not Applicable');
        v_body_class := NULLIF(v_api_result->>'BodyClass', 'Not Applicable');
        v_drive_type := NULLIF(v_api_result->>'DriveType', 'Not Applicable');
        v_fuel_type := NULLIF(v_api_result->>'FuelTypePrimary', 'Not Applicable');
        v_vehicle_type := NULLIF(v_api_result->>'VehicleType', 'Not Applicable');
        v_series := NULLIF(v_api_result->>'Series', 'Not Applicable');
        v_series2 := NULLIF(v_api_result->>'Series2', 'Not Applicable');
        v_trailer_length := NULLIF(v_api_result->>'TrailerLength', 'Not Applicable');
        v_trailer_type := NULLIF(v_api_result->>'TrailerBodyType', 'Not Applicable');
        
        -- Convert model year to integer for tolerance calculations
        v_model_year_int := NULLIF(v_model_year, '')::integer;
        
        -- Build enhanced search string from multiple fields
        v_search_string := TRIM(
            COALESCE(v_make, '') || ' ' || 
            COALESCE(v_model, '') || ' ' || 
            COALESCE(v_trim, '') || ' ' || 
            COALESCE(v_displacement, '') || 
            CASE WHEN v_displacement IS NOT NULL AND v_displacement != '' THEN 'L' ELSE '' END || ' ' ||
            COALESCE(v_body_class, '') || ' ' ||
            COALESCE(v_drive_type, '') || ' ' ||
            COALESCE(NULLIF(v_series, ''), '') || ' ' ||
            COALESCE(NULLIF(v_series2, ''), '') || ' ' ||
            COALESCE(v_trailer_length, '') || ' ' ||
            COALESCE(v_trailer_type, '')
        );
        
        -- Search for matching guide vehicles using description similarity
        -- Two-pass strategy: strict then relaxed if no results
        WITH scored_matches AS (
            SELECT 
                gv.vehicle_id,
                gv.type,
                gv.make,
                gv.model,
                gv.trim,
                gv.description,
                -- Individual similarity scores (for reference only)
                similarity(LOWER(gv.make), LOWER(COALESCE(v_make, ''))) AS make_similarity,
                similarity(
                    REPLACE(LOWER(gv.model), '-', ''), 
                    REPLACE(LOWER(COALESCE(v_model, '')), '-', '')
                ) AS model_similarity,
                similarity(LOWER(gv.trim), LOWER(v_search_string)) AS trim_similarity,
                word_similarity(LOWER(COALESCE(v_trim, '')), LOWER(gv.trim)) AS word_trim_similarity,
                -- Overall description similarity
                similarity(LOWER(gv.description), LOWER(v_search_string)) AS description_similarity,
                -- Individual field bonuses for matches in description
                CASE 
                    WHEN v_make IS NOT NULL AND gv.description ILIKE '%' || v_make || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_model IS NOT NULL AND gv.description ILIKE '%' || v_model || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_trim IS NOT NULL AND gv.description ILIKE '%' || v_trim || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_body_class IS NOT NULL AND gv.description ILIKE '%' || v_body_class || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_vehicle_type IS NOT NULL AND gv.description ILIKE '%' || v_vehicle_type || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_drive_type IS NOT NULL AND gv.description ILIKE '%' || v_drive_type || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_fuel_type IS NOT NULL AND gv.description ILIKE '%' || v_fuel_type || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_series IS NOT NULL AND v_series != '' AND gv.description ILIKE '%' || v_series || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_series2 IS NOT NULL AND v_series2 != '' AND gv.description ILIKE '%' || v_series2 || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_trailer_type IS NOT NULL AND gv.description ILIKE '%' || v_trailer_type || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_trailer_length IS NOT NULL AND gv.description ILIKE '%' || v_trailer_length || '%' 
                    THEN 0.02 
                    ELSE 0 
                END +
                CASE 
                    WHEN v_displacement IS NOT NULL AND gv.description ILIKE '%' || v_displacement || '%' 
                    THEN 0.02 
                    ELSE 0 
                END AS field_bonus,
                -- Count available values for this model year (with tolerance)
                (
                    SELECT COUNT(*)
                    FROM guide_vehicle_values gvv
                    WHERE gvv.vehicle_id = gv.vehicle_id
                        AND v_model_year_int IS NOT NULL
                        AND ABS(gvv.year::integer - v_model_year_int) <= p_year_tolerance
                ) AS value_count
            FROM guide_vehicles gv
        ),
        ranked_matches AS (
            SELECT 
                sm.*,
                (sm.description_similarity + sm.field_bonus) AS final_score,
                CASE 
                    WHEN (sm.description_similarity + sm.field_bonus) >= 0.4 THEN 'high'
                    WHEN (sm.description_similarity + sm.field_bonus) >= 0.25 THEN 'medium'
                    ELSE 'low'
                END AS confidence_level
            FROM scored_matches sm
            WHERE (sm.description_similarity + sm.field_bonus) >= p_match_threshold
            ORDER BY 
                (sm.value_count > 0)::int DESC,  -- Prioritize vehicles with values
                (sm.description_similarity + sm.field_bonus) DESC,
                sm.value_count DESC
            LIMIT p_limit
        )
        SELECT jsonb_agg(
            jsonb_build_object(
                'vehicle_id', rm.vehicle_id,
                'type', rm.type,
                'make', rm.make,
                'model', rm.model,
                'trim', rm.trim,
                'description', rm.description,
                'match_scores', jsonb_build_object(
                    'final_score', ROUND(rm.final_score::numeric, 3),
                    'description_similarity', ROUND(rm.description_similarity::numeric, 3),
                    'field_bonus', ROUND(rm.field_bonus::numeric, 3),
                    'make_similarity', ROUND(rm.make_similarity::numeric, 3),
                    'model_similarity', ROUND(rm.model_similarity::numeric, 3),
                    'trim_similarity', ROUND(rm.trim_similarity::numeric, 3),
                    'word_trim_similarity', ROUND(rm.word_trim_similarity::numeric, 3),
                    'confidence_level', rm.confidence_level
                ),
                'value_count', rm.value_count,
                'values', (
                    SELECT jsonb_agg(
                        jsonb_build_object(
                            'guide_year', gvv.guide_year,
                            'year', gvv.year,
                            'value', gvv.value
                        ) ORDER BY gvv.guide_year DESC, gvv.year DESC
                    )
                    FROM guide_vehicle_values gvv
                    WHERE gvv.vehicle_id = rm.vehicle_id
                        AND v_model_year_int IS NOT NULL
                        AND ABS(gvv.year::integer - v_model_year_int) <= p_year_tolerance
                        AND (p_guide_year IS NULL OR gvv.guide_year = p_guide_year)
                )
            )
        )
        INTO v_guide_matches
        FROM ranked_matches rm;
        
        -- Return combined API result and matching guide vehicles
        RETURN jsonb_build_object(
            'vin', p_vin,
            'api_data', v_api_result,
            'extracted_fields', jsonb_build_object(
                'make', v_make,
                'model', v_model,
                'model_year', v_model_year,
                'trim', v_trim,
                'displacement', v_displacement,
                'body_class', v_body_class,
                'drive_type', v_drive_type,
                'fuel_type', v_fuel_type,
                'vehicle_type', v_vehicle_type,
                'series', v_series,
                'series2', v_series2,
                'search_string', v_search_string
            ),
            'match_parameters', jsonb_build_object(
                'year_tolerance', p_year_tolerance,
                'match_threshold', p_match_threshold,
                'make_threshold', p_make_threshold,
                'model_threshold', p_model_threshold,
                'trim_threshold', p_trim_threshold,
                'result_limit', p_limit,
                'guide_year', p_guide_year
            ),
            'guide_matches', COALESCE(v_guide_matches, '[]'::jsonb),
            'match_count', COALESCE(jsonb_array_length(v_guide_matches), 0)
        );
        
    EXCEPTION WHEN OTHERS THEN
        -- Return error information if API call fails
        RETURN jsonb_build_object(
            'error', true,
            'message', SQLERRM,
            'vin', p_vin
        );
    END;
END;
$$;

-- Search VINs and find matching guide descriptions with all values
DROP FUNCTION IF EXISTS search_vin_with_guide_matches CASCADE;
CREATE OR REPLACE FUNCTION search_vin_with_guide_matches(
    p_vin text,
    p_guide_year integer DEFAULT 2026,
    p_match_limit integer DEFAULT 5
)
RETURNS TABLE (
    vin_id bigint,
    vin text,
    model_year text,
    type text,
    vin_description text,
    guide_results jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_vin_length integer;
    v_search_pattern text;
BEGIN
    -- Get the length of the input VIN
    v_vin_length := length(p_vin);
    
    RETURN QUERY
    WITH vin_matches AS (
        -- Find matching VINs using wildcard pattern matching
        SELECT 
            v.id,
            v.vin,
            v.model_year,
            v.type,
            v.description
        FROM public.vin_lookup_2026 v
        WHERE 
            CASE 
                WHEN v_vin_length >= length(v.vin) THEN
                    substring(p_vin, 1, length(v.vin)) LIKE replace(v.vin, '?', '_')
                ELSE
                    p_vin || repeat('_', length(v.vin) - v_vin_length) LIKE replace(v.vin, '?', '_')
            END
        LIMIT 100
    ),
    guide_matches AS (
        -- For each VIN match, find top N most similar guide vehicles
        SELECT 
            vm.id as vin_id,
            vm.vin,
            vm.model_year,
            vm.type,
            vm.description as vin_description,
            jsonb_agg(
                jsonb_build_object(
                    'vehicle_id', gv.vehicle_id,
                    'type', gv.type,
                    'make', gv.make,
                    'model', gv.model,
                    'trim', gv.trim,
                    'similarity_score', gv.similarity_score,
                    'values', gv.values
                )
                ORDER BY gv.similarity_score DESC
            ) FILTER (WHERE gv.vehicle_id IS NOT NULL) as guide_results
        FROM vin_matches vm
        LEFT JOIN LATERAL (
            SELECT 
                g.vehicle_id,
                g.type,
                g.make,
                g.model,
                g.trim,
                similarity(
                    COALESCE(vm.description, ''), 
                    g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '')
                ) as similarity_score,
                (
                    SELECT jsonb_agg(
                        jsonb_build_object(
                            'guide_year', v.guide_year,
                            'year', v.year,
                            'value', v.value
                        )
                        ORDER BY v.year DESC
                    )
                    FROM public.guide_vehicle_values v
                    WHERE v.vehicle_id = g.vehicle_id
                        AND v.guide_year = p_guide_year
                ) as values
            FROM public.guide_vehicles g
            ORDER BY similarity(
                COALESCE(vm.description, ''), 
                g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '')
            ) DESC
            LIMIT p_match_limit
        ) gv ON true
        GROUP BY vm.id, vm.vin, vm.model_year, vm.type, vm.description
    )
    SELECT 
        gm.vin_id,
        gm.vin,
        gm.model_year,
        gm.type,
        gm.vin_description,
        COALESCE(gm.guide_results, '[]'::jsonb) as guide_results
    FROM guide_matches gm
    ORDER BY gm.vin_id;
END;
$$;

-- ============================================================
-- UNIFIED VEHICLE SEARCH FUNCTION
-- ============================================================

-- Unified search function: VIN or description with intelligent fallback
DROP FUNCTION IF EXISTS search_vehicle_unified CASCADE;
CREATE OR REPLACE FUNCTION search_vehicle_unified(
    p_search_text text,
    p_search_type text DEFAULT 'auto', -- 'auto', 'vin', 'description'
    p_guide_year integer DEFAULT 2026,
    p_match_limit integer DEFAULT 10,
    p_similarity_threshold numeric DEFAULT 0.4,
    p_year_tolerance integer DEFAULT 1
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    v_is_vin boolean;
    v_vin_lookup_count integer;
    v_result jsonb;
    v_search_type text;
BEGIN
    -- Normalize search text
    p_search_text := trim(p_search_text);
    
    -- Determine search type
    v_search_type := lower(p_search_type);
    
    -- Auto-detect if searching by VIN (17 chars, alphanumeric) or partial VIN (8-16 chars)
    IF v_search_type = 'auto' THEN
        v_is_vin := (length(p_search_text) BETWEEN 8 AND 17) 
                    AND (p_search_text ~ '^[A-HJ-NPR-Z0-9]+$');
        v_search_type := CASE WHEN v_is_vin THEN 'vin' ELSE 'description' END;
    END IF;
    
    -- VIN SEARCH PATH
    IF v_search_type = 'vin' THEN
        -- Step 1: Check vin_lookup_2026 table for matches
        WITH vin_matches AS (
            SELECT 
                v.id,
                v.vin,
                v.model_year,
                v.type,
                v.description
            FROM public.vin_lookup_2026 v
            WHERE 
                CASE 
                    WHEN length(p_search_text) >= length(v.vin) THEN
                        substring(p_search_text, 1, length(v.vin)) LIKE replace(v.vin, '?', '_')
                    ELSE
                        p_search_text || repeat('_', length(v.vin) - length(p_search_text)) LIKE replace(v.vin, '?', '_')
                END
            LIMIT 100
        ),
        guide_matches AS (
            SELECT 
                vm.id as vin_id,
                vm.vin,
                vm.model_year,
                vm.type,
                vm.description as vin_description,
                jsonb_agg(
                    jsonb_build_object(
                        'vehicle_id', gv.vehicle_id,
                        'type', gv.type,
                        'make', gv.make,
                        'model', gv.model,
                        'trim', gv.trim,
                        'description', gv.description,
                        'similarity_score', gv.similarity_score,
                        'values', gv.values
                    )
                    ORDER BY gv.similarity_score DESC
                ) FILTER (WHERE gv.vehicle_id IS NOT NULL) as matches
            FROM vin_matches vm
            LEFT JOIN LATERAL (
                SELECT 
                    g.vehicle_id,
                    g.type,
                    g.make,
                    g.model,
                    g.trim,
                    g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '') as description,
                    similarity(
                        COALESCE(vm.description, ''), 
                        g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '')
                    ) as similarity_score,
                    (
                        SELECT jsonb_agg(
                            jsonb_build_object(
                                'guide_year', gvv.guide_year,
                                'year', gvv.year,
                                'value', gvv.value
                            )
                            ORDER BY gvv.guide_year DESC, gvv.year DESC
                        )
                        FROM public.guide_vehicle_values gvv
                        WHERE gvv.vehicle_id = g.vehicle_id
                            AND (p_guide_year IS NULL OR gvv.guide_year = p_guide_year)
                    ) as values
                FROM public.guide_vehicles g
                WHERE similarity(
                    COALESCE(vm.description, ''), 
                    g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '')
                ) > p_similarity_threshold
                ORDER BY similarity_score DESC
                LIMIT p_match_limit
            ) gv ON true
            GROUP BY vm.id, vm.vin, vm.model_year, vm.type, vm.description
        )
        SELECT jsonb_build_object(
            'search_text', p_search_text,
            'search_type', 'vin',
            'source', 'vin_lookup_table',
            'match_count', COUNT(*),
            'results', jsonb_agg(
                jsonb_build_object(
                    'vin_id', gm.vin_id,
                    'vin', gm.vin,
                    'model_year', gm.model_year,
                    'type', gm.type,
                    'vin_description', gm.vin_description,
                    'guide_matches', COALESCE(gm.matches, '[]'::jsonb)
                )
            )
        )
        INTO v_result
        FROM guide_matches gm;
        
        -- Get count of VIN lookup matches from the result
        v_vin_lookup_count := COALESCE((v_result->>'match_count')::integer, 0);
        
        -- Step 2: If no matches in lookup table, try NHTSA API
        IF v_vin_lookup_count = 0 AND length(p_search_text) = 17 THEN
            -- Call NHTSA API (reusing existing decode_vin_nhtsa logic)
            v_result := decode_vin_nhtsa(
                p_search_text,
                p_year_tolerance,
                p_similarity_threshold,
                0.1, -- make threshold
                0.6, -- model threshold
                0.3, -- trim threshold
                p_match_limit,
                p_guide_year
            );
            
            -- Wrap result to match unified format
            v_result := jsonb_build_object(
                'search_text', p_search_text,
                'search_type', 'vin',
                'source', 'nhtsa_api',
                'match_count', COALESCE((v_result->>'match_count')::integer, 0),
                'results', jsonb_build_array(v_result)
            );
        END IF;
        
        RETURN COALESCE(v_result, jsonb_build_object(
            'search_text', p_search_text,
            'search_type', 'vin',
            'source', 'none',
            'match_count', 0,
            'results', '[]'::jsonb,
            'message', 'No matches found in VIN lookup or NHTSA API'
        ));
        
    -- DESCRIPTION SEARCH PATH
    ELSE
        WITH vehicle_matches AS (
            SELECT 
                gv.vehicle_id,
                gv.type,
                gv.make,
                gv.model,
                gv.trim,
                gv.description,
                GREATEST(
                    similarity(p_search_text, gv.description),
                    similarity(p_search_text, gv.make || ' ' || gv.model),
                    similarity(p_search_text, gv.make),
                    similarity(p_search_text, gv.model),
                    similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.description, '[.-]', '', 'g')),
                    similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.make, '[.-]', '', 'g')),
                    similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.model, '[.-]', '', 'g'))
                ) as similarity_score
            FROM public.guide_vehicles gv
            WHERE 
                p_search_text IS NOT NULL
                AND (
                    gv.description % p_search_text
                    OR gv.make % p_search_text
                    OR gv.model % p_search_text
                    OR gv.trim % p_search_text
                    OR regexp_replace(gv.description, '[.-]', '', 'g') % regexp_replace(p_search_text, '[.-]', '', 'g')
                    OR regexp_replace(gv.make, '[.-]', '', 'g') % regexp_replace(p_search_text, '[.-]', '', 'g')
                    OR regexp_replace(gv.model, '[.-]', '', 'g') % regexp_replace(p_search_text, '[.-]', '', 'g')
                )
            ORDER BY similarity_score DESC
            LIMIT LEAST(p_match_limit, 100)
        )
        SELECT jsonb_build_object(
            'search_text', p_search_text,
            'search_type', 'description',
            'source', 'guide_vehicles',
            'match_count', COUNT(*),
            'results', jsonb_agg(
                jsonb_build_object(
                    'vehicle_id', vm.vehicle_id,
                    'type', vm.type,
                    'make', vm.make,
                    'model', vm.model,
                    'trim', vm.trim,
                    'description', vm.description,
                    'similarity_score', vm.similarity_score,
                    'values', COALESCE(
                        (
                            SELECT jsonb_agg(
                                jsonb_build_object(
                                    'guide_year', gvv.guide_year,
                                    'year', gvv.year,
                                    'value', gvv.value
                                )
                                ORDER BY gvv.guide_year DESC, gvv.year DESC
                            )
                            FROM public.guide_vehicle_values gvv
                            WHERE gvv.vehicle_id = vm.vehicle_id
                                AND (p_guide_year IS NULL OR gvv.guide_year = p_guide_year)
                        ),
                        '[]'::jsonb
                    )
                )
                ORDER BY vm.similarity_score DESC
            )
        )
        INTO v_result
        FROM vehicle_matches vm;
        
        RETURN COALESCE(v_result, jsonb_build_object(
            'search_text', p_search_text,
            'search_type', 'description',
            'source', 'guide_vehicles',
            'match_count', 0,
            'results', '[]'::jsonb,
            'message', 'No matches found'
        ));
    END IF;
END;
$$;

-- ============================================================
-- GUIDE SIMILARITY SEARCH FUNCTION (Legacy - use search_vehicle_unified)
-- ============================================================

-- Search guide vehicles by text similarity with all values
DROP FUNCTION IF EXISTS search_guide_by_description CASCADE;
CREATE OR REPLACE FUNCTION search_guide_by_description(
    p_search_text text,
    p_guide_year integer DEFAULT NULL,
    p_limit integer DEFAULT 25
)
RETURNS TABLE (
    vehicle_id text,
    type text,
    make text,
    model text,
    "trim" text,
    similarity_score real,
    "values" jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH vehicle_matches AS (
        SELECT 
            gv.vehicle_id,
            gv.type,
            gv.make,
            gv.model,
            gv.trim,
            GREATEST(
                similarity(
                    regexp_replace(p_search_text, '[.-]', '', 'g'),
                    regexp_replace(gv.make || ' ' || gv.model || ' ' || COALESCE(gv.trim, ''), '[.-]', '', 'g')
                ),
                similarity(
                    regexp_replace(p_search_text, '[.-]', '', 'g'),
                    regexp_replace(gv.make || ' ' || gv.model, '[.-]', '', 'g')
                ),
                similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.make, '[.-]', '', 'g')),
                similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.model, '[.-]', '', 'g'))
            ) as similarity_score
        FROM public.guide_vehicles gv
        WHERE 
            p_search_text IS NOT NULL
            AND trim(p_search_text) != ''
            -- If guide_year is specified, only include vehicles that have values for that year
            AND (
                p_guide_year IS NULL 
                OR EXISTS (
                    SELECT 1 
                    FROM public.guide_vehicle_values gvv 
                    WHERE gvv.vehicle_id = gv.vehicle_id 
                        AND gvv.guide_year = p_guide_year
                )
            )
        ORDER BY similarity_score DESC
        LIMIT LEAST(p_limit, 100)
    )
    SELECT 
        vm.vehicle_id,
        vm.type,
        vm.make,
        vm.model,
        vm.trim,
        vm.similarity_score,
        COALESCE(
            (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'guide_year', gvv.guide_year,
                        'year', gvv.year,
                        'value', gvv.value
                    )
                    ORDER BY gvv.guide_year DESC, gvv.year DESC
                )
                FROM public.guide_vehicle_values gvv
                WHERE gvv.vehicle_id = vm.vehicle_id
                    AND (p_guide_year IS NULL OR gvv.guide_year = p_guide_year)
            ),
            '[]'::jsonb
        ) as values
    FROM vehicle_matches vm
    ORDER BY vm.similarity_score DESC;
END;
$$;

-- Get best guide value match for account vehicles
DROP FUNCTION IF EXISTS get_best_guide_value_for_account_vehicle CASCADE;
CREATE OR REPLACE FUNCTION get_best_guide_value_for_account_vehicle(
    p_limit integer DEFAULT 10
)
RETURNS TABLE (
    account_vehicle_id bigint,
    account_number text,
    account_description text,
    account_model_year integer,
    account_year integer,
    account_current_value numeric,
    vehicle_id text,
    type text,
    make text,
    model text,
    "trim" text,
    guide_description text,
    similarity_score real,
    guide_year integer,
    year integer,
    guide_value numeric,
    is_default_value boolean
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH vehicles_without_exact_match AS (
        SELECT 
            av.id,
            av.account_number,
            av.description,
            av.model_year,
            av.account_year,
            av.current_value,
            av.vehicle_id as av_vehicle_id
        FROM public.account_vehicles av
        LEFT JOIN public.guide_vehicles gv ON gv.vehicle_id = av.vehicle_id
        WHERE gv.vehicle_id IS NULL
        LIMIT p_limit
    ),
    account_vehicle_matches AS (
        SELECT 
            vw.id as av_id,
            vw.account_number,
            vw.description as av_description,
            vw.model_year as av_model_year,
            vw.account_year as av_account_year,
            vw.current_value as av_current_value,
            gv.vehicle_id,
            gv.type,
            gv.make,
            gv.model,
            gv.trim,
            gv.description as gv_description,
            similarity(
                regexp_replace(vw.description, '[.-]', '', 'g'),
                regexp_replace(gv.description, '[.-]', '', 'g')
            ) as sim_score,
            ROW_NUMBER() OVER (PARTITION BY vw.id ORDER BY 
                similarity(
                    regexp_replace(vw.description, '[.-]', '', 'g'),
                    regexp_replace(gv.description, '[.-]', '', 'g')
                ) DESC
            ) as match_rank
        FROM vehicles_without_exact_match vw
        CROSS JOIN public.guide_vehicles gv
    ),
    best_matches AS (
        SELECT *
        FROM account_vehicle_matches
        WHERE match_rank = 1
    )
    SELECT 
        bm.av_id,
        bm.account_number,
        bm.av_description,
        bm.av_model_year,
        bm.av_account_year,
        bm.av_current_value,
        bm.vehicle_id,
        bm.type,
        bm.make,
        bm.model,
        bm.trim,
        bm.gv_description,
        bm.sim_score,
        gvv.guide_year,
        gvv.year,
        gvv.value,
        CASE WHEN gvv.year = 9999 THEN true ELSE false END as is_default_value
    FROM best_matches bm
    LEFT JOIN LATERAL (
        SELECT *
        FROM public.guide_vehicle_values gvv
        WHERE gvv.vehicle_id = bm.vehicle_id
            AND gvv.guide_year = bm.av_account_year
            AND (gvv.year = bm.av_model_year OR gvv.year = 9999)
        ORDER BY 
            CASE WHEN gvv.year = bm.av_model_year THEN 0 ELSE 1 END,
            gvv.year DESC
        LIMIT 1
    ) gvv ON true;
END;
$$;

-- ============================================================
-- DEVNET REVIEW STATUSES
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_statuses CASCADE;
CREATE TABLE public.devnet_review_statuses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_kind public.devnet_review_kind NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    description text NULL,
    is_terminal boolean NOT NULL DEFAULT false,
    needs_approval boolean NOT NULL DEFAULT false,
    
    -- Assignment configuration
    requires_assignment boolean NOT NULL DEFAULT false,
    preferred_role text NULL, -- 'appraiser', 'supervisor', etc.
    required_specialties text[] DEFAULT '{}', -- Required employee specialties
    
    sort_order integer NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (review_kind, slug)
);

-- Insert enhanced review statuses with assignment requirements
INSERT INTO public.devnet_review_statuses (review_kind, slug, name, is_terminal, needs_approval, requires_assignment, preferred_role, required_specialties, sort_order) VALUES
-- Sale review statuses with specific assignment requirements
('sale_review', 'pending', 'Pending Review', false, false, false, NULL, '{}', 1),
('sale_review', 'field-assigned', 'Field Work Assigned', false, false, true, 'appraiser', '{field_work}', 2),
('sale_review', 'in-field', 'Field Work In Progress', false, false, false, NULL, '{}', 3),
('sale_review', 'data-collected', 'Data Collected', false, false, false, NULL, '{}', 4),
('sale_review', 'entry-assigned', 'Data Entry Assigned', false, false, true, 'supervisor', '{data_entry}', 5),
('sale_review', 'data-entered', 'Data Entered', false, false, false, NULL, '{}', 6),
('sale_review', 'needs-approval', 'Needs Approval', false, true, true, 'supervisor', '{approval}', 7),
('sale_review', 'approved-for-copy', 'Approved for Devnet Copy', false, false, false, NULL, '{}', 8),
('sale_review', 'copied-to-devnet', 'Copied to Devnet', false, false, false, NULL, '{}', 9),
('sale_review', 'completed', 'Completed', true, false, false, NULL, '{}', 10),
('sale_review', 'rejected', 'Rejected', true, false, false, NULL, '{}', 11),

-- Permit review statuses
('permit_review', 'pending', 'Pending Review', false, false, false, NULL, '{}', 1),
('permit_review', 'investigating', 'Investigating', false, false, true, 'appraiser', '{field_work}', 2),
('permit_review', 'needs-approval', 'Needs Approval', false, true, true, 'supervisor', '{approval}', 3),
('permit_review', 'approved', 'Approved', true, false, false, NULL, '{}', 4),
('permit_review', 'denied', 'Denied', true, false, false, NULL, '{}', 5),

-- Appeal review statuses
('appeal_review', 'filed', 'Filed', false, false, false, NULL, '{}', 1),
('appeal_review', 'under-review', 'Under Review', false, false, true, 'appraiser', '{review}', 2),
('appeal_review', 'needs-decision', 'Needs Decision', false, true, true, 'supervisor', '{approval}', 3),
('appeal_review', 'upheld', 'Upheld', true, false, false, NULL, '{}', 4),
('appeal_review', 'overturned', 'Overturned', true, false, false, NULL, '{}', 5),
('appeal_review', 'withdrawn', 'Withdrawn', true, false, false, NULL, '{}', 6),

-- Custom review statuses
('custom_review', 'open', 'Open', false, false, false, NULL, '{}', 1),
('custom_review', 'assigned', 'Assigned', false, false, true, NULL, '{}', 2),
('custom_review', 'in-progress', 'In Progress', false, false, false, NULL, '{}', 3),
('custom_review', 'needs-review', 'Needs Review', false, true, true, 'supervisor', '{approval}', 4),
('custom_review', 'completed', 'Completed', true, false, false, NULL, '{}', 5),
('custom_review', 'cancelled', 'Cancelled', true, false, false, NULL, '{}', 6)
ON CONFLICT (review_kind, slug) DO NOTHING;

-- ============================================================
-- DEVNET REVIEWS (Central workflow)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_reviews CASCADE;
CREATE TABLE public.devnet_reviews (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kind public.devnet_review_kind NOT NULL,
    current_status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    
    -- Current assignment (for backward compatibility and quick access)
    assigned_to_id bigint NULL REFERENCES public.devnet_employees (id),
    due_date date NULL,
    
    -- Entity references (flexible - reference different devnet tables)
    entity_type text NULL, -- 'devnet_parcel', 'devnet_sale', etc.
    entity_id bigint NULL,
    
    -- Data collection and copy tracking
    data_status public.devnet_data_status DEFAULT 'not_collected',
    data_collected_at timestamptz NULL,
    data_collected_by_id bigint NULL REFERENCES public.devnet_employees (id),
    copied_to_devnet_at timestamptz NULL,
    copied_to_devnet_by_id bigint NULL REFERENCES public.devnet_employees (id),
    devnet_copy_confirmed boolean DEFAULT false,
    
    -- Data requirements and validation
    requires_field_review boolean DEFAULT false,
    required_data_fields jsonb DEFAULT '{}',
    data_validation_rules jsonb DEFAULT '{}',
    completion_criteria jsonb DEFAULT '{}',
    
    -- Additional context and data
    title text NULL,
    description text NULL,
    priority text DEFAULT 'medium', -- 'low', 'medium', 'high', 'urgent'
    data jsonb NOT NULL DEFAULT '{}', -- Flexible storage for review-specific data
    
    -- Field data collection
    field_data jsonb NULL, -- Data collected in the field
    field_notes text NULL,
    
    -- Workflow tracking
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    completed_at timestamptz NULL
);

CREATE INDEX devnet_reviews_kind_idx ON public.devnet_reviews (kind, created_at DESC);
CREATE INDEX devnet_reviews_status_idx ON public.devnet_reviews (current_status_id);
CREATE INDEX devnet_reviews_assigned_idx ON public.devnet_reviews (assigned_to_id);
CREATE INDEX devnet_reviews_entity_idx ON public.devnet_reviews (entity_type, entity_id);
CREATE INDEX devnet_reviews_priority_idx ON public.devnet_reviews (priority);
CREATE INDEX devnet_reviews_due_date_idx ON public.devnet_reviews (due_date);
CREATE INDEX devnet_reviews_data_status_idx ON public.devnet_reviews (data_status);
CREATE INDEX devnet_reviews_field_required_idx ON public.devnet_reviews (requires_field_review);
CREATE INDEX devnet_reviews_data_gin_idx ON public.devnet_reviews USING gin (data);
CREATE INDEX devnet_reviews_field_data_gin_idx ON public.devnet_reviews USING gin (field_data);
CREATE INDEX devnet_reviews_required_data_gin_idx ON public.devnet_reviews USING gin (required_data_fields);

-- ============================================================
-- STATUS-SPECIFIC ASSIGNMENTS
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_assignments CASCADE;
CREATE TABLE public.devnet_review_assignments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.devnet_reviews (id) ON DELETE CASCADE,
    status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    employee_id bigint NOT NULL REFERENCES public.devnet_employees (id),
    
    -- Assignment details
    assigned_by_id bigint NULL REFERENCES public.devnet_employees (id),
    assigned_at timestamptz NOT NULL DEFAULT now(),
    due_date date NULL,
    notes text NULL,
    
    -- Completion tracking
    completed_at timestamptz NULL,
    completed_by_id bigint NULL REFERENCES public.devnet_employees (id),
    completion_notes text NULL,
    
    -- Status
    is_active boolean DEFAULT true,
    
    UNIQUE (review_id, status_id, employee_id)
);

CREATE INDEX devnet_review_assignments_review_idx ON public.devnet_review_assignments (review_id);
CREATE INDEX devnet_review_assignments_status_idx ON public.devnet_review_assignments (status_id);
CREATE INDEX devnet_review_assignments_employee_idx ON public.devnet_review_assignments (employee_id);
CREATE INDEX devnet_review_assignments_active_idx ON public.devnet_review_assignments (is_active) WHERE is_active = true;
CREATE INDEX devnet_review_assignments_due_date_idx ON public.devnet_review_assignments (due_date);

-- ============================================================
-- DEVNET REVIEW HISTORY (Status and Assignment Changes)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_history CASCADE;
CREATE TABLE public.devnet_review_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.devnet_reviews (id) ON DELETE CASCADE,
    
    -- Status change tracking
    from_status_id bigint NULL REFERENCES public.devnet_review_statuses (id),
    to_status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    
    -- Assignment change tracking
    from_employee_id bigint NULL REFERENCES public.devnet_employees (id),
    to_employee_id bigint NULL REFERENCES public.devnet_employees (id),
    
    -- Data status changes
    from_data_status public.devnet_data_status NULL,
    to_data_status public.devnet_data_status NULL,
    
    -- Change details
    changed_by_id bigint NULL REFERENCES public.devnet_employees (id),
    notes text NULL,
    change_reason text NULL,
    
    changed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_review_history_review_idx ON public.devnet_review_history (review_id, changed_at DESC);
CREATE INDEX devnet_review_history_changed_by_idx ON public.devnet_review_history (changed_by_id);

-- ============================================================
-- DEVNET AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-log review changes
DROP FUNCTION IF EXISTS log_devnet_review_changes();
CREATE OR REPLACE FUNCTION log_devnet_review_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Log status changes
    IF OLD.current_status_id IS DISTINCT FROM NEW.current_status_id THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_status_id,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.current_status_id,
            NEW.current_status_id,
            'Status changed via trigger'
        );
    END IF;
    
    -- Log assignment changes
    IF OLD.assigned_to_id IS DISTINCT FROM NEW.assigned_to_id THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_employee_id,
            to_employee_id,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.assigned_to_id,
            NEW.assigned_to_id,
            NEW.current_status_id,
            'Assignment changed via trigger'
        );
    END IF;
    
    -- Log data status changes
    IF OLD.data_status IS DISTINCT FROM NEW.data_status THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_data_status,
            to_data_status,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.data_status,
            NEW.data_status,
            NEW.current_status_id,
            'Data status changed via trigger'
        );
    END IF;
    
    -- Update timestamp
    NEW.updated_at = now();
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS devnet_review_changes_trigger ON public.devnet_reviews;
CREATE TRIGGER devnet_review_changes_trigger
    BEFORE UPDATE ON public.devnet_reviews
    FOR EACH ROW 
    EXECUTE FUNCTION log_devnet_review_changes();

-- ============================================================
-- DEVNET WORKFLOW FUNCTIONS
-- ============================================================

-- Create a review for a devnet entity
DROP FUNCTION IF EXISTS create_devnet_review(public.devnet_review_kind, text, bigint, text, text, bigint, jsonb);
CREATE OR REPLACE FUNCTION create_devnet_review(
    p_kind public.devnet_review_kind,
    p_entity_type text,
    p_entity_id bigint,
    p_title text DEFAULT NULL,
    p_description text DEFAULT NULL,
    p_assigned_to_employee_id bigint DEFAULT NULL,
    p_data jsonb DEFAULT '{}'::jsonb
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_default_status_id bigint;
BEGIN
    -- Get default status for this review kind (lowest sort_order)
    SELECT id INTO v_default_status_id
    FROM public.devnet_review_statuses 
    WHERE review_kind = p_kind 
    ORDER BY sort_order ASC 
    LIMIT 1;
    
    IF v_default_status_id IS NULL THEN
        RAISE EXCEPTION 'No default status found for review kind: %', p_kind;
    END IF;
    
    -- Create the review
    INSERT INTO public.devnet_reviews (
        kind,
        current_status_id,
        entity_type,
        entity_id,
        title,
        description,
        assigned_to_id,
        data
    ) VALUES (
        p_kind,
        v_default_status_id,
        p_entity_type,
        p_entity_id,
        p_title,
        p_description,
        p_assigned_to_employee_id,
        p_data
    ) RETURNING id INTO v_review_id;
    
    -- Log initial creation
    INSERT INTO public.devnet_review_history (
        review_id,
        to_status_id,
        to_employee_id,
        notes
    ) VALUES (
        v_review_id,
        v_default_status_id,
        p_assigned_to_employee_id,
        'Review created'
    );
    
    RETURN v_review_id;
END;
$$;

-- Transition review status
DROP FUNCTION IF EXISTS transition_devnet_review_status(bigint, text, bigint, text);
CREATE OR REPLACE FUNCTION transition_devnet_review_status(
    p_review_id bigint,
    p_new_status_slug text,
    p_changed_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_kind public.devnet_review_kind;
    v_old_status_id bigint;
    v_new_status_id bigint;
    v_is_terminal boolean;
BEGIN
    -- Get current review details
    SELECT kind, current_status_id INTO v_review_kind, v_old_status_id
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review not found: %', p_review_id;
    END IF;
    
    -- Get new status
    SELECT id, is_terminal INTO v_new_status_id, v_is_terminal
    FROM public.devnet_review_statuses 
    WHERE review_kind = v_review_kind AND slug = p_new_status_slug;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid status % for review kind %', p_new_status_slug, v_review_kind;
    END IF;
    
    -- Update review
    UPDATE public.devnet_reviews 
    SET 
        current_status_id = v_new_status_id,
        completed_at = CASE WHEN v_is_terminal THEN now() ELSE completed_at END
    WHERE id = p_review_id;
    
    -- Log the change
    INSERT INTO public.devnet_review_history (
        review_id,
        from_status_id,
        to_status_id,
        changed_by_id,
        notes,
        change_reason
    ) VALUES (
        p_review_id,
        v_old_status_id,
        v_new_status_id,
        p_changed_by_employee_id,
        p_notes,
        'Manual status transition'
    );
    
    RETURN true;
END;
$$;

-- Assign review to employee
DROP FUNCTION IF EXISTS assign_devnet_review(bigint, bigint, bigint, text);
CREATE OR REPLACE FUNCTION assign_devnet_review(
    p_review_id bigint,
    p_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_old_employee_id bigint;
    v_current_status_id bigint;
BEGIN
    -- Get current assignment
    SELECT assigned_to_id, current_status_id INTO v_old_employee_id, v_current_status_id
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review not found: %', p_review_id;
    END IF;
    
    -- Update assignment
    UPDATE public.devnet_reviews 
    SET assigned_to_id = p_employee_id
    WHERE id = p_review_id;
    
    -- Log the assignment change
    INSERT INTO public.devnet_review_history (
        review_id,
        from_employee_id,
        to_employee_id,
        to_status_id,
        changed_by_id,
        notes,
        change_reason
    ) VALUES (
        p_review_id,
        v_old_employee_id,
        p_employee_id,
        v_current_status_id,
        p_assigned_by_employee_id,
        p_notes,
        'Manual assignment'
    );
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET MASS OPERATIONS FUNCTIONS
-- ============================================================

-- Mass create reviews with data requirements
DROP FUNCTION IF EXISTS mass_create_devnet_reviews(jsonb);
CREATE OR REPLACE FUNCTION mass_create_devnet_reviews(
    p_review_configs jsonb -- Array of review configurations
)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    review_config jsonb;
    review_id bigint;
    review_ids bigint[] := '{}';
    default_status_id bigint;
BEGIN
    FOR review_config IN SELECT jsonb_array_elements(p_review_configs)
    LOOP
        -- Get default status for review kind
        SELECT id INTO default_status_id
        FROM public.devnet_review_statuses 
        WHERE review_kind = (review_config->>'kind')::devnet_review_kind
        ORDER BY sort_order ASC 
        LIMIT 1;
        
        -- Create review
        INSERT INTO public.devnet_reviews (
            kind,
            current_status_id,
            entity_type,
            entity_id,
            title,
            description,
            priority,
            requires_field_review,
            required_data_fields,
            data_validation_rules,
            completion_criteria,
            data,
            due_date
        ) VALUES (
            (review_config->>'kind')::devnet_review_kind,
            default_status_id,
            review_config->>'entity_type',
            (review_config->>'entity_id')::bigint,
            review_config->>'title',
            review_config->>'description',
            COALESCE(review_config->>'priority', 'medium'),
            COALESCE((review_config->>'requires_field_review')::boolean, false),
            COALESCE(review_config->'required_data_fields', '{}'::jsonb),
            COALESCE(review_config->'data_validation_rules', '{}'::jsonb),
            COALESCE(review_config->'completion_criteria', '{}'::jsonb),
            COALESCE(review_config->'data', '{}'::jsonb),
            COALESCE((review_config->>'due_date')::date, NULL)
        ) RETURNING id INTO review_id;
        
        review_ids := review_ids || review_id;
        
        -- Auto-assign if specified
        IF review_config ? 'assigned_to_id' THEN
            PERFORM assign_devnet_review(
                review_id,
                (review_config->>'assigned_to_id')::bigint,
                NULL,
                'Auto-assigned during mass creation'
            );
        END IF;
    END LOOP;
    
    RETURN review_ids;
END;
$$;

-- Mass update review status
DROP FUNCTION IF EXISTS mass_update_devnet_review_status(bigint[], text, bigint, text);
CREATE OR REPLACE FUNCTION mass_update_devnet_review_status(
    p_review_ids bigint[],
    p_new_status_slug text,
    p_changed_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    success_count integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        BEGIN
            PERFORM transition_devnet_review_status(
                review_id,
                p_new_status_slug,
                p_changed_by_employee_id,
                p_notes
            );
            success_count := success_count + 1;
        EXCEPTION WHEN OTHERS THEN
            -- Log error but continue with other reviews
            INSERT INTO public.devnet_review_history (
                review_id,
                to_status_id,
                changed_by_id,
                notes,
                change_reason
            ) VALUES (
                review_id,
                (SELECT current_status_id FROM public.devnet_reviews WHERE id = review_id),
                p_changed_by_employee_id,
                'Failed to update: ' || SQLERRM,
                'Mass update error'
            );
        END;
    END LOOP;
    
    RETURN success_count = array_length(p_review_ids, 1);
END;
$$;

-- Mass assign reviews
DROP FUNCTION IF EXISTS mass_assign_devnet_reviews(bigint[], bigint, bigint, date);
CREATE OR REPLACE FUNCTION mass_assign_devnet_reviews(
    p_review_ids bigint[],
    p_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_current_status_id bigint;
BEGIN
    FOREACH v_review_id IN ARRAY p_review_ids
    LOOP
        -- Get current status
        SELECT devnet_reviews.current_status_id INTO v_current_status_id
        FROM public.devnet_reviews 
        WHERE id = v_review_id;
        
        -- Update assignment
        UPDATE public.devnet_reviews 
        SET 
            assigned_to_id = p_employee_id,
            due_date = COALESCE(p_due_date, due_date)
        WHERE id = v_review_id;
        
        -- Create status-specific assignment if status requires it
        INSERT INTO public.devnet_review_assignments (
            review_id,
            status_id,
            employee_id,
            assigned_by_id,
            due_date,
            notes
        ) VALUES (
            v_review_id,
            v_current_status_id,
            p_employee_id,
            p_assigned_by_employee_id,
            p_due_date,
            'Mass assignment'
        ) ON CONFLICT (review_id, status_id, employee_id) 
        DO UPDATE SET
            assigned_by_id = EXCLUDED.assigned_by_id,
            due_date = COALESCE(EXCLUDED.due_date, p_due_date),
            assigned_at = now(),
            is_active = true;
    END LOOP;
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET DATA REQUIREMENTS AND VALIDATION FUNCTIONS
-- ============================================================

-- Set data requirements for reviews
DROP FUNCTION IF EXISTS set_review_data_requirements(bigint, jsonb, jsonb, jsonb);
CREATE OR REPLACE FUNCTION set_review_data_requirements(
    p_review_id bigint,
    p_required_fields jsonb,
    p_validation_rules jsonb DEFAULT '{}',
    p_completion_criteria jsonb DEFAULT '{}'
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews 
    SET 
        required_data_fields = p_required_fields,
        data_validation_rules = p_validation_rules,
        completion_criteria = p_completion_criteria,
        updated_at = now()
    WHERE id = p_review_id;
    
    RETURN FOUND;
END;
$$;

-- Check if review has required data
DROP FUNCTION IF EXISTS check_review_data_completeness(bigint);
CREATE OR REPLACE FUNCTION check_review_data_completeness(
    p_review_id bigint
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    review_record record;
    required_field text;
    missing_fields text[] := '{}';
    validation_errors text[] := '{}';
    result jsonb;
BEGIN
    -- Get review data
    SELECT 
        required_data_fields,
        field_data,
        data,
        data_validation_rules
    INTO review_record
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    -- Check required fields
    FOR required_field IN 
        SELECT jsonb_array_elements_text(review_record.required_data_fields->'fields')
    LOOP
        IF NOT (
            (review_record.field_data ? required_field AND review_record.field_data->>required_field IS NOT NULL) OR
            (review_record.data ? required_field AND review_record.data->>required_field IS NOT NULL)
        ) THEN
            missing_fields := missing_fields || required_field;
        END IF;
    END LOOP;
    
    -- Build result
    result := jsonb_build_object(
        'is_complete', array_length(missing_fields, 1) IS NULL,
        'missing_fields', to_jsonb(missing_fields),
        'validation_errors', to_jsonb(validation_errors),
        'checked_at', now()
    );
    
    RETURN result;
END;
$$;

-- Auto-assign based on field requirements
DROP FUNCTION IF EXISTS auto_assign_field_reviews();
CREATE OR REPLACE FUNCTION auto_assign_field_reviews()
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_record record;
    eligible_employee_id bigint;
    assignments_made integer := 0;
BEGIN
    -- Find reviews that need field assignment
    FOR review_record IN 
        SELECT 
            r.id,
            r.entity_type,
            r.entity_id,
            rs.preferred_role,
            rs.required_specialties
        FROM public.devnet_reviews r
        JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
        WHERE r.requires_field_review = true
        AND r.assigned_to_id IS NULL
        AND rs.requires_assignment = true
        AND rs.preferred_role = 'appraiser'
    LOOP
        -- Find eligible employee
        SELECT e.id INTO eligible_employee_id
        FROM public.devnet_employees e
        WHERE e.status = 'active'
        AND e.role = review_record.preferred_role
        AND (
            review_record.required_specialties = '{}' OR
            review_record.required_specialties <@ e.specialties
        )
        ORDER BY 
            -- Prefer employees with fewer active assignments
            (SELECT COUNT(*) FROM public.devnet_reviews WHERE assigned_to_id = e.id AND completed_at IS NULL)
        LIMIT 1;
        
        IF eligible_employee_id IS NOT NULL THEN
            PERFORM assign_devnet_review(
                review_record.id,
                eligible_employee_id,
                NULL,
                'Auto-assigned for field review'
            );
            assignments_made := assignments_made + 1;
        END IF;
    END LOOP;
    
    RETURN assignments_made;
END;
$$;

-- Mark data collection complete
DROP FUNCTION IF EXISTS mark_data_collected(bigint, jsonb, bigint, text);
CREATE OR REPLACE FUNCTION mark_data_collected(
    p_review_id bigint,
    p_field_data jsonb,
    p_collected_by_employee_id bigint,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews
    SET 
        data_status = 'collected',
        field_data = p_field_data,
        field_notes = p_notes,
        data_collected_at = now(),
        data_collected_by_id = p_collected_by_employee_id,
        updated_at = now()
    WHERE id = p_review_id;
    
    -- Auto-transition to data-collected status if available
    IF EXISTS (
        SELECT 1 FROM public.devnet_review_statuses rs
        JOIN public.devnet_reviews r ON r.kind = rs.review_kind
        WHERE r.id = p_review_id AND rs.slug = 'data-collected'
    ) THEN
        PERFORM transition_devnet_review_status(
            p_review_id,
            'data-collected',
            p_collected_by_employee_id,
            'Data collection completed: ' || COALESCE(p_notes, '')
        );
    END IF;
    
    RETURN true;
END;
$$;

-- Mark copied to devnet
DROP FUNCTION IF EXISTS mark_copied_to_devnet(bigint, bigint, text);
CREATE OR REPLACE FUNCTION mark_copied_to_devnet(
    p_review_id bigint,
    p_copied_by_employee_id bigint,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews
    SET 
        copied_to_devnet_at = now(),
        copied_to_devnet_by_id = p_copied_by_employee_id,
        devnet_copy_confirmed = true,
        updated_at = now()
    WHERE id = p_review_id;
    
    -- Auto-transition to copied-to-devnet status if available
    IF EXISTS (
        SELECT 1 FROM public.devnet_review_statuses rs
        JOIN public.devnet_reviews r ON r.kind = rs.review_kind
        WHERE r.id = p_review_id AND rs.slug = 'copied-to-devnet'
    ) THEN
        PERFORM transition_devnet_review_status(
            p_review_id,
            'copied-to-devnet',
            p_copied_by_employee_id,
            'Copied to Devnet: ' || COALESCE(p_notes, '')
        );
    END IF;
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET SEARCH AND FILTER FUNCTIONS
-- ============================================================

-- Comprehensive search function for devnet reviews
DROP FUNCTION IF EXISTS search_devnet_reviews(text, text, bigint, text, text, text, boolean, text, boolean, date, date, date, date, boolean, boolean);
CREATE OR REPLACE FUNCTION search_devnet_reviews(
    p_kind text DEFAULT NULL,
    p_devnet_review_statuses_ids text DEFAULT NULL,
    p_assigned_to_devnet_employees_id bigint DEFAULT NULL,
    p_data_status text DEFAULT NULL,
    p_priority text DEFAULT NULL,
    p_entity_type text DEFAULT NULL,
    p_requires_field_review boolean DEFAULT NULL,
    p_search_text text DEFAULT NULL,
    p_overdue_only boolean DEFAULT false,
    p_created_after date DEFAULT NULL,
    p_created_before date DEFAULT NULL,
    p_due_after date DEFAULT NULL,
    p_due_before date DEFAULT NULL,
    p_completed_only boolean DEFAULT false,
    p_active_only boolean DEFAULT false
)
RETURNS TABLE (
    id bigint,
    kind text,
    title text,
    description text,
    priority text,
    status_name text,
    status_slug text,
    assigned_to_name text,
    assigned_to_email text,
    assigned_to_role text,
    entity_type text,
    entity_id bigint,
    parcel_number text,
    parcel_address text,
    neighborhood_name text,
    sale_price numeric,
    sale_date date,
    requires_field_review boolean,
    data_status text,
    due_date date,
    days_until_due integer,
    created_at timestamptz,
    updated_at timestamptz,
    completed_at timestamptz,
    -- Associated parcel data
    parcel_data jsonb,
    -- Associated sales data  
    sales_data jsonb,
    -- Associated sale-parcel relationships
    sale_parcels_data jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
    status_ids_array bigint[];
BEGIN
    -- Convert comma-separated status IDs to array
    IF p_devnet_review_statuses_ids IS NOT NULL AND p_devnet_review_statuses_ids != '' THEN
        SELECT ARRAY(
            SELECT trim(unnest(string_to_array(p_devnet_review_statuses_ids, ',')))::bigint
        ) INTO status_ids_array;
    END IF;

    RETURN QUERY
    SELECT 
        r.id,
        r.kind::text,
        r.title,
        r.description,
        r.priority,
        rs.name as status_name,
        rs.slug as status_slug,
        COALESCE(e.first_name || ' ' || e.last_name, '') as assigned_to_name,
        e.email as assigned_to_email,
        e.role as assigned_to_role,
        r.entity_type,
        r.entity_id,
        COALESCE(dp.parcel_number, '') as parcel_number,
        COALESCE(dp.data->>'address', '') as parcel_address,
        COALESCE(dnr.neighborhood_name, '') as neighborhood_name,
        ds.sale_price,
        ds.sale_date,
        r.requires_field_review,
        r.data_status::text,
        r.due_date,
        CASE WHEN r.due_date IS NOT NULL 
             THEN r.due_date - CURRENT_DATE 
             ELSE NULL END as days_until_due,
        r.created_at,
        r.updated_at,
        r.completed_at,
        -- Get all parcels related to this review
        CASE 
            WHEN r.entity_type = 'devnet_parcels' THEN 
                jsonb_build_object(
                    'id', dp.id,
                    'parcel_number', dp.parcel_number,
                    'start_year', dp.start_year,
                    'end_year', dp.end_year,
                    'data', dp.data,
                    'devnet_id', dp.devnet_id,
                    'sync_date', dp.sync_date
                )
            WHEN r.entity_type = 'devnet_sales' THEN (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', related_parcels.id,
                        'parcel_number', related_parcels.parcel_number,
                        'start_year', related_parcels.start_year,
                        'end_year', related_parcels.end_year,
                        'data', related_parcels.data,
                        'devnet_id', related_parcels.devnet_id,
                        'sync_date', related_parcels.sync_date
                    )
                )
                FROM public.devnet_parcels related_parcels
                INNER JOIN public.devnet_sale_parcels dsp ON related_parcels.id = dsp.parcel_id
                WHERE dsp.sale_id = r.entity_id
            )
            ELSE NULL
        END as parcel_data,
        -- Get all sales related to this review
        CASE 
            WHEN r.entity_type = 'devnet_sales' THEN 
                jsonb_build_object(
                    'id', ds.id,
                    'sale_price', ds.sale_price,
                    'sale_date', ds.sale_date,
                    'sale_type', ds.sale_type,
                    'sale_status', ds.sale_status,
                    'data', ds.data,
                    'devnet_id', ds.devnet_id,
                    'sync_date', ds.sync_date
                )
            WHEN r.entity_type = 'devnet_parcels' THEN (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', related_sales.id,
                        'sale_price', related_sales.sale_price,
                        'sale_date', related_sales.sale_date,
                        'sale_type', related_sales.sale_type,
                        'sale_status', related_sales.sale_status,
                        'data', related_sales.data,
                        'devnet_id', related_sales.devnet_id,
                        'sync_date', related_sales.sync_date
                    )
                )
                FROM public.devnet_sales related_sales
                INNER JOIN public.devnet_sale_parcels dsp ON related_sales.id = dsp.sale_id
                WHERE dsp.parcel_id = r.entity_id
            )
            ELSE NULL
        END as sales_data,
        -- Get sale-parcel relationships
        CASE 
            WHEN r.entity_type IN ('devnet_sales', 'devnet_parcels') THEN (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', dsp.id,
                        'sale_id', dsp.sale_id,
                        'parcel_id', dsp.parcel_id,
                        'data', dsp.data,
                        'created_at', dsp.created_at
                    )
                )
                FROM public.devnet_sale_parcels dsp
                WHERE (r.entity_type = 'devnet_sales' AND dsp.sale_id = r.entity_id)
                   OR (r.entity_type = 'devnet_parcels' AND dsp.parcel_id = r.entity_id)
            )
            ELSE NULL
        END as sale_parcels_data
    FROM public.devnet_reviews r
    LEFT JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
    LEFT JOIN public.devnet_employees e ON r.assigned_to_id = e.id
    LEFT JOIN public.devnet_parcels dp ON r.entity_type = 'devnet_parcels' AND r.entity_id = dp.id
    LEFT JOIN public.devnet_sales ds ON r.entity_type = 'devnet_sales' AND r.entity_id = ds.id
    LEFT JOIN public.devnet_neighborhood_report dnr ON r.entity_type = 'neighborhood' AND r.entity_id = dnr.id
    WHERE 1=1
        -- Filter by kind
        AND (p_kind IS NULL OR r.kind::text = p_kind)
        -- Filter by status IDs
        AND (status_ids_array IS NULL OR r.current_status_id = ANY(status_ids_array))
        -- Filter by assigned employee
        AND (p_assigned_to_devnet_employees_id IS NULL OR r.assigned_to_id = p_assigned_to_devnet_employees_id)
        -- Filter by data status
        AND (p_data_status IS NULL OR r.data_status::text = p_data_status)
        -- Filter by priority
        AND (p_priority IS NULL OR r.priority = p_priority)
        -- Filter by entity type
        AND (p_entity_type IS NULL OR r.entity_type = p_entity_type)
        -- Filter by field review requirement
        AND (p_requires_field_review IS NULL OR r.requires_field_review = p_requires_field_review)
        -- Text search in title and description
        AND (p_search_text IS NULL OR 
             (r.title ILIKE '%' || p_search_text || '%' OR 
              r.description ILIKE '%' || p_search_text || '%' OR
              dp.parcel_number ILIKE '%' || p_search_text || '%' OR
              (dp.data->>'address') ILIKE '%' || p_search_text || '%'))
        -- Overdue filter
        AND (NOT p_overdue_only OR (r.due_date IS NOT NULL AND r.due_date < CURRENT_DATE))
        -- Date range filters
        AND (p_created_after IS NULL OR r.created_at::date >= p_created_after)
        AND (p_created_before IS NULL OR r.created_at::date <= p_created_before)
        AND (p_due_after IS NULL OR r.due_date >= p_due_after)
        AND (p_due_before IS NULL OR r.due_date <= p_due_before)
        -- Completion filters
        AND (NOT p_completed_only OR r.completed_at IS NOT NULL)
        AND (NOT p_active_only OR r.completed_at IS NULL)
    ORDER BY 
        CASE WHEN p_overdue_only THEN r.due_date END ASC,
        r.created_at DESC
    LIMIT 1000;
END;
$$;

-- Get review counts by status and kind
DROP FUNCTION IF EXISTS get_devnet_review_counts(jsonb);
CREATE OR REPLACE FUNCTION get_devnet_review_counts(
    p_filters jsonb DEFAULT '{}'::jsonb
)
RETURNS TABLE (
    kind text,
    status_name text,
    status_slug text,
    review_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.kind::text,
        rs.name as status_name,
        rs.slug as status_slug,
        COUNT(r.id) as review_count
    FROM public.devnet_reviews r
    LEFT JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
    LEFT JOIN public.devnet_employees e ON r.assigned_to_id = e.id
    LEFT JOIN public.devnet_parcels p ON (r.entity_type = 'devnet_parcel' AND r.entity_id = p.id)
    LEFT JOIN public.devnet_sales s ON (r.entity_type = 'devnet_sale' AND r.entity_id = s.id)
    LEFT JOIN public.devnet_sale_parcels salep ON (r.entity_type = 'devnet_sale' AND s.id = salep.sale_id)
    LEFT JOIN public.devnet_parcels sp ON salep.parcel_id = sp.id
    WHERE 1=1
    -- Apply same filters as search function
    AND (NOT p_filters ? 'kind' OR r.kind::text = p_filters->>'kind')
    AND (NOT p_filters ? 'assigned_to_id' OR r.assigned_to_id = (p_filters->>'assigned_to_id')::bigint)
    AND (NOT p_filters ? 'priority' OR r.priority = p_filters->>'priority')
    AND (NOT p_filters ? 'neighborhood' OR 
         (COALESCE(p.data->>'neighborhood', p.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%' OR
          COALESCE(sp.data->>'neighborhood', sp.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%'))
    GROUP BY r.kind::text, rs.name, rs.slug, rs.sort_order
    ORDER BY r.kind::text, rs.sort_order;
END;
$$;

-- Get available filter options
DROP FUNCTION IF EXISTS get_devnet_filter_options();
CREATE OR REPLACE FUNCTION get_devnet_filter_options()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'kinds', (SELECT jsonb_agg(DISTINCT kind::text) FROM public.devnet_reviews),
        'statuses', (
            SELECT jsonb_agg(jsonb_build_object('slug', slug, 'name', name, 'kind', review_kind::text)) 
            FROM public.devnet_review_statuses ORDER BY review_kind, sort_order
        ),
        'priorities', jsonb_build_array('low', 'medium', 'high', 'urgent'),
        'data_statuses', jsonb_build_array('not_collected', 'in_field', 'collected', 'entered', 'copied_to_devnet', 'verified'),
        'employees', (
            SELECT jsonb_agg(jsonb_build_object(
                'id', id, 
                'name', first_name || ' ' || last_name, 
                'email', email, 
                'role', role
            ))
            FROM public.devnet_employees 
            WHERE status = 'active'
            ORDER BY first_name, last_name
        ),
        'neighborhoods', (
            SELECT jsonb_agg(DISTINCT neighborhood) 
            FROM (
                SELECT COALESCE(data->>'neighborhood', data->>'neighborhood_name', '') as neighborhood
                FROM public.devnet_parcels
                WHERE COALESCE(data->>'neighborhood', data->>'neighborhood_name', '') != ''
                UNION
                SELECT DISTINCT neighborhood_name as neighborhood
                FROM public.devnet_neighborhood_report
                WHERE neighborhood_name IS NOT NULL AND neighborhood_name != ''
            ) neighborhoods
            WHERE neighborhood != ''
        )
    ) INTO result;
    
    RETURN result;
END;
$$;

-- ============================================================
-- ENHANCED MASS ASSIGNMENT FUNCTIONS
-- ============================================================

-- Mass create assignments for specific statuses
DROP FUNCTION IF EXISTS mass_create_devnet_assignments(bigint[], bigint[], bigint, bigint, date, text);
CREATE OR REPLACE FUNCTION mass_create_devnet_assignments(
    p_review_ids bigint[],
    p_status_ids bigint[],
    p_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_status_id bigint;
    assignments_created integer := 0;
BEGIN
    FOREACH v_review_id IN ARRAY p_review_ids
    LOOP
        FOREACH v_status_id IN ARRAY p_status_ids
        LOOP
            INSERT INTO public.devnet_review_assignments (
                review_id,
                status_id,
                employee_id,
                assigned_by_id,
                due_date,
                notes
            ) VALUES (
                v_review_id,
                v_status_id,
                p_employee_id,
                p_assigned_by_employee_id,
                p_due_date,
                p_notes
            ) ON CONFLICT (review_id, status_id, employee_id) 
            DO UPDATE SET
                assigned_by_id = EXCLUDED.assigned_by_id,
                due_date = COALESCE(EXCLUDED.due_date, p_due_date),
                assigned_at = now(),
                is_active = true;
            
            assignments_created := assignments_created + 1;
        END LOOP;
    END LOOP;
    
    RETURN assignments_created;
END;
$$;

-- Mass reassign reviews (update current assignment and create new status-specific assignments)
DROP FUNCTION IF EXISTS mass_reassign_devnet_reviews(bigint[], bigint, bigint, bigint, date, text);
CREATE OR REPLACE FUNCTION mass_reassign_devnet_reviews(
    p_review_ids bigint[],
    p_from_employee_id bigint,
    p_to_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_notes text DEFAULT 'Mass reassignment'
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    current_status_id bigint;
    reassignments_made integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        -- Only reassign if currently assigned to the from_employee
        SELECT devnet_reviews.current_status_id INTO current_status_id
        FROM public.devnet_reviews 
        WHERE id = review_id 
        AND assigned_to_id = p_from_employee_id;
        
        IF FOUND THEN
            -- Update main assignment
            UPDATE public.devnet_reviews 
            SET 
                assigned_to_id = p_to_employee_id,
                due_date = COALESCE(p_due_date, due_date),
                updated_at = now()
            WHERE id = review_id;
            
            -- Deactivate old status-specific assignments for the from_employee
            UPDATE public.devnet_review_assignments
            SET is_active = false
            WHERE review_id = review_id 
            AND employee_id = p_from_employee_id
            AND is_active = true;
            
            -- Create new status-specific assignment
            INSERT INTO public.devnet_review_assignments (
                review_id,
                status_id,
                employee_id,
                assigned_by_id,
                due_date,
                notes
            ) VALUES (
                review_id,
                current_status_id,
                p_to_employee_id,
                p_assigned_by_employee_id,
                p_due_date,
                p_notes
            ) ON CONFLICT (review_id, status_id, employee_id) 
            DO UPDATE SET
                assigned_by_id = EXCLUDED.assigned_by_id,
                due_date = COALESCE(EXCLUDED.due_date, devnet_review_assignments.due_date),
                assigned_at = now(),
                is_active = true;
            
            reassignments_made := reassignments_made + 1;
        END IF;
    END LOOP;
    
    RETURN reassignments_made;
END;
$$;

-- Mass update assignment completion
DROP FUNCTION IF EXISTS mass_complete_devnet_assignments(bigint[], bigint, text);
CREATE OR REPLACE FUNCTION mass_complete_devnet_assignments(
    p_assignment_ids bigint[],
    p_completed_by_employee_id bigint,
    p_completion_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    assignment_id bigint;
    completions_made integer := 0;
BEGIN
    FOREACH assignment_id IN ARRAY p_assignment_ids
    LOOP
        UPDATE public.devnet_review_assignments
        SET 
            completed_at = now(),
            completed_by_id = p_completed_by_employee_id,
            completion_notes = p_completion_notes,
            is_active = false
        WHERE id = assignment_id
        AND completed_at IS NULL;
        
        IF FOUND THEN
            completions_made := completions_made + 1;
        END IF;
    END LOOP;
    
    RETURN completions_made;
END;
$$;

-- Mass update assignment due dates
DROP FUNCTION IF EXISTS mass_update_assignment_due_dates(bigint[], date, bigint, text);
CREATE OR REPLACE FUNCTION mass_update_assignment_due_dates(
    p_assignment_ids bigint[],
    p_new_due_date date,
    p_updated_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    assignment_id bigint;
    updates_made integer := 0;
BEGIN
    FOREACH assignment_id IN ARRAY p_assignment_ids
    LOOP
        UPDATE public.devnet_review_assignments
        SET 
            due_date = p_new_due_date,
            notes = COALESCE(p_notes, notes)
        WHERE id = assignment_id;
        
        IF FOUND THEN
            updates_made := updates_made + 1;
        END IF;
    END LOOP;
    
    RETURN updates_made;
END;
$$;

-- ============================================================
-- COMPREHENSIVE SEED DATA FOR TESTING
-- ============================================================

-- Generate comprehensive employee data (120 employees)
INSERT INTO public.devnet_employees (first_name, last_name, email, role, specialties, can_approve) 
SELECT 
    CASE (i % 20)
        WHEN 0 THEN 'John'
        WHEN 1 THEN 'Sarah' 
        WHEN 2 THEN 'Mike'
        WHEN 3 THEN 'Lisa'
        WHEN 4 THEN 'Tom'
        WHEN 5 THEN 'Amy'
        WHEN 6 THEN 'David'
        WHEN 7 THEN 'Emily'
        WHEN 8 THEN 'James'
        WHEN 9 THEN 'Jessica'
        WHEN 10 THEN 'Robert'
        WHEN 11 THEN 'Ashley'
        WHEN 12 THEN 'Michael'
        WHEN 13 THEN 'Amanda'
        WHEN 14 THEN 'William'
        WHEN 15 THEN 'Jennifer'
        WHEN 16 THEN 'Kevin'
        WHEN 17 THEN 'Stephanie'
        WHEN 18 THEN 'Brian'
        ELSE 'Michelle'
    END as first_name,
    CASE (i % 25)
        WHEN 0 THEN 'Smith'
        WHEN 1 THEN 'Johnson'
        WHEN 2 THEN 'Davis'
        WHEN 3 THEN 'Wilson'
        WHEN 4 THEN 'Brown'
        WHEN 5 THEN 'Miller'
        WHEN 6 THEN 'Moore'
        WHEN 7 THEN 'Taylor'
        WHEN 8 THEN 'Anderson'
        WHEN 9 THEN 'Thomas'
        WHEN 10 THEN 'Jackson'
        WHEN 11 THEN 'White'
        WHEN 12 THEN 'Harris'
        WHEN 13 THEN 'Martin'
        WHEN 14 THEN 'Thompson'
        WHEN 15 THEN 'Garcia'
        WHEN 16 THEN 'Martinez'
        WHEN 17 THEN 'Robinson'
        WHEN 18 THEN 'Clark'
        WHEN 19 THEN 'Rodriguez'
        WHEN 20 THEN 'Lewis'
        WHEN 21 THEN 'Lee'
        WHEN 22 THEN 'Walker'
        WHEN 23 THEN 'Hall'
        ELSE 'Allen'
    END as last_name,
    'employee' || i || '@example.com' as email,
    CASE (i % 4)
        WHEN 0 THEN 'appraiser'
        WHEN 1 THEN 'supervisor'
        WHEN 2 THEN 'data_entry'
        ELSE 'reviewer'
    END as role,
    CASE (i % 6)
        WHEN 0 THEN '{field_work, residential}'
        WHEN 1 THEN '{approval, data_entry}'
        WHEN 2 THEN '{field_work, commercial}'
        WHEN 3 THEN '{data_entry, residential}'
        WHEN 4 THEN '{approval, review}'
        ELSE '{field_work, commercial, residential}'
    END::text[] as specialties,
    CASE WHEN (i % 4) = 1 THEN true ELSE false END as can_approve
FROM generate_series(1, 120) as i
ON CONFLICT (email) DO NOTHING;

-- Generate comprehensive parcel data (150 parcels)
INSERT INTO public.devnet_parcels (parcel_number, start_year, end_year, data, devnet_id)
SELECT 
    lpad((100000 + i)::text, 3, '0') || '-' || 
    lpad(((i * 7) % 1000 + 100)::text, 3, '0') || '-' || 
    lpad(((i * 13) % 1000 + 100)::text, 3, '0') as parcel_number,
    2022 + (i % 3) as start_year,
    2023 + (i % 3) as end_year,
    jsonb_build_object(
        'owner', 'Owner ' || i,
        'address', (100 + (i * 3) % 900) || ' ' || 
                  CASE (i % 15)
                      WHEN 0 THEN 'Main St'
                      WHEN 1 THEN 'Oak Ave'
                      WHEN 2 THEN 'Pine Rd'
                      WHEN 3 THEN 'Elm St'
                      WHEN 4 THEN 'Maple Dr'
                      WHEN 5 THEN 'Cedar Ln'
                      WHEN 6 THEN 'First Ave'
                      WHEN 7 THEN 'Second St'
                      WHEN 8 THEN 'Third Ave'
                      WHEN 9 THEN 'Broadway'
                      WHEN 10 THEN 'Park Ave'
                      WHEN 11 THEN 'Central St'
                      WHEN 12 THEN 'North Rd'
                      WHEN 13 THEN 'South St'
                      ELSE 'East Ave'
                  END,
        'property_type', CASE (i % 4)
                           WHEN 0 THEN 'residential'
                           WHEN 1 THEN 'commercial'
                           WHEN 2 THEN 'industrial'
                           ELSE 'mixed_use'
                       END,
        'square_feet', 1000 + (i * 50) % 3000,
        'year_built', 1950 + (i * 3) % 70,
        'neighborhood', CASE (i % 8)
                          WHEN 0 THEN 'Downtown'
                          WHEN 1 THEN 'Midtown'
                          WHEN 2 THEN 'Uptown'
                          WHEN 3 THEN 'Eastside'
                          WHEN 4 THEN 'Westside'
                          WHEN 5 THEN 'Northside'
                          WHEN 6 THEN 'Southside'
                          ELSE 'Suburbs'
                      END
    ) as data,
    'DEV' || lpad(i::text, 4, '0') as devnet_id
FROM generate_series(1, 150) as i
ON CONFLICT DO NOTHING;

-- Generate comprehensive neighborhood reports (110 reports)
INSERT INTO public.devnet_neighborhood_report (neighborhood_name, start_year, end_year, data, devnet_id)
SELECT 
    CASE (i % 11)
        WHEN 0 THEN 'Downtown'
        WHEN 1 THEN 'Midtown'
        WHEN 2 THEN 'Uptown'
        WHEN 3 THEN 'Eastside'
        WHEN 4 THEN 'Westside'
        WHEN 5 THEN 'Northside'
        WHEN 6 THEN 'Southside'
        WHEN 7 THEN 'Suburbs'
        WHEN 8 THEN 'Historic District'
        WHEN 9 THEN 'Waterfront'
        ELSE 'Industrial Zone'
    END as neighborhood_name,
    2020 + (i % 5) as start_year,
    2021 + (i % 5) as end_year,
    jsonb_build_object(
        'median_home_value', 150000 + (i * 5000) % 300000,
        'population', 500 + (i * 100) % 5000,
        'crime_rate', 1.0 + (i * 0.1) % 5.0,
        'school_rating', 6 + (i % 5),
        'amenities', array[
            CASE WHEN (i % 4) = 0 THEN 'schools' END,
            CASE WHEN (i % 3) = 0 THEN 'parks' END,
            CASE WHEN (i % 5) = 0 THEN 'shopping' END,
            CASE WHEN (i % 7) = 0 THEN 'transit' END
        ]::text[],
        'market_trend', CASE (i % 3)
                          WHEN 0 THEN 'rising'
                          WHEN 1 THEN 'stable'
                          ELSE 'declining'
                      END
    ) as data,
    'NBH' || lpad(i::text, 4, '0') as devnet_id
FROM generate_series(1, 110) as i;

-- Generate comprehensive sales data (200 sales)
INSERT INTO public.devnet_sales (sale_price, sale_date, sale_type, sale_status, data, devnet_id)
SELECT 
    (100000 + (i * 7919) % 500000)::numeric(12,2) as sale_price,
    '2022-01-01'::date + (i * 5) % 1095 as sale_date,
    CASE (i % 5)
        WHEN 0 THEN 'arms_length'
        WHEN 1 THEN 'foreclosure'
        WHEN 2 THEN 'estate'
        WHEN 3 THEN 'family'
        ELSE 'auction'
    END as sale_type,
    CASE (i % 4)
        WHEN 0 THEN 'verified'
        WHEN 1 THEN 'pending'
        WHEN 2 THEN 'under_review'
        ELSE 'approved'
    END as sale_status,
    jsonb_build_object(
        'buyer', 'Buyer ' || i,
        'seller', 'Seller ' || i,
        'financing', CASE (i % 4)
                       WHEN 0 THEN 'cash'
                       WHEN 1 THEN 'conventional'
                       WHEN 2 THEN 'fha'
                       ELSE 'va'
                   END,
        'days_on_market', 5 + (i * 3) % 180,
        'listing_price', (110000 + (i * 7919) % 500000)::numeric(12,2),
        'agent_name', 'Agent ' || ((i % 50) + 1),
        'property_condition', CASE (i % 5)
                                WHEN 0 THEN 'excellent'
                                WHEN 1 THEN 'good'
                                WHEN 2 THEN 'average'
                                WHEN 3 THEN 'fair'
                                ELSE 'poor'
                            END
    ) as data,
    'SALE' || lpad(i::text, 5, '0') as devnet_id
FROM generate_series(1, 200) as i;

-- Generate sale-parcel relationships (300 relationships, some sales have multiple parcels)
INSERT INTO public.devnet_sale_parcels (sale_id, parcel_id, data)
SELECT 
    (i % 200) + 1 as sale_id,
    ((i * 7) % 150) + 1 as parcel_id,
    jsonb_build_object(
        'parcel_role', CASE (i % 3)
                         WHEN 0 THEN 'primary'
                         WHEN 1 THEN 'secondary'
                         ELSE 'additional'
                     END,
        'parcel_percentage', CASE 
                               WHEN (i % 3) = 0 THEN 100
                               WHEN (i % 3) = 1 THEN 60
                               ELSE 40
                           END
    ) as data
FROM generate_series(1, 300) as i
ON CONFLICT (sale_id, parcel_id) DO NOTHING;

-- Generate comprehensive reviews data (250 reviews)
INSERT INTO public.devnet_reviews (
    kind, 
    current_status_id, 
    assigned_to_id, 
    due_date, 
    entity_type, 
    entity_id, 
    data_status, 
    requires_field_review, 
    title, 
    description, 
    priority, 
    data,
    field_data,
    field_notes,
    created_at,
    updated_at
)
SELECT 
    CASE (i % 4)
        WHEN 0 THEN 'sale_review'::public.devnet_review_kind
        WHEN 1 THEN 'permit_review'::public.devnet_review_kind
        WHEN 2 THEN 'appeal_review'::public.devnet_review_kind
        ELSE 'custom_review'::public.devnet_review_kind
    END as kind,
    -- Get appropriate status for each kind
    (SELECT id FROM public.devnet_review_statuses rs 
     WHERE rs.review_kind = CASE (i % 4)
                              WHEN 0 THEN 'sale_review'::public.devnet_review_kind
                              WHEN 1 THEN 'permit_review'::public.devnet_review_kind
                              WHEN 2 THEN 'appeal_review'::public.devnet_review_kind
                              ELSE 'custom_review'::public.devnet_review_kind
                          END
     ORDER BY rs.sort_order + (i % 3) 
     LIMIT 1) as current_status_id,
    (i % 120) + 1 as assigned_to_id,
    CURRENT_DATE + (i % 30) as due_date,
    CASE (i % 4)
        WHEN 0 THEN 'devnet_sales'
        WHEN 1 THEN 'devnet_parcels'
        WHEN 2 THEN 'devnet_parcels'
        ELSE 'devnet_sales'
    END as entity_type,
    CASE (i % 4)
        WHEN 0 THEN (i % 200) + 1
        WHEN 1 THEN (i % 150) + 1
        WHEN 2 THEN (i % 150) + 1
        ELSE (i % 200) + 1
    END as entity_id,
    CASE (i % 6)
        WHEN 0 THEN 'not_collected'::public.devnet_data_status
        WHEN 1 THEN 'in_field'::public.devnet_data_status
        WHEN 2 THEN 'collected'::public.devnet_data_status
        WHEN 3 THEN 'entered'::public.devnet_data_status
        WHEN 4 THEN 'copied_to_devnet'::public.devnet_data_status
        ELSE 'verified'::public.devnet_data_status
    END as data_status,
    (i % 3) = 0 as requires_field_review,
    CASE (i % 4)
        WHEN 0 THEN 'Sale Review #' || i
        WHEN 1 THEN 'Permit Review #' || i
        WHEN 2 THEN 'Appeal Review #' || i
        ELSE 'Custom Review #' || i
    END as title,
    'Review description for item #' || i || '. ' ||
    CASE (i % 5)
        WHEN 0 THEN 'Requires urgent attention due to high priority.'
        WHEN 1 THEN 'Standard review process with normal timeline.'
        WHEN 2 THEN 'Complex case requiring additional documentation.'
        WHEN 3 THEN 'Follow-up review from previous inspection.'
        ELSE 'Routine review as part of regular workflow.'
    END as description,
    CASE (i % 4)
        WHEN 0 THEN 1
        WHEN 1 THEN 2
        WHEN 2 THEN 3
        ELSE 4
    END as priority,
    jsonb_build_object(
        'property_address', (100 + (i * 7) % 900) || ' Test St #' || i,
        'estimated_value', 150000 + (i * 1000) % 400000,
        'urgency_level', CASE (i % 3)
                           WHEN 0 THEN 'low'
                           WHEN 1 THEN 'medium'
                           ELSE 'high'
                       END,
        'review_type', CASE (i % 4)
                         WHEN 0 THEN 'initial'
                         WHEN 1 THEN 'follow_up'
                         WHEN 2 THEN 'appeal'
                         ELSE 'special'
                     END,
        'documents_required', array[
            CASE WHEN (i % 5) = 0 THEN 'deed' END,
            CASE WHEN (i % 4) = 0 THEN 'survey' END,
            CASE WHEN (i % 3) = 0 THEN 'photos' END,
            CASE WHEN (i % 7) = 0 THEN 'appraisal' END
        ]::text[]
    ) as data,
    CASE 
        WHEN (i % 6) >= 2 THEN 
            jsonb_build_object(
                'inspection_date', CURRENT_DATE - (i % 30),
                'inspector_notes', 'Field inspection completed for review #' || i,
                'photos_taken', 3 + (i % 8),
                'measurements', jsonb_build_object(
                    'length', 50 + (i * 3) % 100,
                    'width', 30 + (i * 2) % 60,
                    'height', 8 + (i % 4)
                ),
                'condition_rating', 1 + (i % 5)
            )
        ELSE NULL
    END as field_data,
    CASE 
        WHEN (i % 6) >= 2 THEN 'Field notes for review #' || i || '. Property inspected and documented.'
        ELSE NULL
    END as field_notes,
    CURRENT_TIMESTAMP - (i || ' days')::interval as created_at,
    CURRENT_TIMESTAMP - (GREATEST(0, i - 5) || ' days')::interval as updated_at
FROM generate_series(1, 250) as i;

-- Generate review assignments (400 assignments - multiple assignments per review for different statuses)
INSERT INTO public.devnet_review_assignments (
    review_id, 
    status_id, 
    employee_id, 
    assigned_by_id, 
    due_date, 
    notes,
    completed_at,
    completed_by_id,
    completion_notes,
    is_active
)
SELECT 
    (i % 250) + 1 as review_id,
    -- Get a random status for the review kind
    (SELECT rs.id FROM public.devnet_reviews r 
     JOIN public.devnet_review_statuses rs ON rs.review_kind = r.kind 
     WHERE r.id = (i % 250) + 1 
     ORDER BY rs.sort_order + (i % 3) 
     LIMIT 1) as status_id,
    ((i * 7) % 120) + 1 as employee_id,
    ((i * 11) % 120) + 1 as assigned_by_id,
    CURRENT_DATE + ((i * 3) % 45) as due_date,
    'Assignment #' || i || ' - ' ||
    CASE (i % 4)
        WHEN 0 THEN 'High priority assignment requiring immediate attention'
        WHEN 1 THEN 'Standard assignment with normal processing'
        WHEN 2 THEN 'Complex assignment requiring specialist knowledge'
        ELSE 'Follow-up assignment from previous work'
    END as notes,
    CASE 
        WHEN (i % 3) = 0 THEN CURRENT_TIMESTAMP - ((i % 10) || ' days')::interval
        ELSE NULL
    END as completed_at,
    CASE 
        WHEN (i % 3) = 0 THEN ((i * 7) % 120) + 1
        ELSE NULL
    END as completed_by_id,
    CASE 
        WHEN (i % 3) = 0 THEN 'Assignment completed successfully. All requirements met.'
        ELSE NULL
    END as completion_notes,
    (i % 3) != 0 as is_active
FROM generate_series(1, 400) as i
ON CONFLICT (review_id, status_id, employee_id) DO NOTHING;

-- ============================================================
-- EXAMPLE USAGE QUERIES
-- ============================================================

/*
-- Create a new sale review with data requirements
SELECT create_devnet_review(
    'sale_review',
    'devnet_sale',
    1,
    'Review Sale #1',
    'Verify sale price and conditions',
    1,
    '{"priority": "high"}'::jsonb
);

-- Set data requirements for a review
SELECT set_review_data_requirements(
    1,
    '{"fields": ["verified_price", "condition_rating", "market_analysis"]}'::jsonb,
    '{"verified_price": {"min": 0, "required": true}}'::jsonb,
    '{"completion_threshold": 0.95}'::jsonb
);

-- Mass create reviews
SELECT mass_create_devnet_reviews('[
    {
        "kind": "sale_review",
        "entity_type": "devnet_sale", 
        "entity_id": 1,
        "title": "Sale Review #1",
        "priority": "high",
        "requires_field_review": true,
        "required_data_fields": {"fields": ["verified_price", "condition"]},
        "due_date": "2024-02-01"
    },
    {
        "kind": "sale_review",
        "entity_type": "devnet_sale",
        "entity_id": 2, 
        "title": "Sale Review #2",
        "priority": "medium",
        "requires_field_review": false
    }
]'::jsonb);

-- Mass assign reviews to an employee
SELECT mass_assign_devnet_reviews(
    ARRAY[1, 2, 3, 4, 5],
    1
);
-- Search reviews with filters
SELECT * FROM search_devnet_reviews(
    p_kind := 'sale_review',
    p_priority := 'high',
    p_search_text := 'Downtown'
) LIMIT 25;

-- Search by assigned employee
SELECT * FROM search_devnet_reviews(
    p_assigned_to_employee_id := 1,
    p_search_text := 'in-field'
) LIMIT 50;

-- Search by address
SELECT * FROM search_devnet_reviews(
    p_search_text := 'Main St',
    p_requires_field_review := true
) LIMIT 100;

-- Search by parcel number
SELECT * FROM search_devnet_reviews(
    p_search_text := '123-456'
) LIMIT 25;

-- Search with date ranges
SELECT * FROM search_devnet_reviews(
    p_created_after := '2024-01-01',
    p_due_before := '2024-03-01',
    p_active_only := true
) LIMIT 50;

-- Search sale reviews (filters by kind)
SELECT * FROM search_devnet_reviews(
    p_kind := 'sale_review',
    p_entity_type := 'devnet_sales'
) LIMIT 25;

-- Get review counts by status
SELECT * FROM get_devnet_review_counts('{"kind": "sale_review"}'::jsonb);

-- Get all available filter options
SELECT get_devnet_filter_options();

-- Mass operations examples

-- Mass create assignments for multiple reviews and statuses
SELECT mass_create_devnet_assignments(
    ARRAY[1, 2, 3], -- review_ids
    ARRAY[2, 5], -- status_ids (field-assigned, entry-assigned)
    1, -- employee_id
    2, -- assigned_by_id
    '2024-02-01', -- due_date
    'Bulk assignment for priority reviews'
);

-- Mass reassign reviews from one employee to another
SELECT mass_reassign_devnet_reviews(
    ARRAY[1, 2, 3, 4], -- review_ids
    1, -- from_employee_id
    2, -- to_employee_id
    3, -- assigned_by_id
    '2024-02-15', -- new_due_date
    'Reassigned due to workload balancing'
);

-- Complete multiple assignments at once
SELECT mass_complete_devnet_assignments(
    ARRAY[10, 11, 12], -- assignment_ids
    1, -- completed_by_id
    'Completed field work for all assignments'
);

-- Update due dates for multiple assignments
SELECT mass_update_assignment_due_dates(
    ARRAY[5, 6, 7, 8], -- assignment_ids
    '2024-02-20', -- new_due_date
    2, -- updated_by_id
    'Extended due to complexity'
);

-- Complex search with custom sorting and limiting
SELECT 
    id,
    kind,
    title,
    status_name,
    assigned_to_name,
    neighborhood_name,
    parcel_address,
    priority,
    days_until_due,
    created_at
FROM search_devnet_reviews(
    p_search_text := 'Downtown',
    p_priority := 'high',
    p_active_only := true,
    p_requires_field_review := true
) 
ORDER BY days_until_due ASC NULLS LAST, created_at DESC
LIMIT 100;
*/