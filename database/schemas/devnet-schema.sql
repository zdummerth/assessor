-- ============================================================
-- DEVNET REVIEW SCHEMA: Review Layer for External Database
-- ============================================================
-- Complete implementation with data collection tracking and mass operations
-- Focus: Flexible reviews for sales, permits, appeals with status-specific assignments

-- ============================================================
-- DEVNET ENUMS
-- ============================================================

DROP TYPE IF EXISTS public.devnet_review_kind CASCADE;
CREATE TYPE public.devnet_review_kind AS ENUM (
    'sale_review',
    'permit_review', 
    'appeal_review',
    'custom_review'
);

DROP TYPE IF EXISTS public.devnet_data_status CASCADE;
CREATE TYPE public.devnet_data_status AS ENUM (
    'not_collected',
    'in_field',
    'collected',
    'entered',
    'copied_to_devnet',
    'verified'
);

-- ============================================================
-- DEVNET EMPLOYEES (Simplified with roles)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_employees CASCADE;
CREATE TABLE public.devnet_employees (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid UNIQUE NULL, -- Links to Supabase auth
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text UNIQUE NULL,
    status text NOT NULL DEFAULT 'active',
    can_approve boolean NOT NULL DEFAULT false,
    
    -- Role information for assignments
    role text NULL, -- 'appraiser', 'supervisor', 'data_entry', 'reviewer'
    specialties text[] DEFAULT '{}', -- ['field_work', 'data_entry', 'commercial', 'residential']
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_employees_user_id_idx ON public.devnet_employees (user_id);
CREATE INDEX devnet_employees_status_idx ON public.devnet_employees (status);
CREATE INDEX devnet_employees_role_idx ON public.devnet_employees (role);

-- ============================================================
-- DEVNET DATA TABLES (Copied Daily)
-- ============================================================

-- Devnet parcels data
DROP TABLE IF EXISTS public.devnet_parcels CASCADE;
CREATE TABLE public.devnet_parcels (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_number text NOT NULL,
    start_year integer NULL,
    end_year integer NULL,
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL, -- Original ID from Devnet system
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_parcels_number_idx ON public.devnet_parcels (parcel_number);
CREATE INDEX devnet_parcels_years_idx ON public.devnet_parcels (start_year, end_year);
CREATE INDEX devnet_parcels_devnet_id_idx ON public.devnet_parcels (devnet_id);
CREATE INDEX devnet_parcels_data_gin_idx ON public.devnet_parcels USING gin (data);

-- Devnet neighborhood reports
DROP TABLE IF EXISTS public.devnet_neighborhood_report CASCADE;
CREATE TABLE public.devnet_neighborhood_report (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    neighborhood_name text NOT NULL,
    start_year integer NULL,
    end_year integer NULL,
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL,
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_neighborhood_report_name_idx ON public.devnet_neighborhood_report (neighborhood_name);
CREATE INDEX devnet_neighborhood_report_years_idx ON public.devnet_neighborhood_report (start_year, end_year);
CREATE INDEX devnet_neighborhood_report_data_gin_idx ON public.devnet_neighborhood_report USING gin (data);

-- Devnet sales data
DROP TABLE IF EXISTS public.devnet_sales CASCADE;
CREATE TABLE public.devnet_sales (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_price numeric(12,2) NULL,
    sale_date date NULL,
    sale_type text NULL,
    sale_status text NULL,
    
    -- Additional sale details in JSONB for flexibility
    data jsonb NOT NULL DEFAULT '{}',
    
    -- Metadata
    devnet_id text NULL,
    sync_date timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_sales_date_idx ON public.devnet_sales (sale_date DESC);
CREATE INDEX devnet_sales_price_idx ON public.devnet_sales (sale_price);
CREATE INDEX devnet_sales_type_idx ON public.devnet_sales (sale_type);
CREATE INDEX devnet_sales_devnet_id_idx ON public.devnet_sales (devnet_id);
CREATE INDEX devnet_sales_data_gin_idx ON public.devnet_sales USING gin (data);

-- Junction table for many-to-many sales/parcels relationship
DROP TABLE IF EXISTS public.devnet_sale_parcels CASCADE;
CREATE TABLE public.devnet_sale_parcels (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id bigint NOT NULL REFERENCES public.devnet_sales (id) ON DELETE CASCADE,
    parcel_id bigint NOT NULL REFERENCES public.devnet_parcels (id) ON DELETE CASCADE,
    
    -- Additional relationship data
    data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (sale_id, parcel_id)
);

CREATE INDEX devnet_sale_parcels_sale_idx ON public.devnet_sale_parcels (sale_id);
CREATE INDEX devnet_sale_parcels_parcel_idx ON public.devnet_sale_parcels (parcel_id);

-- ============================================================
-- VIN LOOKUP AND GUIDE TABLES
-- ============================================================

-- Enable pg_trgm extension for text similarity searches
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Enable http extension for external API calls
CREATE EXTENSION IF NOT EXISTS http;

-- VIN lookup table for 2026
DROP TABLE IF EXISTS public.vin_lookup_2026 CASCADE;
CREATE TABLE public.vin_lookup_2026 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vin text NOT NULL,
    model_year text NULL,
    type text NULL,
    description text NULL,
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for VIN lookup table
CREATE INDEX vin_lookup_2026_vin_idx ON public.vin_lookup_2026 (vin);
CREATE INDEX vin_lookup_2026_model_year_idx ON public.vin_lookup_2026 (model_year);
CREATE INDEX vin_lookup_2026_type_idx ON public.vin_lookup_2026 (type);
-- GIN index for trigram text similarity search on description
CREATE INDEX vin_lookup_2026_description_trgm_idx ON public.vin_lookup_2026 USING gin (description gin_trgm_ops);

-- Normalized guide structure: vehicles and their values
DROP TABLE IF EXISTS public.guide_vehicle_values CASCADE;
DROP TABLE IF EXISTS public.guide_vehicles CASCADE;

-- Guide vehicles table - unique vehicle descriptions
CREATE TABLE public.guide_vehicles (
    vehicle_id text PRIMARY KEY,
    type text,
    make text NOT NULL,
    model text NOT NULL,
    "trim" text,
    description text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for guide vehicles table
CREATE INDEX guide_vehicles_type_idx ON public.guide_vehicles (type);
CREATE INDEX guide_vehicles_make_idx ON public.guide_vehicles (make);
CREATE INDEX guide_vehicles_model_idx ON public.guide_vehicles (model);
CREATE INDEX guide_vehicles_description_trgm_idx ON public.guide_vehicles USING gin (description gin_trgm_ops);
-- GIN index for trigram text similarity search on make/model/trim
CREATE INDEX guide_vehicles_make_trgm_idx ON public.guide_vehicles USING gin (make gin_trgm_ops);
CREATE INDEX guide_vehicles_model_trgm_idx ON public.guide_vehicles USING gin (model gin_trgm_ops);
CREATE INDEX guide_vehicles_trim_trgm_idx ON public.guide_vehicles USING gin (trim gin_trgm_ops);

-- Guide vehicle values table - year/value pairs by guide year
CREATE TABLE public.guide_vehicle_values (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vehicle_id text NOT NULL REFERENCES public.guide_vehicles(vehicle_id) ON DELETE CASCADE,
    guide_year integer NOT NULL,
    year integer NOT NULL,
    value numeric(10, 2) NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (vehicle_id, guide_year, year)
);

-- Indexes for guide vehicle values table
CREATE INDEX guide_vehicle_values_vehicle_idx ON public.guide_vehicle_values (vehicle_id);
CREATE INDEX guide_vehicle_values_guide_year_idx ON public.guide_vehicle_values (guide_year);
CREATE INDEX guide_vehicle_values_year_idx ON public.guide_vehicle_values (year);
CREATE INDEX guide_vehicle_values_value_idx ON public.guide_vehicle_values (value);

-- Account vehicles table - vehicles from devnet reports with guide value matches
DROP TABLE IF EXISTS public.account_vehicles CASCADE;
CREATE TABLE public.account_vehicles (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    account_number text NOT NULL,
    vehicle_id text NOT NULL REFERENCES public.guide_vehicles(vehicle_id),
    account_year integer NOT NULL,
    model_year integer NOT NULL,
    description text NOT NULL,
    vin_number text,
    current_value numeric,
    guide_value numeric,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for account vehicles table
CREATE INDEX account_vehicles_account_number_idx ON public.account_vehicles (account_number);
CREATE INDEX account_vehicles_vehicle_id_idx ON public.account_vehicles (vehicle_id);
CREATE INDEX account_vehicles_account_year_idx ON public.account_vehicles (account_year);
CREATE INDEX account_vehicles_model_year_idx ON public.account_vehicles (model_year);
CREATE INDEX account_vehicles_vin_idx ON public.account_vehicles (vin_number);
CREATE INDEX account_vehicles_current_value_idx ON public.account_vehicles (current_value);
CREATE INDEX account_vehicles_description_trgm_idx ON public.account_vehicles USING gin (description gin_trgm_ops);

-- ============================================================
-- UNIFIED VEHICLE SEARCH FUNCTION (Combined)
-- ============================================================

-- Combined search function: Auto-detect VIN or description, search with NHTSA API fallback
DROP FUNCTION IF EXISTS search_vehicle_unified CASCADE;
DROP FUNCTION IF EXISTS decode_vin_nhtsa CASCADE;
CREATE OR REPLACE FUNCTION search_vehicle_unified(
    p_search_text text,
    p_search_type text DEFAULT 'auto',
    p_guide_year integer DEFAULT 2026,
    p_match_limit integer DEFAULT 10,
    p_similarity_threshold numeric DEFAULT 0.0
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    v_search_type text;
    v_is_vin boolean;
    v_result jsonb;
    v_vin_lookup_count integer;
    v_url text;
    v_response http_response;
    v_api_result jsonb;
    v_make text;
    v_model text;
    v_model_year text;
    v_trim text;
    v_trailer_body_type text;
    v_trailer_length text;
    v_series text;
    v_series_2 text;
    v_displacement_cc text;
    v_search_string text;
    v_model_year_int integer;
    v_guide_matches jsonb;
BEGIN
    -- Normalize search text
    p_search_text := trim(p_search_text);
    v_search_type := lower(p_search_type);
    
    -- Auto-detect: VIN (8-17 alphanumeric chars) or description
    IF v_search_type = 'auto' THEN
        v_is_vin := (length(p_search_text) BETWEEN 8 AND 17) 
                    AND (p_search_text ~ '^[A-HJ-NPR-Z0-9]+$');
        v_search_type := CASE WHEN v_is_vin THEN 'vin' ELSE 'description' END;
    END IF;
    
    -- VIN SEARCH PATH
    IF v_search_type = 'vin' THEN
        -- Step 1: Check vin_lookup_2026 table
        WITH vin_matches AS (
            SELECT 
                v.id, v.vin, v.model_year, v.type, v.description
            FROM public.vin_lookup_2026 v
            WHERE CASE 
                WHEN length(p_search_text) >= length(v.vin) THEN
                    substring(p_search_text, 1, length(v.vin)) LIKE replace(v.vin, '?', '_')
                ELSE
                    p_search_text || repeat('_', length(v.vin) - length(p_search_text)) LIKE replace(v.vin, '?', '_')
            END
            LIMIT 100
        ),
        guide_matches AS (
            SELECT 
                vm.id as vin_id, vm.vin, vm.model_year, vm.type, vm.description as vin_description,
                jsonb_agg(
                    jsonb_build_object(
                        'vehicle_id', gv.vehicle_id, 'type', gv.type, 'make', gv.make,
                        'model', gv.model, 'trim', gv.trim, 'description', gv.description,
                        'similarity_score', gv.similarity_score, 'values', gv.values
                    )
                    ORDER BY gv.similarity_score DESC
                ) FILTER (WHERE gv.vehicle_id IS NOT NULL AND gv.values IS NOT NULL) as matches
            FROM vin_matches vm
            LEFT JOIN LATERAL (
                SELECT 
                    g.vehicle_id, g.type, g.make, g.model, g.trim,
                    g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '') as description,
                    similarity(COALESCE(vm.description, ''), g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '')) as similarity_score,
                    (
                        SELECT jsonb_agg(jsonb_build_object('guide_year', gvv.guide_year, 'year', gvv.year, 'value', gvv.value) ORDER BY gvv.guide_year DESC, gvv.year DESC)
                        FROM public.guide_vehicle_values gvv
                        WHERE gvv.vehicle_id = g.vehicle_id AND gvv.guide_year = COALESCE(p_guide_year, gvv.guide_year)
                    ) as values
                FROM public.guide_vehicles g
                WHERE similarity(COALESCE(vm.description, ''), g.make || ' ' || g.model || ' ' || COALESCE(g.trim, '')) > p_similarity_threshold
                ORDER BY similarity_score DESC
                LIMIT p_match_limit
            ) gv ON true
            GROUP BY vm.id, vm.vin, vm.model_year, vm.type, vm.description
            HAVING jsonb_array_length(jsonb_agg(jsonb_build_object('vehicle_id', gv.vehicle_id, 'type', gv.type, 'make', gv.make, 'model', gv.model, 'trim', gv.trim, 'description', gv.description, 'similarity_score', gv.similarity_score, 'values', gv.values) ORDER BY gv.similarity_score DESC) FILTER (WHERE gv.vehicle_id IS NOT NULL AND gv.values IS NOT NULL)) > 0
        )
        SELECT jsonb_build_object(
            'search_text', p_search_text, 'search_type', 'vin', 'source', 'vin_lookup_table',
            'match_count', COUNT(*),
            'results', jsonb_agg(jsonb_build_object('vin_id', gm.vin_id, 'vin', gm.vin, 'model_year', gm.model_year, 'type', gm.type, 'vin_description', gm.vin_description, 'guide_matches', COALESCE(gm.matches, '[]'::jsonb)))
        ) INTO v_result FROM guide_matches gm;
        
        v_vin_lookup_count := COALESCE((v_result->>'match_count')::integer, 0);
        
        -- Step 2: If full VIN (17 chars) and no lookup matches, try NHTSA API
        IF v_vin_lookup_count = 0 AND length(p_search_text) = 17 THEN
            BEGIN
                v_url := 'https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVinValues/' || p_search_text || '?format=json';
                v_response := http_get(v_url);
                v_api_result := v_response.content::jsonb->'Results'->0;
                
                -- Extract fields (replace 'Not Applicable' with null)
                v_make := NULLIF(v_api_result->>'Make', 'Not Applicable');
                v_model := NULLIF(v_api_result->>'Model', 'Not Applicable');
                v_model_year := NULLIF(v_api_result->>'ModelYear', 'Not Applicable');
                v_trim := NULLIF(v_api_result->>'Trim', 'Not Applicable');
                v_trailer_body_type := NULLIF(v_api_result->>'TrailerBodyType', 'Not Applicable');
                v_trailer_length := NULLIF(v_api_result->>'TrailerLength', 'Not Applicable');
                v_series := NULLIF(v_api_result->>'Series', 'Not Applicable');
                v_series_2 := NULLIF(v_api_result->>'Series2', 'Not Applicable');
                v_displacement_cc := NULLIF(v_api_result->>'DisplacementCC', 'Not Applicable');
                v_model_year_int := NULLIF(v_model_year, '')::integer;
                
                                v_search_string := TRIM(
                                    array_to_string(
                                        ARRAY[
                                            v_make,
                                            v_model,
                                            v_trim,
                                            v_trailer_body_type,
                                            v_trailer_length,
                                            v_series,
                                            v_series_2,
                                            v_displacement_cc
                                        ], ' ', ''
                                    )
                                );
                
                -- Search guide vehicles with bonus scoring
                WITH scored_matches AS (
                    SELECT 
                        gv.vehicle_id, gv.type, gv.make, gv.model, gv.trim,
                        similarity(LOWER(gv.description), LOWER(v_search_string)) as desc_similarity,
                        -- Bonus for matching vehicle type
                        CASE 
                            WHEN v_api_result->>'VehicleType' IS NOT NULL AND gv.type ILIKE v_api_result->>'VehicleType'
                            THEN 0.05
                            ELSE 0
                        END +
                        -- Bonus for matching make in description
                        CASE 
                            WHEN v_make IS NOT NULL AND gv.description ILIKE '%' || v_make || '%' 
                            THEN 0.02 
                            ELSE 0 
                        END +
                        -- Bonus for matching model in description
                        CASE 
                            WHEN v_model IS NOT NULL AND gv.description ILIKE '%' || v_model || '%' 
                            THEN 0.02 
                            ELSE 0 
                        END +
                        -- Bonus for matching trim in description
                        CASE 
                            WHEN v_trim IS NOT NULL AND gv.description ILIKE '%' || v_trim || '%' 
                            THEN 0.02 
                            ELSE 0 
                        END as field_bonus,
                        (SELECT COUNT(*) FROM guide_vehicle_values gvv WHERE gvv.vehicle_id = gv.vehicle_id AND gvv.guide_year = p_guide_year AND v_model_year_int IS NOT NULL) as value_count
                    FROM guide_vehicles gv
                ),
                ranked_matches AS (
                    SELECT 
                        sm.*, (sm.desc_similarity + sm.field_bonus) as final_score
                    FROM scored_matches sm
                    WHERE (sm.desc_similarity + sm.field_bonus) >= p_similarity_threshold
                        AND sm.value_count > 0
                    ORDER BY (sm.desc_similarity + sm.field_bonus) DESC, sm.value_count DESC
                    LIMIT p_match_limit
                )
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'vehicle_id', rm.vehicle_id, 'type', rm.type, 'make', rm.make, 'model', rm.model, 'trim', rm.trim,
                        'similarity_score', ROUND(rm.final_score::numeric, 3),
                        'values', (SELECT jsonb_agg(jsonb_build_object('guide_year', gvv.guide_year, 'year', gvv.year, 'value', gvv.value) ORDER BY gvv.year DESC) FROM guide_vehicle_values gvv WHERE gvv.vehicle_id = rm.vehicle_id AND gvv.guide_year = p_guide_year AND v_model_year_int IS NOT NULL)
                    )
                ) INTO v_guide_matches FROM ranked_matches rm;
                
                v_result := jsonb_build_object(
                    'search_text', p_search_text, 'search_type', 'vin', 'source', 'nhtsa_api',
                    'match_count', COALESCE(jsonb_array_length(v_guide_matches), 0),
                    'results', jsonb_build_array(jsonb_build_object(
                        'vin', p_search_text,
                        'api_data', v_api_result,
                        'extracted_fields', jsonb_build_object('make', v_make, 'model', v_model, 'model_year', v_model_year, 'trim', v_trim),
                        'search_description', v_search_string,
                        'guide_matches', COALESCE(v_guide_matches, '[]'::jsonb)
                    ))
                );
            EXCEPTION WHEN OTHERS THEN
                v_result := jsonb_build_object(
                    'search_text', p_search_text, 'search_type', 'vin', 'source', 'nhtsa_api_error',
                    'match_count', 0, 'results', '[]'::jsonb, 'error', SQLERRM
                );
            END;
        END IF;
        
        RETURN COALESCE(v_result, jsonb_build_object(
            'search_text', p_search_text, 'search_type', 'vin', 'source', 'none',
            'match_count', 0, 'results', '[]'::jsonb, 'message', 'No matches found'
        ));
    
    -- DESCRIPTION SEARCH PATH
    ELSE
        WITH vehicle_matches AS (
            SELECT 
                gv.vehicle_id, gv.type, gv.make, gv.model, gv.trim, gv.description,
                GREATEST(
                    similarity(p_search_text, gv.description),
                    similarity(p_search_text, gv.make || ' ' || gv.model),
                    similarity(p_search_text, gv.make),
                    similarity(p_search_text, gv.model),
                    similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.description, '[.-]', '', 'g')),
                    similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.make, '[.-]', '', 'g')),
                    similarity(regexp_replace(p_search_text, '[.-]', '', 'g'), regexp_replace(gv.model, '[.-]', '', 'g'))
                ) as similarity_score
            FROM public.guide_vehicles gv
            INNER JOIN public.guide_vehicle_values gvv ON gv.vehicle_id = gvv.vehicle_id
            WHERE p_search_text IS NOT NULL
                AND (
                    gv.description % p_search_text OR gv.make % p_search_text OR gv.model % p_search_text OR gv.trim % p_search_text
                    OR regexp_replace(gv.description, '[.-]', '', 'g') % regexp_replace(p_search_text, '[.-]', '', 'g')
                    OR regexp_replace(gv.make, '[.-]', '', 'g') % regexp_replace(p_search_text, '[.-]', '', 'g')
                    OR regexp_replace(gv.model, '[.-]', '', 'g') % regexp_replace(p_search_text, '[.-]', '', 'g')
                )
                AND gvv.guide_year = COALESCE(p_guide_year, gvv.guide_year)
            GROUP BY gv.vehicle_id, gv.type, gv.make, gv.model, gv.trim, gv.description
            ORDER BY similarity_score DESC
            LIMIT LEAST(p_match_limit, 100)
        )
        SELECT jsonb_build_object(
            'search_text', p_search_text, 'search_type', 'description', 'source', 'guide_vehicles',
            'match_count', COUNT(*),
            'results', jsonb_agg(
                jsonb_build_object(
                    'vehicle_id', vm.vehicle_id, 'type', vm.type, 'make', vm.make, 'model', vm.model,
                    'trim', vm.trim, 'description', vm.description, 'similarity_score', vm.similarity_score,
                    'values', COALESCE((SELECT jsonb_agg(jsonb_build_object('guide_year', gvv.guide_year, 'year', gvv.year, 'value', gvv.value) ORDER BY gvv.guide_year DESC, gvv.year DESC) FROM public.guide_vehicle_values gvv WHERE gvv.vehicle_id = vm.vehicle_id AND (p_guide_year IS NULL OR gvv.guide_year = p_guide_year)), '[]'::jsonb)
                )
                ORDER BY vm.similarity_score DESC
            )
        ) INTO v_result FROM vehicle_matches vm;
        
        RETURN COALESCE(v_result, jsonb_build_object(
            'search_text', p_search_text, 'search_type', 'description', 'source', 'guide_vehicles',
            'match_count', 0, 'results', '[]'::jsonb, 'message', 'No matches found'
        ));
    END IF;
END;
$$;

-- ============================================================
-- VEHICLE VALUE SEARCH FUNCTION
-- ============================================================

-- Search vehicle values with filters for make, model, trim, years
DROP FUNCTION IF EXISTS search_vehicle_values(text, text, text, integer, integer);
CREATE OR REPLACE FUNCTION search_vehicle_values(
    p_type text DEFAULT NULL,
    p_make text DEFAULT NULL,
    p_model text DEFAULT NULL,
    p_trim text DEFAULT NULL,
    p_model_year_min integer DEFAULT NULL,
    p_model_year_max integer DEFAULT NULL,
    p_guide_year integer DEFAULT NULL
)
RETURNS TABLE (
    vehicle_id text,
    type text,
    make text,
    model text,
    "trim" text,
    description text,
    values jsonb,
    vehicle_created_at timestamptz,
    vehicle_updated_at timestamptz
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.vehicle_id,
        gv.type,
        gv.make,
        gv.model,
        gv.trim,
        gv.description,
        jsonb_agg(
            jsonb_build_object(
                'guide_year', gvv.guide_year,
                'year', gvv.year,
                'value', gvv.value
            ) ORDER BY gvv.guide_year DESC, gvv.year DESC
        ) as values,
        gv.created_at as vehicle_created_at,
        gv.updated_at as vehicle_updated_at
    FROM public.guide_vehicles gv
    INNER JOIN public.guide_vehicle_values gvv ON gv.vehicle_id = gvv.vehicle_id
    WHERE 
        (p_make IS NULL OR gv.make ILIKE '%' || p_make || '%')
        AND (p_type IS NULL OR gv.type ILIKE '%' || p_type || '%')  
        AND (p_model IS NULL OR gv.model ILIKE '%' || p_model || '%')
        AND (p_trim IS NULL OR gv.trim ILIKE '%' || p_trim || '%')
        AND (p_model_year_min IS NULL OR gvv.year >= p_model_year_min)
        AND (p_model_year_max IS NULL OR gvv.year <= p_model_year_max)
        AND (p_guide_year IS NULL OR gvv.guide_year = p_guide_year)
    GROUP BY 
        gv.vehicle_id,
        gv.type,
        gv.make,
        gv.model,
        gv.trim,
        gv.description,
        gv.created_at,
        gv.updated_at
    ORDER BY gv.make, gv.model;
END;
$$;

-- ============================================================
-- VEHICLE FILTER OPTIONS FUNCTIONS
-- ============================================================

-- Get distinct vehicle types
DROP FUNCTION IF EXISTS get_distinct_vehicle_types();
CREATE OR REPLACE FUNCTION get_distinct_vehicle_types()
RETURNS TABLE (
    type text,
    vehicle_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.type,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count
    FROM public.guide_vehicles gv
    WHERE gv.type IS NOT NULL
    GROUP BY gv.type
    ORDER BY gv.type;
END;
$$;

-- Get distinct vehicle makes
DROP FUNCTION IF EXISTS get_distinct_vehicle_makes();
CREATE OR REPLACE FUNCTION get_distinct_vehicle_makes()
RETURNS TABLE (
    make text,
    vehicle_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.make,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count
    FROM public.guide_vehicles gv
    GROUP BY gv.make
    ORDER BY gv.make;
END;
$$;

-- Get distinct models by make
DROP FUNCTION IF EXISTS get_distinct_models_by_make(text);
CREATE OR REPLACE FUNCTION get_distinct_models_by_make(
    p_make text
)
RETURNS TABLE (
    model text,
    vehicle_count bigint,
    has_trim boolean
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.model,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count,
        bool_or(gv.trim IS NOT NULL AND gv.trim != '') as has_trim
    FROM public.guide_vehicles gv
    WHERE gv.make = p_make
    GROUP BY gv.model
    ORDER BY gv.model;
END;
$$;

-- Get distinct guide years
DROP FUNCTION IF EXISTS get_distinct_guide_years();
CREATE OR REPLACE FUNCTION get_distinct_guide_years()
RETURNS TABLE (
    guide_year integer,
    vehicle_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gvv.guide_year,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count
    FROM guide_vehicles gv
    JOIN guide_vehicle_values gvv ON gv.vehicle_id = gvv.vehicle_id
    GROUP BY gvv.guide_year
    ORDER BY gvv.guide_year DESC;
END;
$$;

-- Get distinct types by guide year
DROP FUNCTION IF EXISTS get_distinct_types_by_guide_year(integer);
CREATE OR REPLACE FUNCTION get_distinct_types_by_guide_year(
    p_guide_year integer
)
RETURNS TABLE (
    type text,
    vehicle_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.type,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count
    FROM guide_vehicles gv
    JOIN guide_vehicle_values gvv ON gv.vehicle_id = gvv.vehicle_id
    WHERE gvv.guide_year = p_guide_year
    GROUP BY gv.type
    ORDER BY gv.type;
END;
$$;

-- Get distinct makes by guide year and type
DROP FUNCTION IF EXISTS get_distinct_makes_by_guide_year_type(integer, text);
CREATE OR REPLACE FUNCTION get_distinct_makes_by_guide_year_type(
    p_guide_year integer,
    p_type text DEFAULT NULL
)
RETURNS TABLE (
    make text,
    vehicle_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.make,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count
    FROM guide_vehicles gv
    JOIN guide_vehicle_values gvv ON gv.vehicle_id = gvv.vehicle_id
    WHERE gvv.guide_year = p_guide_year
        AND (p_type IS NULL OR gv.type = p_type)
    GROUP BY gv.make
    ORDER BY gv.make;
END;
$$;

-- Get distinct models by guide year, type, and make
DROP FUNCTION IF EXISTS get_distinct_models_by_guide_year_type_make(integer, text, text);
CREATE OR REPLACE FUNCTION get_distinct_models_by_guide_year_type_make(
    p_guide_year integer,
    p_type text DEFAULT NULL,
    p_make text DEFAULT NULL
)
RETURNS TABLE (
    model text,
    vehicle_count bigint,
    has_trim boolean
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gv.model,
        COUNT(DISTINCT gv.vehicle_id) as vehicle_count,
        bool_or(gv.trim IS NOT NULL AND gv.trim != '') as has_trim
    FROM guide_vehicles gv
    JOIN guide_vehicle_values gvv ON gv.vehicle_id = gvv.vehicle_id
    WHERE gvv.guide_year = p_guide_year
        AND (p_type IS NULL OR gv.type = p_type)
        AND (p_make IS NULL OR gv.make = p_make)
    GROUP BY gv.model
    ORDER BY gv.model;
END;
$$;


-- ============================================================
-- Real Estate Records Tables
-- ============================================================

-- Abstract Books - Track printed collections of deed abstracts
DROP TABLE IF EXISTS public.deed_abstract_books CASCADE;
CREATE TABLE public.deed_abstract_books (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    book_title text NOT NULL UNIQUE, -- typically a number like "1875"
    printed_at timestamptz NOT NULL DEFAULT now(),
    printed_by_employee_user_id uuid NOT NULL REFERENCES public.employees (user_id),
    saved_location text NULL, -- file path or storage location (optional but recommended)
    notes text NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX deed_abstract_books_printed_at_idx ON public.deed_abstract_books (printed_at DESC);
CREATE INDEX deed_abstract_books_printed_by_idx ON public.deed_abstract_books (printed_by_employee_user_id);
CREATE INDEX deed_abstract_books_title_idx ON public.deed_abstract_books (book_title);

-- Deed Abstracts - Individual deed records
DROP TABLE IF EXISTS public.deed_abstracts CASCADE;
CREATE TABLE public.deed_abstracts (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    date_filed date NULL,
    date_of_deed date NULL,
    daily_number integer NULL,
    type_of_conveyance text NULL,
    grantor_name text NULL,
    grantor_address text NULL,
    grantee_name text NULL,
    grantee_address text NULL,
    consideration_amount integer NULL, -- in cents
    stamps text NULL,
    city_block text NULL,
    legal_description text NULL,
    title_company text NULL,
    is_transfer boolean NOT NULL DEFAULT false,
    book_id bigint NULL REFERENCES public.deed_abstract_books (id) ON DELETE SET NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    created_by_employee_user_id uuid NOT NULL REFERENCES public.employees (user_id),
    published_at timestamptz NULL
);

CREATE INDEX deed_abstracts_book_id_idx ON public.deed_abstracts (book_id);
CREATE INDEX deed_abstracts_date_filed_idx ON public.deed_abstracts (date_filed DESC);
CREATE INDEX deed_abstracts_published_at_idx ON public.deed_abstracts (published_at DESC);

DROP TABLE IF EXISTS public.deed_abstracts_history CASCADE;
CREATE TABLE public.deed_abstracts_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    deed_abstract_id bigint NOT NULL REFERENCES public.deed_abstracts (id) ON DELETE CASCADE,
    change_type text NOT NULL, -- 'insert', 'update', 'delete'
    changed_at timestamptz NOT NULL DEFAULT now(),
    changed_by_employee_user_id uuid NOT NULL REFERENCES public.employees (user_id),
    old_data jsonb NULL,
    new_data jsonb NULL
);

-- ============================================================
-- DEED ABSTRACTS TRIGGERS
-- ============================================================

-- Log deed abstract updates to history
DROP FUNCTION IF EXISTS log_deed_abstract_changes() CASCADE;
CREATE OR REPLACE FUNCTION log_deed_abstract_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Log update to history
    INSERT INTO public.deed_abstracts_history (
        deed_abstract_id,
        change_type,
        changed_by_employee_user_id,
        old_data,
        new_data
    ) VALUES (
        OLD.id,
        'update',
        NEW.created_by_employee_user_id, -- Use the employee from the updated record
        row_to_json(OLD)::jsonb,
        row_to_json(NEW)::jsonb
    );
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS deed_abstracts_update_trigger ON public.deed_abstracts;
CREATE TRIGGER deed_abstracts_update_trigger
    AFTER UPDATE ON public.deed_abstracts
    FOR EACH ROW
    EXECUTE FUNCTION log_deed_abstract_changes();

-- Prevent deletion if published
DROP FUNCTION IF EXISTS prevent_published_deed_abstract_deletion() CASCADE;
CREATE OR REPLACE FUNCTION prevent_published_deed_abstract_deletion()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Check if the deed abstract is published
    IF OLD.published_at IS NOT NULL THEN
        RAISE EXCEPTION 'Cannot delete published deed abstract (id: %). Unpublish first.', OLD.id;
    END IF;
    
    -- Log deletion to history before allowing it
    INSERT INTO public.deed_abstracts_history (
        deed_abstract_id,
        change_type,
        changed_by_employee_user_id,
        old_data,
        new_data
    ) VALUES (
        OLD.id,
        'delete',
        OLD.created_by_employee_user_id, -- Use the employee from the record being deleted
        row_to_json(OLD)::jsonb,
        NULL
    );
    
    RETURN OLD;
END;
$$;

DROP TRIGGER IF EXISTS deed_abstracts_delete_trigger ON public.deed_abstracts;
CREATE TRIGGER deed_abstracts_delete_trigger
    BEFORE DELETE ON public.deed_abstracts
    FOR EACH ROW
    EXECUTE FUNCTION prevent_published_deed_abstract_deletion();

-- ============================================================
-- DEED ABSTRACT BOOK FUNCTIONS
-- ============================================================

-- Get abstracts ready for printing (unpublished, no book)
DROP FUNCTION IF EXISTS get_printable_abstracts(integer, date, date);
CREATE OR REPLACE FUNCTION get_printable_abstracts(
    p_limit integer DEFAULT 1000,
    p_start_date date DEFAULT NULL,
    p_end_date date DEFAULT NULL
)
RETURNS TABLE (
    id bigint,
    date_filed date,
    date_of_deed date,
    daily_number integer,
    type_of_conveyance text,
    grantor_name text,
    grantor_address text,
    grantee_name text,
    grantee_address text,
    consideration_amount integer,
    stamps text,
    city_block text,
    legal_description text,
    title_company text,
    is_transfer boolean,
    created_at timestamptz,
    created_by_employee_user_id uuid,
    published_at timestamptz
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        da.id,
        da.date_filed,
        da.date_of_deed,
        da.daily_number,
        da.type_of_conveyance,
        da.grantor_name,
        da.grantor_address,
        da.grantee_name,
        da.grantee_address,
        da.consideration_amount,
        da.stamps,
        da.city_block,
        da.legal_description,
        da.title_company,
        da.is_transfer,
        da.created_at,
        da.created_by_employee_user_id,
        da.published_at
    FROM public.deed_abstracts da
    WHERE da.book_id IS NULL
        AND (p_start_date IS NULL OR da.date_filed >= p_start_date)
        AND (p_end_date IS NULL OR da.date_filed <= p_end_date)
    ORDER BY da.date_filed ASC, da.daily_number ASC
    LIMIT p_limit;
END;
$$;

-- Assign abstracts to book in batch
DROP FUNCTION IF EXISTS assign_abstracts_to_book(bigint[], bigint);
CREATE OR REPLACE FUNCTION assign_abstracts_to_book(
    p_abstract_ids bigint[],
    p_book_id bigint
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    v_updated_count integer;
BEGIN
    UPDATE public.deed_abstracts
    SET book_id = p_book_id,
        published_at = CASE WHEN published_at IS NULL THEN now() ELSE published_at END
    WHERE id = ANY(p_abstract_ids);
    
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
    RETURN v_updated_count;
END;
$$;

-- Get book statistics
DROP FUNCTION IF EXISTS get_book_stats(bigint);
CREATE OR REPLACE FUNCTION get_book_stats(p_book_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    v_result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'abstract_count', COUNT(da.id),
        'earliest_date_filed', MIN(da.date_filed),
        'latest_date_filed', MAX(da.date_filed),
        'total_consideration', SUM(da.consideration_amount),
        'transfer_count', COUNT(*) FILTER (WHERE da.is_transfer = true),
        'non_transfer_count', COUNT(*) FILTER (WHERE da.is_transfer = false)
    )
    INTO v_result
    FROM public.deed_abstracts da
    WHERE da.book_id = p_book_id;
    
    RETURN v_result;
END;
$$;

-- Get books with statistics
DROP FUNCTION IF EXISTS get_books_with_stats();
CREATE OR REPLACE FUNCTION get_books_with_stats()
RETURNS TABLE (
    id bigint,
    book_title text,
    printed_at timestamptz,
    printed_by_employee_user_id uuid,
    printed_by_employee_email text,
    saved_location text,
    notes text,
    created_at timestamptz,
    updated_at timestamptz,
    abstract_count bigint,
    earliest_date_filed date,
    latest_date_filed date,
    total_consideration bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dab.id,
        dab.book_title,
        dab.printed_at,
        dab.printed_by_employee_user_id,
        e.email as printed_by_employee_email,
        dab.saved_location,
        dab.notes,
        dab.created_at,
        dab.updated_at,
        COUNT(da.id) as abstract_count,
        MIN(da.date_filed) as earliest_date_filed,
        MAX(da.date_filed) as latest_date_filed,
        SUM(da.consideration_amount) as total_consideration
    FROM public.deed_abstract_books dab
    LEFT JOIN public.deed_abstracts da ON da.book_id = dab.id
    LEFT JOIN public.employees e ON e.user_id = dab.printed_by_employee_user_id
    GROUP BY dab.id, e.email
    ORDER BY dab.printed_at DESC;
END;
$$;

-- Remove abstracts from book
DROP FUNCTION IF EXISTS remove_abstracts_from_book(bigint[]);
CREATE OR REPLACE FUNCTION remove_abstracts_from_book(p_abstract_ids bigint[])
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    v_updated_count integer;
BEGIN
    UPDATE public.deed_abstracts
    SET book_id = NULL
    WHERE id = ANY(p_abstract_ids);
    
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
    RETURN v_updated_count;
END;
$$;

-- ============================================================
-- DEVNET REVIEW STATUSES
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_statuses CASCADE;
CREATE TABLE public.devnet_review_statuses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_kind public.devnet_review_kind NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    description text NULL,
    is_terminal boolean NOT NULL DEFAULT false,
    needs_approval boolean NOT NULL DEFAULT false,
    
    -- Assignment configuration
    requires_assignment boolean NOT NULL DEFAULT false,
    preferred_role text NULL, -- 'appraiser', 'supervisor', etc.
    required_specialties text[] DEFAULT '{}', -- Required employee specialties
    
    sort_order integer NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (review_kind, slug)
);

-- Insert enhanced review statuses with assignment requirements
INSERT INTO public.devnet_review_statuses (review_kind, slug, name, is_terminal, needs_approval, requires_assignment, preferred_role, required_specialties, sort_order) VALUES
-- Sale review statuses with specific assignment requirements
('sale_review', 'pending', 'Pending Review', false, false, false, NULL, '{}', 1),
('sale_review', 'field-assigned', 'Field Work Assigned', false, false, true, 'appraiser', '{field_work}', 2),
('sale_review', 'in-field', 'Field Work In Progress', false, false, false, NULL, '{}', 3),
('sale_review', 'data-collected', 'Data Collected', false, false, false, NULL, '{}', 4),
('sale_review', 'entry-assigned', 'Data Entry Assigned', false, false, true, 'supervisor', '{data_entry}', 5),
('sale_review', 'data-entered', 'Data Entered', false, false, false, NULL, '{}', 6),
('sale_review', 'needs-approval', 'Needs Approval', false, true, true, 'supervisor', '{approval}', 7),
('sale_review', 'approved-for-copy', 'Approved for Devnet Copy', false, false, false, NULL, '{}', 8),
('sale_review', 'copied-to-devnet', 'Copied to Devnet', false, false, false, NULL, '{}', 9),
('sale_review', 'completed', 'Completed', true, false, false, NULL, '{}', 10),
('sale_review', 'rejected', 'Rejected', true, false, false, NULL, '{}', 11),

-- Permit review statuses
('permit_review', 'pending', 'Pending Review', false, false, false, NULL, '{}', 1),
('permit_review', 'investigating', 'Investigating', false, false, true, 'appraiser', '{field_work}', 2),
('permit_review', 'needs-approval', 'Needs Approval', false, true, true, 'supervisor', '{approval}', 3),
('permit_review', 'approved', 'Approved', true, false, false, NULL, '{}', 4),
('permit_review', 'denied', 'Denied', true, false, false, NULL, '{}', 5),

-- Appeal review statuses
('appeal_review', 'filed', 'Filed', false, false, false, NULL, '{}', 1),
('appeal_review', 'under-review', 'Under Review', false, false, true, 'appraiser', '{review}', 2),
('appeal_review', 'needs-decision', 'Needs Decision', false, true, true, 'supervisor', '{approval}', 3),
('appeal_review', 'upheld', 'Upheld', true, false, false, NULL, '{}', 4),
('appeal_review', 'overturned', 'Overturned', true, false, false, NULL, '{}', 5),
('appeal_review', 'withdrawn', 'Withdrawn', true, false, false, NULL, '{}', 6),

-- Custom review statuses
('custom_review', 'open', 'Open', false, false, false, NULL, '{}', 1),
('custom_review', 'assigned', 'Assigned', false, false, true, NULL, '{}', 2),
('custom_review', 'in-progress', 'In Progress', false, false, false, NULL, '{}', 3),
('custom_review', 'needs-review', 'Needs Review', false, true, true, 'supervisor', '{approval}', 4),
('custom_review', 'completed', 'Completed', true, false, false, NULL, '{}', 5),
('custom_review', 'cancelled', 'Cancelled', true, false, false, NULL, '{}', 6)
ON CONFLICT (review_kind, slug) DO NOTHING;

-- ============================================================
-- DEVNET REVIEWS (Central workflow)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_reviews CASCADE;
CREATE TABLE public.devnet_reviews (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kind public.devnet_review_kind NOT NULL,
    current_status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    
    -- Current assignment (for backward compatibility and quick access)
    assigned_to_id bigint NULL REFERENCES public.devnet_employees (id),
    due_date date NULL,
    
    -- Entity references (flexible - reference different devnet tables)
    entity_type text NULL, -- 'devnet_parcel', 'devnet_sale', etc.
    entity_id bigint NULL,
    
    -- Data collection and copy tracking
    data_status public.devnet_data_status DEFAULT 'not_collected',
    data_collected_at timestamptz NULL,
    data_collected_by_id bigint NULL REFERENCES public.devnet_employees (id),
    copied_to_devnet_at timestamptz NULL,
    copied_to_devnet_by_id bigint NULL REFERENCES public.devnet_employees (id),
    devnet_copy_confirmed boolean DEFAULT false,
    
    -- Data requirements and validation
    requires_field_review boolean DEFAULT false,
    required_data_fields jsonb DEFAULT '{}',
    data_validation_rules jsonb DEFAULT '{}',
    completion_criteria jsonb DEFAULT '{}',
    
    -- Additional context and data
    title text NULL,
    description text NULL,
    priority text DEFAULT 'medium', -- 'low', 'medium', 'high', 'urgent'
    data jsonb NOT NULL DEFAULT '{}', -- Flexible storage for review-specific data
    
    -- Field data collection
    field_data jsonb NULL, -- Data collected in the field
    field_notes text NULL,
    
    -- Workflow tracking
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    completed_at timestamptz NULL
);

CREATE INDEX devnet_reviews_kind_idx ON public.devnet_reviews (kind, created_at DESC);
CREATE INDEX devnet_reviews_status_idx ON public.devnet_reviews (current_status_id);
CREATE INDEX devnet_reviews_assigned_idx ON public.devnet_reviews (assigned_to_id);
CREATE INDEX devnet_reviews_entity_idx ON public.devnet_reviews (entity_type, entity_id);
CREATE INDEX devnet_reviews_priority_idx ON public.devnet_reviews (priority);
CREATE INDEX devnet_reviews_due_date_idx ON public.devnet_reviews (due_date);
CREATE INDEX devnet_reviews_data_status_idx ON public.devnet_reviews (data_status);
CREATE INDEX devnet_reviews_field_required_idx ON public.devnet_reviews (requires_field_review);
CREATE INDEX devnet_reviews_data_gin_idx ON public.devnet_reviews USING gin (data);
CREATE INDEX devnet_reviews_field_data_gin_idx ON public.devnet_reviews USING gin (field_data);
CREATE INDEX devnet_reviews_required_data_gin_idx ON public.devnet_reviews USING gin (required_data_fields);

-- ============================================================
-- STATUS-SPECIFIC ASSIGNMENTS
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_assignments CASCADE;
CREATE TABLE public.devnet_review_assignments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.devnet_reviews (id) ON DELETE CASCADE,
    status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    employee_id bigint NOT NULL REFERENCES public.devnet_employees (id),
    
    -- Assignment details
    assigned_by_id bigint NULL REFERENCES public.devnet_employees (id),
    assigned_at timestamptz NOT NULL DEFAULT now(),
    due_date date NULL,
    notes text NULL,
    
    -- Completion tracking
    completed_at timestamptz NULL,
    completed_by_id bigint NULL REFERENCES public.devnet_employees (id),
    completion_notes text NULL,
    
    -- Status
    is_active boolean DEFAULT true,
    
    UNIQUE (review_id, status_id, employee_id)
);

CREATE INDEX devnet_review_assignments_review_idx ON public.devnet_review_assignments (review_id);
CREATE INDEX devnet_review_assignments_status_idx ON public.devnet_review_assignments (status_id);
CREATE INDEX devnet_review_assignments_employee_idx ON public.devnet_review_assignments (employee_id);
CREATE INDEX devnet_review_assignments_active_idx ON public.devnet_review_assignments (is_active) WHERE is_active = true;
CREATE INDEX devnet_review_assignments_due_date_idx ON public.devnet_review_assignments (due_date);

-- ============================================================
-- DEVNET REVIEW HISTORY (Status and Assignment Changes)
-- ============================================================

DROP TABLE IF EXISTS public.devnet_review_history CASCADE;
CREATE TABLE public.devnet_review_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.devnet_reviews (id) ON DELETE CASCADE,
    
    -- Status change tracking
    from_status_id bigint NULL REFERENCES public.devnet_review_statuses (id),
    to_status_id bigint NOT NULL REFERENCES public.devnet_review_statuses (id),
    
    -- Assignment change tracking
    from_employee_id bigint NULL REFERENCES public.devnet_employees (id),
    to_employee_id bigint NULL REFERENCES public.devnet_employees (id),
    
    -- Data status changes
    from_data_status public.devnet_data_status NULL,
    to_data_status public.devnet_data_status NULL,
    
    -- Change details
    changed_by_id bigint NULL REFERENCES public.devnet_employees (id),
    notes text NULL,
    change_reason text NULL,
    
    changed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX devnet_review_history_review_idx ON public.devnet_review_history (review_id, changed_at DESC);
CREATE INDEX devnet_review_history_changed_by_idx ON public.devnet_review_history (changed_by_id);

-- ============================================================
-- DEVNET AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-log review changes
DROP FUNCTION IF EXISTS log_devnet_review_changes();
CREATE OR REPLACE FUNCTION log_devnet_review_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Log status changes
    IF OLD.current_status_id IS DISTINCT FROM NEW.current_status_id THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_status_id,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.current_status_id,
            NEW.current_status_id,
            'Status changed via trigger'
        );
    END IF;
    
    -- Log assignment changes
    IF OLD.assigned_to_id IS DISTINCT FROM NEW.assigned_to_id THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_employee_id,
            to_employee_id,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.assigned_to_id,
            NEW.assigned_to_id,
            NEW.current_status_id,
            'Assignment changed via trigger'
        );
    END IF;
    
    -- Log data status changes
    IF OLD.data_status IS DISTINCT FROM NEW.data_status THEN
        INSERT INTO public.devnet_review_history (
            review_id,
            from_data_status,
            to_data_status,
            to_status_id,
            notes
        ) VALUES (
            NEW.id,
            OLD.data_status,
            NEW.data_status,
            NEW.current_status_id,
            'Data status changed via trigger'
        );
    END IF;
    
    -- Update timestamp
    NEW.updated_at = now();
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS devnet_review_changes_trigger ON public.devnet_reviews;
CREATE TRIGGER devnet_review_changes_trigger
    BEFORE UPDATE ON public.devnet_reviews
    FOR EACH ROW 
    EXECUTE FUNCTION log_devnet_review_changes();

-- ============================================================
-- DEVNET WORKFLOW FUNCTIONS
-- ============================================================

-- Create a review for a devnet entity
DROP FUNCTION IF EXISTS create_devnet_review(public.devnet_review_kind, text, bigint, text, text, bigint, jsonb);
CREATE OR REPLACE FUNCTION create_devnet_review(
    p_kind public.devnet_review_kind,
    p_entity_type text,
    p_entity_id bigint,
    p_title text DEFAULT NULL,
    p_description text DEFAULT NULL,
    p_assigned_to_employee_id bigint DEFAULT NULL,
    p_data jsonb DEFAULT '{}'::jsonb
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_default_status_id bigint;
BEGIN
    -- Get default status for this review kind (lowest sort_order)
    SELECT id INTO v_default_status_id
    FROM public.devnet_review_statuses 
    WHERE review_kind = p_kind 
    ORDER BY sort_order ASC 
    LIMIT 1;
    
    IF v_default_status_id IS NULL THEN
        RAISE EXCEPTION 'No default status found for review kind: %', p_kind;
    END IF;
    
    -- Create the review
    INSERT INTO public.devnet_reviews (
        kind,
        current_status_id,
        entity_type,
        entity_id,
        title,
        description,
        assigned_to_id,
        data
    ) VALUES (
        p_kind,
        v_default_status_id,
        p_entity_type,
        p_entity_id,
        p_title,
        p_description,
        p_assigned_to_employee_id,
        p_data
    ) RETURNING id INTO v_review_id;
    
    -- Log initial creation
    INSERT INTO public.devnet_review_history (
        review_id,
        to_status_id,
        to_employee_id,
        notes
    ) VALUES (
        v_review_id,
        v_default_status_id,
        p_assigned_to_employee_id,
        'Review created'
    );
    
    RETURN v_review_id;
END;
$$;

-- Transition review status
DROP FUNCTION IF EXISTS transition_devnet_review_status(bigint, text, bigint, text);
CREATE OR REPLACE FUNCTION transition_devnet_review_status(
    p_review_id bigint,
    p_new_status_slug text,
    p_changed_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_kind public.devnet_review_kind;
    v_old_status_id bigint;
    v_new_status_id bigint;
    v_is_terminal boolean;
BEGIN
    -- Get current review details
    SELECT kind, current_status_id INTO v_review_kind, v_old_status_id
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review not found: %', p_review_id;
    END IF;
    
    -- Get new status
    SELECT id, is_terminal INTO v_new_status_id, v_is_terminal
    FROM public.devnet_review_statuses 
    WHERE review_kind = v_review_kind AND slug = p_new_status_slug;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid status % for review kind %', p_new_status_slug, v_review_kind;
    END IF;
    
    -- Update review
    UPDATE public.devnet_reviews 
    SET 
        current_status_id = v_new_status_id,
        completed_at = CASE WHEN v_is_terminal THEN now() ELSE completed_at END
    WHERE id = p_review_id;
    
    -- Log the change
    INSERT INTO public.devnet_review_history (
        review_id,
        from_status_id,
        to_status_id,
        changed_by_id,
        notes,
        change_reason
    ) VALUES (
        p_review_id,
        v_old_status_id,
        v_new_status_id,
        p_changed_by_employee_id,
        p_notes,
        'Manual status transition'
    );
    
    RETURN true;
END;
$$;

-- Assign review to employee
DROP FUNCTION IF EXISTS assign_devnet_review(bigint, bigint, bigint, text);
CREATE OR REPLACE FUNCTION assign_devnet_review(
    p_review_id bigint,
    p_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_old_employee_id bigint;
    v_current_status_id bigint;
BEGIN
    -- Get current assignment
    SELECT assigned_to_id, current_status_id INTO v_old_employee_id, v_current_status_id
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review not found: %', p_review_id;
    END IF;
    
    -- Update assignment
    UPDATE public.devnet_reviews 
    SET assigned_to_id = p_employee_id
    WHERE id = p_review_id;
    
    -- Log the assignment change
    INSERT INTO public.devnet_review_history (
        review_id,
        from_employee_id,
        to_employee_id,
        to_status_id,
        changed_by_id,
        notes,
        change_reason
    ) VALUES (
        p_review_id,
        v_old_employee_id,
        p_employee_id,
        v_current_status_id,
        p_assigned_by_employee_id,
        p_notes,
        'Manual assignment'
    );
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET MASS OPERATIONS FUNCTIONS
-- ============================================================

-- Mass create reviews with data requirements
DROP FUNCTION IF EXISTS mass_create_devnet_reviews(jsonb);
CREATE OR REPLACE FUNCTION mass_create_devnet_reviews(
    p_review_configs jsonb -- Array of review configurations
)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    review_config jsonb;
    review_id bigint;
    review_ids bigint[] := '{}';
    default_status_id bigint;
BEGIN
    FOR review_config IN SELECT jsonb_array_elements(p_review_configs)
    LOOP
        -- Get default status for review kind
        SELECT id INTO default_status_id
        FROM public.devnet_review_statuses 
        WHERE review_kind = (review_config->>'kind')::devnet_review_kind
        ORDER BY sort_order ASC 
        LIMIT 1;
        
        -- Create review
        INSERT INTO public.devnet_reviews (
            kind,
            current_status_id,
            entity_type,
            entity_id,
            title,
            description,
            priority,
            requires_field_review,
            required_data_fields,
            data_validation_rules,
            completion_criteria,
            data,
            due_date
        ) VALUES (
            (review_config->>'kind')::devnet_review_kind,
            default_status_id,
            review_config->>'entity_type',
            (review_config->>'entity_id')::bigint,
            review_config->>'title',
            review_config->>'description',
            COALESCE(review_config->>'priority', 'medium'),
            COALESCE((review_config->>'requires_field_review')::boolean, false),
            COALESCE(review_config->'required_data_fields', '{}'::jsonb),
            COALESCE(review_config->'data_validation_rules', '{}'::jsonb),
            COALESCE(review_config->'completion_criteria', '{}'::jsonb),
            COALESCE(review_config->'data', '{}'::jsonb),
            COALESCE((review_config->>'due_date')::date, NULL)
        ) RETURNING id INTO review_id;
        
        review_ids := review_ids || review_id;
        
        -- Auto-assign if specified
        IF review_config ? 'assigned_to_id' THEN
            PERFORM assign_devnet_review(
                review_id,
                (review_config->>'assigned_to_id')::bigint,
                NULL,
                'Auto-assigned during mass creation'
            );
        END IF;
    END LOOP;
    
    RETURN review_ids;
END;
$$;

-- Mass update review status
DROP FUNCTION IF EXISTS mass_update_devnet_review_status(bigint[], text, bigint, text);
CREATE OR REPLACE FUNCTION mass_update_devnet_review_status(
    p_review_ids bigint[],
    p_new_status_slug text,
    p_changed_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    success_count integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        BEGIN
            PERFORM transition_devnet_review_status(
                review_id,
                p_new_status_slug,
                p_changed_by_employee_id,
                p_notes
            );
            success_count := success_count + 1;
        EXCEPTION WHEN OTHERS THEN
            -- Log error but continue with other reviews
            INSERT INTO public.devnet_review_history (
                review_id,
                to_status_id,
                changed_by_id,
                notes,
                change_reason
            ) VALUES (
                review_id,
                (SELECT current_status_id FROM public.devnet_reviews WHERE id = review_id),
                p_changed_by_employee_id,
                'Failed to update: ' || SQLERRM,
                'Mass update error'
            );
        END;
    END LOOP;
    
    RETURN success_count = array_length(p_review_ids, 1);
END;
$$;

-- Mass assign reviews
DROP FUNCTION IF EXISTS mass_assign_devnet_reviews(bigint[], bigint, bigint, date);
CREATE OR REPLACE FUNCTION mass_assign_devnet_reviews(
    p_review_ids bigint[],
    p_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_current_status_id bigint;
BEGIN
    FOREACH v_review_id IN ARRAY p_review_ids
    LOOP
        -- Get current status
        SELECT devnet_reviews.current_status_id INTO v_current_status_id
        FROM public.devnet_reviews 
        WHERE id = v_review_id;
        
        -- Update assignment
        UPDATE public.devnet_reviews 
        SET 
            assigned_to_id = p_employee_id,
            due_date = COALESCE(p_due_date, due_date)
        WHERE id = v_review_id;
        
        -- Create status-specific assignment if status requires it
        INSERT INTO public.devnet_review_assignments (
            review_id,
            status_id,
            employee_id,
            assigned_by_id,
            due_date,
            notes
        ) VALUES (
            v_review_id,
            v_current_status_id,
            p_employee_id,
            p_assigned_by_employee_id,
            p_due_date,
            'Mass assignment'
        ) ON CONFLICT (review_id, status_id, employee_id) 
        DO UPDATE SET
            assigned_by_id = EXCLUDED.assigned_by_id,
            due_date = COALESCE(EXCLUDED.due_date, p_due_date),
            assigned_at = now(),
            is_active = true;
    END LOOP;
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET DATA REQUIREMENTS AND VALIDATION FUNCTIONS
-- ============================================================

-- Set data requirements for reviews
DROP FUNCTION IF EXISTS set_review_data_requirements(bigint, jsonb, jsonb, jsonb);
CREATE OR REPLACE FUNCTION set_review_data_requirements(
    p_review_id bigint,
    p_required_fields jsonb,
    p_validation_rules jsonb DEFAULT '{}',
    p_completion_criteria jsonb DEFAULT '{}'
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews 
    SET 
        required_data_fields = p_required_fields,
        data_validation_rules = p_validation_rules,
        completion_criteria = p_completion_criteria,
        updated_at = now()
    WHERE id = p_review_id;
    
    RETURN FOUND;
END;
$$;

-- Check if review has required data
DROP FUNCTION IF EXISTS check_review_data_completeness(bigint);
CREATE OR REPLACE FUNCTION check_review_data_completeness(
    p_review_id bigint
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    review_record record;
    required_field text;
    missing_fields text[] := '{}';
    validation_errors text[] := '{}';
    result jsonb;
BEGIN
    -- Get review data
    SELECT 
        required_data_fields,
        field_data,
        data,
        data_validation_rules
    INTO review_record
    FROM public.devnet_reviews 
    WHERE id = p_review_id;
    
    -- Check required fields
    FOR required_field IN 
        SELECT jsonb_array_elements_text(review_record.required_data_fields->'fields')
    LOOP
        IF NOT (
            (review_record.field_data ? required_field AND review_record.field_data->>required_field IS NOT NULL) OR
            (review_record.data ? required_field AND review_record.data->>required_field IS NOT NULL)
        ) THEN
            missing_fields := missing_fields || required_field;
        END IF;
    END LOOP;
    
    -- Build result
    result := jsonb_build_object(
        'is_complete', array_length(missing_fields, 1) IS NULL,
        'missing_fields', to_jsonb(missing_fields),
        'validation_errors', to_jsonb(validation_errors),
        'checked_at', now()
    );
    
    RETURN result;
END;
$$;

-- Auto-assign based on field requirements
DROP FUNCTION IF EXISTS auto_assign_field_reviews();
CREATE OR REPLACE FUNCTION auto_assign_field_reviews()
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_record record;
    eligible_employee_id bigint;
    assignments_made integer := 0;
BEGIN
    -- Find reviews that need field assignment
    FOR review_record IN 
        SELECT 
            r.id,
            r.entity_type,
            r.entity_id,
            rs.preferred_role,
            rs.required_specialties
        FROM public.devnet_reviews r
        JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
        WHERE r.requires_field_review = true
        AND r.assigned_to_id IS NULL
        AND rs.requires_assignment = true
        AND rs.preferred_role = 'appraiser'
    LOOP
        -- Find eligible employee
        SELECT e.id INTO eligible_employee_id
        FROM public.devnet_employees e
        WHERE e.status = 'active'
        AND e.role = review_record.preferred_role
        AND (
            review_record.required_specialties = '{}' OR
            review_record.required_specialties <@ e.specialties
        )
        ORDER BY 
            -- Prefer employees with fewer active assignments
            (SELECT COUNT(*) FROM public.devnet_reviews WHERE assigned_to_id = e.id AND completed_at IS NULL)
        LIMIT 1;
        
        IF eligible_employee_id IS NOT NULL THEN
            PERFORM assign_devnet_review(
                review_record.id,
                eligible_employee_id,
                NULL,
                'Auto-assigned for field review'
            );
            assignments_made := assignments_made + 1;
        END IF;
    END LOOP;
    
    RETURN assignments_made;
END;
$$;

-- Mark data collection complete
DROP FUNCTION IF EXISTS mark_data_collected(bigint, jsonb, bigint, text);
CREATE OR REPLACE FUNCTION mark_data_collected(
    p_review_id bigint,
    p_field_data jsonb,
    p_collected_by_employee_id bigint,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews
    SET 
        data_status = 'collected',
        field_data = p_field_data,
        field_notes = p_notes,
        data_collected_at = now(),
        data_collected_by_id = p_collected_by_employee_id,
        updated_at = now()
    WHERE id = p_review_id;
    
    -- Auto-transition to data-collected status if available
    IF EXISTS (
        SELECT 1 FROM public.devnet_review_statuses rs
        JOIN public.devnet_reviews r ON r.kind = rs.review_kind
        WHERE r.id = p_review_id AND rs.slug = 'data-collected'
    ) THEN
        PERFORM transition_devnet_review_status(
            p_review_id,
            'data-collected',
            p_collected_by_employee_id,
            'Data collection completed: ' || COALESCE(p_notes, '')
        );
    END IF;
    
    RETURN true;
END;
$$;

-- Mark copied to devnet
DROP FUNCTION IF EXISTS mark_copied_to_devnet(bigint, bigint, text);
CREATE OR REPLACE FUNCTION mark_copied_to_devnet(
    p_review_id bigint,
    p_copied_by_employee_id bigint,
    p_notes text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.devnet_reviews
    SET 
        copied_to_devnet_at = now(),
        copied_to_devnet_by_id = p_copied_by_employee_id,
        devnet_copy_confirmed = true,
        updated_at = now()
    WHERE id = p_review_id;
    
    -- Auto-transition to copied-to-devnet status if available
    IF EXISTS (
        SELECT 1 FROM public.devnet_review_statuses rs
        JOIN public.devnet_reviews r ON r.kind = rs.review_kind
        WHERE r.id = p_review_id AND rs.slug = 'copied-to-devnet'
    ) THEN
        PERFORM transition_devnet_review_status(
            p_review_id,
            'copied-to-devnet',
            p_copied_by_employee_id,
            'Copied to Devnet: ' || COALESCE(p_notes, '')
        );
    END IF;
    
    RETURN true;
END;
$$;

-- ============================================================
-- DEVNET SEARCH AND FILTER FUNCTIONS
-- ============================================================

-- Comprehensive search function for devnet reviews
DROP FUNCTION IF EXISTS search_devnet_reviews(text, text, bigint, text, text, text, boolean, text, boolean, date, date, date, date, boolean, boolean);
CREATE OR REPLACE FUNCTION search_devnet_reviews(
    p_kind text DEFAULT NULL,
    p_devnet_review_statuses_ids text DEFAULT NULL,
    p_assigned_to_devnet_employees_id bigint DEFAULT NULL,
    p_data_status text DEFAULT NULL,
    p_priority text DEFAULT NULL,
    p_entity_type text DEFAULT NULL,
    p_requires_field_review boolean DEFAULT NULL,
    p_search_text text DEFAULT NULL,
    p_overdue_only boolean DEFAULT false,
    p_created_after date DEFAULT NULL,
    p_created_before date DEFAULT NULL,
    p_due_after date DEFAULT NULL,
    p_due_before date DEFAULT NULL,
    p_completed_only boolean DEFAULT false,
    p_active_only boolean DEFAULT false
)
RETURNS TABLE (
    id bigint,
    kind text,
    title text,
    description text,
    priority text,
    status_name text,
    status_slug text,
    assigned_to_name text,
    assigned_to_email text,
    assigned_to_role text,
    entity_type text,
    entity_id bigint,
    parcel_number text,
    parcel_address text,
    neighborhood_name text,
    sale_price numeric,
    sale_date date,
    requires_field_review boolean,
    data_status text,
    due_date date,
    days_until_due integer,
    created_at timestamptz,
    updated_at timestamptz,
    completed_at timestamptz,
    -- Associated parcel data
    parcel_data jsonb,
    -- Associated sales data  
    sales_data jsonb,
    -- Associated sale-parcel relationships
    sale_parcels_data jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
    status_ids_array bigint[];
BEGIN
    -- Convert comma-separated status IDs to array
    IF p_devnet_review_statuses_ids IS NOT NULL AND p_devnet_review_statuses_ids != '' THEN
        SELECT ARRAY(
            SELECT trim(unnest(string_to_array(p_devnet_review_statuses_ids, ',')))::bigint
        ) INTO status_ids_array;
    END IF;

    RETURN QUERY
    SELECT 
        r.id,
        r.kind::text,
        r.title,
        r.description,
        r.priority,
        rs.name as status_name,
        rs.slug as status_slug,
        COALESCE(e.first_name || ' ' || e.last_name, '') as assigned_to_name,
        e.email as assigned_to_email,
        e.role as assigned_to_role,
        r.entity_type,
        r.entity_id,
        COALESCE(dp.parcel_number, '') as parcel_number,
        COALESCE(dp.data->>'address', '') as parcel_address,
        COALESCE(dnr.neighborhood_name, '') as neighborhood_name,
        ds.sale_price,
        ds.sale_date,
        r.requires_field_review,
        r.data_status::text,
        r.due_date,
        CASE WHEN r.due_date IS NOT NULL 
             THEN r.due_date - CURRENT_DATE 
             ELSE NULL END as days_until_due,
        r.created_at,
        r.updated_at,
        r.completed_at,
        -- Get all parcels related to this review
        CASE 
            WHEN r.entity_type = 'devnet_parcels' THEN 
                jsonb_build_object(
                    'id', dp.id,
                    'parcel_number', dp.parcel_number,
                    'start_year', dp.start_year,
                    'end_year', dp.end_year,
                    'data', dp.data,
                    'devnet_id', dp.devnet_id,
                    'sync_date', dp.sync_date
                )
            WHEN r.entity_type = 'devnet_sales' THEN (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', related_parcels.id,
                        'parcel_number', related_parcels.parcel_number,
                        'start_year', related_parcels.start_year,
                        'end_year', related_parcels.end_year,
                        'data', related_parcels.data,
                        'devnet_id', related_parcels.devnet_id,
                        'sync_date', related_parcels.sync_date
                    )
                )
                FROM public.devnet_parcels related_parcels
                INNER JOIN public.devnet_sale_parcels dsp ON related_parcels.id = dsp.parcel_id
                WHERE dsp.sale_id = r.entity_id
            )
            ELSE NULL
        END as parcel_data,
        -- Get all sales related to this review
        CASE 
            WHEN r.entity_type = 'devnet_sales' THEN 
                jsonb_build_object(
                    'id', ds.id,
                    'sale_price', ds.sale_price,
                    'sale_date', ds.sale_date,
                    'sale_type', ds.sale_type,
                    'sale_status', ds.sale_status,
                    'data', ds.data,
                    'devnet_id', ds.devnet_id,
                    'sync_date', ds.sync_date
                )
            WHEN r.entity_type = 'devnet_parcels' THEN (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', related_sales.id,
                        'sale_price', related_sales.sale_price,
                        'sale_date', related_sales.sale_date,
                        'sale_type', related_sales.sale_type,
                        'sale_status', related_sales.sale_status,
                        'data', related_sales.data,
                        'devnet_id', related_sales.devnet_id,
                        'sync_date', related_sales.sync_date
                    )
                )
                FROM public.devnet_sales related_sales
                INNER JOIN public.devnet_sale_parcels dsp ON related_sales.id = dsp.sale_id
                WHERE dsp.parcel_id = r.entity_id
            )
            ELSE NULL
        END as sales_data,
        -- Get sale-parcel relationships
        CASE 
            WHEN r.entity_type IN ('devnet_sales', 'devnet_parcels') THEN (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', dsp.id,
                        'sale_id', dsp.sale_id,
                        'parcel_id', dsp.parcel_id,
                        'data', dsp.data,
                        'created_at', dsp.created_at
                    )
                )
                FROM public.devnet_sale_parcels dsp
                WHERE (r.entity_type = 'devnet_sales' AND dsp.sale_id = r.entity_id)
                   OR (r.entity_type = 'devnet_parcels' AND dsp.parcel_id = r.entity_id)
            )
            ELSE NULL
        END as sale_parcels_data
    FROM public.devnet_reviews r
    LEFT JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
    LEFT JOIN public.devnet_employees e ON r.assigned_to_id = e.id
    LEFT JOIN public.devnet_parcels dp ON r.entity_type = 'devnet_parcels' AND r.entity_id = dp.id
    LEFT JOIN public.devnet_sales ds ON r.entity_type = 'devnet_sales' AND r.entity_id = ds.id
    LEFT JOIN public.devnet_neighborhood_report dnr ON r.entity_type = 'neighborhood' AND r.entity_id = dnr.id
    WHERE 1=1
        -- Filter by kind
        AND (p_kind IS NULL OR r.kind::text = p_kind)
        -- Filter by status IDs
        AND (status_ids_array IS NULL OR r.current_status_id = ANY(status_ids_array))
        -- Filter by assigned employee
        AND (p_assigned_to_devnet_employees_id IS NULL OR r.assigned_to_id = p_assigned_to_devnet_employees_id)
        -- Filter by data status
        AND (p_data_status IS NULL OR r.data_status::text = p_data_status)
        -- Filter by priority
        AND (p_priority IS NULL OR r.priority = p_priority)
        -- Filter by entity type
        AND (p_entity_type IS NULL OR r.entity_type = p_entity_type)
        -- Filter by field review requirement
        AND (p_requires_field_review IS NULL OR r.requires_field_review = p_requires_field_review)
        -- Text search in title and description
        AND (p_search_text IS NULL OR 
             (r.title ILIKE '%' || p_search_text || '%' OR 
              r.description ILIKE '%' || p_search_text || '%' OR
              dp.parcel_number ILIKE '%' || p_search_text || '%' OR
              (dp.data->>'address') ILIKE '%' || p_search_text || '%'))
        -- Overdue filter
        AND (NOT p_overdue_only OR (r.due_date IS NOT NULL AND r.due_date < CURRENT_DATE))
        -- Date range filters
        AND (p_created_after IS NULL OR r.created_at::date >= p_created_after)
        AND (p_created_before IS NULL OR r.created_at::date <= p_created_before)
        AND (p_due_after IS NULL OR r.due_date >= p_due_after)
        AND (p_due_before IS NULL OR r.due_date <= p_due_before)
        -- Completion filters
        AND (NOT p_completed_only OR r.completed_at IS NOT NULL)
        AND (NOT p_active_only OR r.completed_at IS NULL)
    ORDER BY 
        CASE WHEN p_overdue_only THEN r.due_date END ASC,
        r.created_at DESC
    LIMIT 1000;
END;
$$;

-- Get review counts by status and kind
DROP FUNCTION IF EXISTS get_devnet_review_counts(jsonb);
CREATE OR REPLACE FUNCTION get_devnet_review_counts(
    p_filters jsonb DEFAULT '{}'::jsonb
)
RETURNS TABLE (
    kind text,
    status_name text,
    status_slug text,
    review_count bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.kind::text,
        rs.name as status_name,
        rs.slug as status_slug,
        COUNT(r.id) as review_count
    FROM public.devnet_reviews r
    LEFT JOIN public.devnet_review_statuses rs ON r.current_status_id = rs.id
    LEFT JOIN public.devnet_employees e ON r.assigned_to_id = e.id
    LEFT JOIN public.devnet_parcels p ON (r.entity_type = 'devnet_parcel' AND r.entity_id = p.id)
    LEFT JOIN public.devnet_sales s ON (r.entity_type = 'devnet_sale' AND r.entity_id = s.id)
    LEFT JOIN public.devnet_sale_parcels salep ON (r.entity_type = 'devnet_sale' AND s.id = salep.sale_id)
    LEFT JOIN public.devnet_parcels sp ON salep.parcel_id = sp.id
    WHERE 1=1
    -- Apply same filters as search function
    AND (NOT p_filters ? 'kind' OR r.kind::text = p_filters->>'kind')
    AND (NOT p_filters ? 'assigned_to_id' OR r.assigned_to_id = (p_filters->>'assigned_to_id')::bigint)
    AND (NOT p_filters ? 'priority' OR r.priority = p_filters->>'priority')
    AND (NOT p_filters ? 'neighborhood' OR 
         (COALESCE(p.data->>'neighborhood', p.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%' OR
          COALESCE(sp.data->>'neighborhood', sp.data->>'neighborhood_name', '') ILIKE '%' || (p_filters->>'neighborhood') || '%'))
    GROUP BY r.kind::text, rs.name, rs.slug, rs.sort_order
    ORDER BY r.kind::text, rs.sort_order;
END;
$$;

-- Get available filter options
DROP FUNCTION IF EXISTS get_devnet_filter_options();
CREATE OR REPLACE FUNCTION get_devnet_filter_options()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'kinds', (SELECT jsonb_agg(DISTINCT kind::text) FROM public.devnet_reviews),
        'statuses', (
            SELECT jsonb_agg(jsonb_build_object('slug', slug, 'name', name, 'kind', review_kind::text)) 
            FROM public.devnet_review_statuses ORDER BY review_kind, sort_order
        ),
        'priorities', jsonb_build_array('low', 'medium', 'high', 'urgent'),
        'data_statuses', jsonb_build_array('not_collected', 'in_field', 'collected', 'entered', 'copied_to_devnet', 'verified'),
        'employees', (
            SELECT jsonb_agg(jsonb_build_object(
                'id', id, 
                'name', first_name || ' ' || last_name, 
                'email', email, 
                'role', role
            ))
            FROM public.devnet_employees 
            WHERE status = 'active'
            ORDER BY first_name, last_name
        ),
        'neighborhoods', (
            SELECT jsonb_agg(DISTINCT neighborhood) 
            FROM (
                SELECT COALESCE(data->>'neighborhood', data->>'neighborhood_name', '') as neighborhood
                FROM public.devnet_parcels
                WHERE COALESCE(data->>'neighborhood', data->>'neighborhood_name', '') != ''
                UNION
                SELECT DISTINCT neighborhood_name as neighborhood
                FROM public.devnet_neighborhood_report
                WHERE neighborhood_name IS NOT NULL AND neighborhood_name != ''
            ) neighborhoods
            WHERE neighborhood != ''
        )
    ) INTO result;
    
    RETURN result;
END;
$$;

-- ============================================================
-- ENHANCED MASS ASSIGNMENT FUNCTIONS
-- ============================================================

-- Mass create assignments for specific statuses
DROP FUNCTION IF EXISTS mass_create_devnet_assignments(bigint[], bigint[], bigint, bigint, date, text);
CREATE OR REPLACE FUNCTION mass_create_devnet_assignments(
    p_review_ids bigint[],
    p_status_ids bigint[],
    p_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_id bigint;
    v_status_id bigint;
    assignments_created integer := 0;
BEGIN
    FOREACH v_review_id IN ARRAY p_review_ids
    LOOP
        FOREACH v_status_id IN ARRAY p_status_ids
        LOOP
            INSERT INTO public.devnet_review_assignments (
                review_id,
                status_id,
                employee_id,
                assigned_by_id,
                due_date,
                notes
            ) VALUES (
                v_review_id,
                v_status_id,
                p_employee_id,
                p_assigned_by_employee_id,
                p_due_date,
                p_notes
            ) ON CONFLICT (review_id, status_id, employee_id) 
            DO UPDATE SET
                assigned_by_id = EXCLUDED.assigned_by_id,
                due_date = COALESCE(EXCLUDED.due_date, p_due_date),
                assigned_at = now(),
                is_active = true;
            
            assignments_created := assignments_created + 1;
        END LOOP;
    END LOOP;
    
    RETURN assignments_created;
END;
$$;

-- Mass reassign reviews (update current assignment and create new status-specific assignments)
DROP FUNCTION IF EXISTS mass_reassign_devnet_reviews(bigint[], bigint, bigint, bigint, date, text);
CREATE OR REPLACE FUNCTION mass_reassign_devnet_reviews(
    p_review_ids bigint[],
    p_from_employee_id bigint,
    p_to_employee_id bigint,
    p_assigned_by_employee_id bigint DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_notes text DEFAULT 'Mass reassignment'
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    review_id bigint;
    current_status_id bigint;
    reassignments_made integer := 0;
BEGIN
    FOREACH review_id IN ARRAY p_review_ids
    LOOP
        -- Only reassign if currently assigned to the from_employee
        SELECT devnet_reviews.current_status_id INTO current_status_id
        FROM public.devnet_reviews 
        WHERE id = review_id 
        AND assigned_to_id = p_from_employee_id;
        
        IF FOUND THEN
            -- Update main assignment
            UPDATE public.devnet_reviews 
            SET 
                assigned_to_id = p_to_employee_id,
                due_date = COALESCE(p_due_date, due_date),
                updated_at = now()
            WHERE id = review_id;
            
            -- Deactivate old status-specific assignments for the from_employee
            UPDATE public.devnet_review_assignments
            SET is_active = false
            WHERE review_id = review_id 
            AND employee_id = p_from_employee_id
            AND is_active = true;
            
            -- Create new status-specific assignment
            INSERT INTO public.devnet_review_assignments (
                review_id,
                status_id,
                employee_id,
                assigned_by_id,
                due_date,
                notes
            ) VALUES (
                review_id,
                current_status_id,
                p_to_employee_id,
                p_assigned_by_employee_id,
                p_due_date,
                p_notes
            ) ON CONFLICT (review_id, status_id, employee_id) 
            DO UPDATE SET
                assigned_by_id = EXCLUDED.assigned_by_id,
                due_date = COALESCE(EXCLUDED.due_date, devnet_review_assignments.due_date),
                assigned_at = now(),
                is_active = true;
            
            reassignments_made := reassignments_made + 1;
        END IF;
    END LOOP;
    
    RETURN reassignments_made;
END;
$$;

-- Mass update assignment completion
DROP FUNCTION IF EXISTS mass_complete_devnet_assignments(bigint[], bigint, text);
CREATE OR REPLACE FUNCTION mass_complete_devnet_assignments(
    p_assignment_ids bigint[],
    p_completed_by_employee_id bigint,
    p_completion_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    assignment_id bigint;
    completions_made integer := 0;
BEGIN
    FOREACH assignment_id IN ARRAY p_assignment_ids
    LOOP
        UPDATE public.devnet_review_assignments
        SET 
            completed_at = now(),
            completed_by_id = p_completed_by_employee_id,
            completion_notes = p_completion_notes,
            is_active = false
        WHERE id = assignment_id
        AND completed_at IS NULL;
        
        IF FOUND THEN
            completions_made := completions_made + 1;
        END IF;
    END LOOP;
    
    RETURN completions_made;
END;
$$;

-- Mass update assignment due dates
DROP FUNCTION IF EXISTS mass_update_assignment_due_dates(bigint[], date, bigint, text);
CREATE OR REPLACE FUNCTION mass_update_assignment_due_dates(
    p_assignment_ids bigint[],
    p_new_due_date date,
    p_updated_by_employee_id bigint DEFAULT NULL,
    p_notes text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    assignment_id bigint;
    updates_made integer := 0;
BEGIN
    FOREACH assignment_id IN ARRAY p_assignment_ids
    LOOP
        UPDATE public.devnet_review_assignments
        SET 
            due_date = p_new_due_date,
            notes = COALESCE(p_notes, notes)
        WHERE id = assignment_id;
        
        IF FOUND THEN
            updates_made := updates_made + 1;
        END IF;
    END LOOP;
    
    RETURN updates_made;
END;
$$;

-- ============================================================
-- COMPREHENSIVE SEED DATA FOR TESTING
-- ============================================================

-- Generate comprehensive employee data (120 employees)
INSERT INTO public.devnet_employees (first_name, last_name, email, role, specialties, can_approve) 
SELECT 
    CASE (i % 20)
        WHEN 0 THEN 'John'
        WHEN 1 THEN 'Sarah' 
        WHEN 2 THEN 'Mike'
        WHEN 3 THEN 'Lisa'
        WHEN 4 THEN 'Tom'
        WHEN 5 THEN 'Amy'
        WHEN 6 THEN 'David'
        WHEN 7 THEN 'Emily'
        WHEN 8 THEN 'James'
        WHEN 9 THEN 'Jessica'
        WHEN 10 THEN 'Robert'
        WHEN 11 THEN 'Ashley'
        WHEN 12 THEN 'Michael'
        WHEN 13 THEN 'Amanda'
        WHEN 14 THEN 'William'
        WHEN 15 THEN 'Jennifer'
        WHEN 16 THEN 'Kevin'
        WHEN 17 THEN 'Stephanie'
        WHEN 18 THEN 'Brian'
        ELSE 'Michelle'
    END as first_name,
    CASE (i % 25)
        WHEN 0 THEN 'Smith'
        WHEN 1 THEN 'Johnson'
        WHEN 2 THEN 'Davis'
        WHEN 3 THEN 'Wilson'
        WHEN 4 THEN 'Brown'
        WHEN 5 THEN 'Miller'
        WHEN 6 THEN 'Moore'
        WHEN 7 THEN 'Taylor'
        WHEN 8 THEN 'Anderson'
        WHEN 9 THEN 'Thomas'
        WHEN 10 THEN 'Jackson'
        WHEN 11 THEN 'White'
        WHEN 12 THEN 'Harris'
        WHEN 13 THEN 'Martin'
        WHEN 14 THEN 'Thompson'
        WHEN 15 THEN 'Garcia'
        WHEN 16 THEN 'Martinez'
        WHEN 17 THEN 'Robinson'
        WHEN 18 THEN 'Clark'
        WHEN 19 THEN 'Rodriguez'
        WHEN 20 THEN 'Lewis'
        WHEN 21 THEN 'Lee'
        WHEN 22 THEN 'Walker'
        WHEN 23 THEN 'Hall'
        ELSE 'Allen'
    END as last_name,
    'employee' || i || '@example.com' as email,
    CASE (i % 4)
        WHEN 0 THEN 'appraiser'
        WHEN 1 THEN 'supervisor'
        WHEN 2 THEN 'data_entry'
        ELSE 'reviewer'
    END as role,
    CASE (i % 6)
        WHEN 0 THEN '{field_work, residential}'
        WHEN 1 THEN '{approval, data_entry}'
        WHEN 2 THEN '{field_work, commercial}'
        WHEN 3 THEN '{data_entry, residential}'
        WHEN 4 THEN '{approval, review}'
        ELSE '{field_work, commercial, residential}'
    END::text[] as specialties,
    CASE WHEN (i % 4) = 1 THEN true ELSE false END as can_approve
FROM generate_series(1, 120) as i
ON CONFLICT (email) DO NOTHING;

-- Generate comprehensive parcel data (150 parcels)
INSERT INTO public.devnet_parcels (parcel_number, start_year, end_year, data, devnet_id)
SELECT 
    lpad((100000 + i)::text, 3, '0') || '-' || 
    lpad(((i * 7) % 1000 + 100)::text, 3, '0') || '-' || 
    lpad(((i * 13) % 1000 + 100)::text, 3, '0') as parcel_number,
    2022 + (i % 3) as start_year,
    2023 + (i % 3) as end_year,
    jsonb_build_object(
        'owner', 'Owner ' || i,
        'address', (100 + (i * 3) % 900) || ' ' || 
                  CASE (i % 15)
                      WHEN 0 THEN 'Main St'
                      WHEN 1 THEN 'Oak Ave'
                      WHEN 2 THEN 'Pine Rd'
                      WHEN 3 THEN 'Elm St'
                      WHEN 4 THEN 'Maple Dr'
                      WHEN 5 THEN 'Cedar Ln'
                      WHEN 6 THEN 'First Ave'
                      WHEN 7 THEN 'Second St'
                      WHEN 8 THEN 'Third Ave'
                      WHEN 9 THEN 'Broadway'
                      WHEN 10 THEN 'Park Ave'
                      WHEN 11 THEN 'Central St'
                      WHEN 12 THEN 'North Rd'
                      WHEN 13 THEN 'South St'
                      ELSE 'East Ave'
                  END,
        'property_type', CASE (i % 4)
                           WHEN 0 THEN 'residential'
                           WHEN 1 THEN 'commercial'
                           WHEN 2 THEN 'industrial'
                           ELSE 'mixed_use'
                       END,
        'square_feet', 1000 + (i * 50) % 3000,
        'year_built', 1950 + (i * 3) % 70,
        'neighborhood', CASE (i % 8)
                          WHEN 0 THEN 'Downtown'
                          WHEN 1 THEN 'Midtown'
                          WHEN 2 THEN 'Uptown'
                          WHEN 3 THEN 'Eastside'
                          WHEN 4 THEN 'Westside'
                          WHEN 5 THEN 'Northside'
                          WHEN 6 THEN 'Southside'
                          ELSE 'Suburbs'
                      END
    ) as data,
    'DEV' || lpad(i::text, 4, '0') as devnet_id
FROM generate_series(1, 150) as i
ON CONFLICT DO NOTHING;

-- Generate comprehensive neighborhood reports (110 reports)
INSERT INTO public.devnet_neighborhood_report (neighborhood_name, start_year, end_year, data, devnet_id)
SELECT 
    CASE (i % 11)
        WHEN 0 THEN 'Downtown'
        WHEN 1 THEN 'Midtown'
        WHEN 2 THEN 'Uptown'
        WHEN 3 THEN 'Eastside'
        WHEN 4 THEN 'Westside'
        WHEN 5 THEN 'Northside'
        WHEN 6 THEN 'Southside'
        WHEN 7 THEN 'Suburbs'
        WHEN 8 THEN 'Historic District'
        WHEN 9 THEN 'Waterfront'
        ELSE 'Industrial Zone'
    END as neighborhood_name,
    2020 + (i % 5) as start_year,
    2021 + (i % 5) as end_year,
    jsonb_build_object(
        'median_home_value', 150000 + (i * 5000) % 300000,
        'population', 500 + (i * 100) % 5000,
        'crime_rate', 1.0 + (i * 0.1) % 5.0,
        'school_rating', 6 + (i % 5),
        'amenities', array[
            CASE WHEN (i % 4) = 0 THEN 'schools' END,
            CASE WHEN (i % 3) = 0 THEN 'parks' END,
            CASE WHEN (i % 5) = 0 THEN 'shopping' END,
            CASE WHEN (i % 7) = 0 THEN 'transit' END
        ]::text[],
        'market_trend', CASE (i % 3)
                          WHEN 0 THEN 'rising'
                          WHEN 1 THEN 'stable'
                          ELSE 'declining'
                      END
    ) as data,
    'NBH' || lpad(i::text, 4, '0') as devnet_id
FROM generate_series(1, 110) as i;

-- Generate comprehensive sales data (200 sales)
INSERT INTO public.devnet_sales (sale_price, sale_date, sale_type, sale_status, data, devnet_id)
SELECT 
    (100000 + (i * 7919) % 500000)::numeric(12,2) as sale_price,
    '2022-01-01'::date + (i * 5) % 1095 as sale_date,
    CASE (i % 5)
        WHEN 0 THEN 'arms_length'
        WHEN 1 THEN 'foreclosure'
        WHEN 2 THEN 'estate'
        WHEN 3 THEN 'family'
        ELSE 'auction'
    END as sale_type,
    CASE (i % 4)
        WHEN 0 THEN 'verified'
        WHEN 1 THEN 'pending'
        WHEN 2 THEN 'under_review'
        ELSE 'approved'
    END as sale_status,
    jsonb_build_object(
        'buyer', 'Buyer ' || i,
        'seller', 'Seller ' || i,
        'financing', CASE (i % 4)
                       WHEN 0 THEN 'cash'
                       WHEN 1 THEN 'conventional'
                       WHEN 2 THEN 'fha'
                       ELSE 'va'
                   END,
        'days_on_market', 5 + (i * 3) % 180,
        'listing_price', (110000 + (i * 7919) % 500000)::numeric(12,2),
        'agent_name', 'Agent ' || ((i % 50) + 1),
        'property_condition', CASE (i % 5)
                                WHEN 0 THEN 'excellent'
                                WHEN 1 THEN 'good'
                                WHEN 2 THEN 'average'
                                WHEN 3 THEN 'fair'
                                ELSE 'poor'
                            END
    ) as data,
    'SALE' || lpad(i::text, 5, '0') as devnet_id
FROM generate_series(1, 200) as i;

-- Generate sale-parcel relationships (300 relationships, some sales have multiple parcels)
INSERT INTO public.devnet_sale_parcels (sale_id, parcel_id, data)
SELECT 
    (i % 200) + 1 as sale_id,
    ((i * 7) % 150) + 1 as parcel_id,
    jsonb_build_object(
        'parcel_role', CASE (i % 3)
                         WHEN 0 THEN 'primary'
                         WHEN 1 THEN 'secondary'
                         ELSE 'additional'
                     END,
        'parcel_percentage', CASE 
                               WHEN (i % 3) = 0 THEN 100
                               WHEN (i % 3) = 1 THEN 60
                               ELSE 40
                           END
    ) as data
FROM generate_series(1, 300) as i
ON CONFLICT (sale_id, parcel_id) DO NOTHING;

-- Generate comprehensive reviews data (250 reviews)
INSERT INTO public.devnet_reviews (
    kind, 
    current_status_id, 
    assigned_to_id, 
    due_date, 
    entity_type, 
    entity_id, 
    data_status, 
    requires_field_review, 
    title, 
    description, 
    priority, 
    data,
    field_data,
    field_notes,
    created_at,
    updated_at
)
SELECT 
    CASE (i % 4)
        WHEN 0 THEN 'sale_review'::public.devnet_review_kind
        WHEN 1 THEN 'permit_review'::public.devnet_review_kind
        WHEN 2 THEN 'appeal_review'::public.devnet_review_kind
        ELSE 'custom_review'::public.devnet_review_kind
    END as kind,
    -- Get appropriate status for each kind
    (SELECT id FROM public.devnet_review_statuses rs 
     WHERE rs.review_kind = CASE (i % 4)
                              WHEN 0 THEN 'sale_review'::public.devnet_review_kind
                              WHEN 1 THEN 'permit_review'::public.devnet_review_kind
                              WHEN 2 THEN 'appeal_review'::public.devnet_review_kind
                              ELSE 'custom_review'::public.devnet_review_kind
                          END
     ORDER BY rs.sort_order + (i % 3) 
     LIMIT 1) as current_status_id,
    (i % 120) + 1 as assigned_to_id,
    CURRENT_DATE + (i % 30) as due_date,
    CASE (i % 4)
        WHEN 0 THEN 'devnet_sales'
        WHEN 1 THEN 'devnet_parcels'
        WHEN 2 THEN 'devnet_parcels'
        ELSE 'devnet_sales'
    END as entity_type,
    CASE (i % 4)
        WHEN 0 THEN (i % 200) + 1
        WHEN 1 THEN (i % 150) + 1
        WHEN 2 THEN (i % 150) + 1
        ELSE (i % 200) + 1
    END as entity_id,
    CASE (i % 6)
        WHEN 0 THEN 'not_collected'::public.devnet_data_status
        WHEN 1 THEN 'in_field'::public.devnet_data_status
        WHEN 2 THEN 'collected'::public.devnet_data_status
        WHEN 3 THEN 'entered'::public.devnet_data_status
        WHEN 4 THEN 'copied_to_devnet'::public.devnet_data_status
        ELSE 'verified'::public.devnet_data_status
    END as data_status,
    (i % 3) = 0 as requires_field_review,
    CASE (i % 4)
        WHEN 0 THEN 'Sale Review #' || i
        WHEN 1 THEN 'Permit Review #' || i
        WHEN 2 THEN 'Appeal Review #' || i
        ELSE 'Custom Review #' || i
    END as title,
    'Review description for item #' || i || '. ' ||
    CASE (i % 5)
        WHEN 0 THEN 'Requires urgent attention due to high priority.'
        WHEN 1 THEN 'Standard review process with normal timeline.'
        WHEN 2 THEN 'Complex case requiring additional documentation.'
        WHEN 3 THEN 'Follow-up review from previous inspection.'
        ELSE 'Routine review as part of regular workflow.'
    END as description,
    CASE (i % 4)
        WHEN 0 THEN 1
        WHEN 1 THEN 2
        WHEN 2 THEN 3
        ELSE 4
    END as priority,
    jsonb_build_object(
        'property_address', (100 + (i * 7) % 900) || ' Test St #' || i,
        'estimated_value', 150000 + (i * 1000) % 400000,
        'urgency_level', CASE (i % 3)
                           WHEN 0 THEN 'low'
                           WHEN 1 THEN 'medium'
                           ELSE 'high'
                       END,
        'review_type', CASE (i % 4)
                         WHEN 0 THEN 'initial'
                         WHEN 1 THEN 'follow_up'
                         WHEN 2 THEN 'appeal'
                         ELSE 'special'
                     END,
        'documents_required', array[
            CASE WHEN (i % 5) = 0 THEN 'deed' END,
            CASE WHEN (i % 4) = 0 THEN 'survey' END,
            CASE WHEN (i % 3) = 0 THEN 'photos' END,
            CASE WHEN (i % 7) = 0 THEN 'appraisal' END
        ]::text[]
    ) as data,
    CASE 
        WHEN (i % 6) >= 2 THEN 
            jsonb_build_object(
                'inspection_date', CURRENT_DATE - (i % 30),
                'inspector_notes', 'Field inspection completed for review #' || i,
                'photos_taken', 3 + (i % 8),
                'measurements', jsonb_build_object(
                    'length', 50 + (i * 3) % 100,
                    'width', 30 + (i * 2) % 60,
                    'height', 8 + (i % 4)
                ),
                'condition_rating', 1 + (i % 5)
            )
        ELSE NULL
    END as field_data,
    CASE 
        WHEN (i % 6) >= 2 THEN 'Field notes for review #' || i || '. Property inspected and documented.'
        ELSE NULL
    END as field_notes,
    CURRENT_TIMESTAMP - (i || ' days')::interval as created_at,
    CURRENT_TIMESTAMP - (GREATEST(0, i - 5) || ' days')::interval as updated_at
FROM generate_series(1, 250) as i;

-- Generate review assignments (400 assignments - multiple assignments per review for different statuses)
INSERT INTO public.devnet_review_assignments (
    review_id, 
    status_id, 
    employee_id, 
    assigned_by_id, 
    due_date, 
    notes,
    completed_at,
    completed_by_id,
    completion_notes,
    is_active
)
SELECT 
    (i % 250) + 1 as review_id,
    -- Get a random status for the review kind
    (SELECT rs.id FROM public.devnet_reviews r 
     JOIN public.devnet_review_statuses rs ON rs.review_kind = r.kind 
     WHERE r.id = (i % 250) + 1 
     ORDER BY rs.sort_order + (i % 3) 
     LIMIT 1) as status_id,
    ((i * 7) % 120) + 1 as employee_id,
    ((i * 11) % 120) + 1 as assigned_by_id,
    CURRENT_DATE + ((i * 3) % 45) as due_date,
    'Assignment #' || i || ' - ' ||
    CASE (i % 4)
        WHEN 0 THEN 'High priority assignment requiring immediate attention'
        WHEN 1 THEN 'Standard assignment with normal processing'
        WHEN 2 THEN 'Complex assignment requiring specialist knowledge'
        ELSE 'Follow-up assignment from previous work'
    END as notes,
    CASE 
        WHEN (i % 3) = 0 THEN CURRENT_TIMESTAMP - ((i % 10) || ' days')::interval
        ELSE NULL
    END as completed_at,
    CASE 
        WHEN (i % 3) = 0 THEN ((i * 7) % 120) + 1
        ELSE NULL
    END as completed_by_id,
    CASE 
        WHEN (i % 3) = 0 THEN 'Assignment completed successfully. All requirements met.'
        ELSE NULL
    END as completion_notes,
    (i % 3) != 0 as is_active
FROM generate_series(1, 400) as i
ON CONFLICT (review_id, status_id, employee_id) DO NOTHING;

-- ============================================================
-- EXAMPLE USAGE QUERIES
-- ============================================================

/*
-- Vehicle value search examples

-- Search for all Honda Civic values
SELECT * FROM search_vehicle_values(
    p_make := 'Honda',
    p_model := 'Civic'
);

-- Search for specific year and guide
SELECT * FROM search_vehicle_values(
    p_make := 'Toyota',
    p_model := 'Camry',
    p_model_year := 2020,
    p_guide_year := 2024
);

-- Search by trim
SELECT * FROM search_vehicle_values(
    p_make := 'Ford',
    p_model := 'F-150',
    p_trim := 'XLT'
);

-- Search all vehicles for a specific guide year
SELECT * FROM search_vehicle_values(
    p_guide_year := 2024
);

-- Vehicle filter options examples

-- Get all distinct vehicle types
SELECT * FROM get_distinct_vehicle_types();

-- Get all distinct vehicle makes
SELECT * FROM get_distinct_vehicle_makes();

-- Get distinct models for a specific make
SELECT * FROM get_distinct_models_by_make('Honda');

-- Get models for Toyota with counts
SELECT * FROM get_distinct_models_by_make('Toyota')
ORDER BY vehicle_count DESC;

-- Create a new sale review with data requirements
SELECT create_devnet_review(
    'sale_review',
    'devnet_sale',
    1,
    'Review Sale #1',
    'Verify sale price and conditions',
    1,
    '{"priority": "high"}'::jsonb
);

-- Set data requirements for a review
SELECT set_review_data_requirements(
    1,
    '{"fields": ["verified_price", "condition_rating", "market_analysis"]}'::jsonb,
    '{"verified_price": {"min": 0, "required": true}}'::jsonb,
    '{"completion_threshold": 0.95}'::jsonb
);

-- Mass create reviews
SELECT mass_create_devnet_reviews('[
    {
        "kind": "sale_review",
        "entity_type": "devnet_sale", 
        "entity_id": 1,
        "title": "Sale Review #1",
        "priority": "high",
        "requires_field_review": true,
        "required_data_fields": {"fields": ["verified_price", "condition"]},
        "due_date": "2024-02-01"
    },
    {
        "kind": "sale_review",
        "entity_type": "devnet_sale",
        "entity_id": 2, 
        "title": "Sale Review #2",
        "priority": "medium",
        "requires_field_review": false
    }
]'::jsonb);

-- Mass assign reviews to an employee
SELECT mass_assign_devnet_reviews(
    ARRAY[1, 2, 3, 4, 5],
    1
);
-- Search reviews with filters
SELECT * FROM search_devnet_reviews(
    p_kind := 'sale_review',
    p_priority := 'high',
    p_search_text := 'Downtown'
) LIMIT 25;

-- Search by assigned employee
SELECT * FROM search_devnet_reviews(
    p_assigned_to_employee_id := 1,
    p_search_text := 'in-field'
) LIMIT 50;

-- Search by address
SELECT * FROM search_devnet_reviews(
    p_search_text := 'Main St',
    p_requires_field_review := true
) LIMIT 100;

-- Search by parcel number
SELECT * FROM search_devnet_reviews(
    p_search_text := '123-456'
) LIMIT 25;

-- Search with date ranges
SELECT * FROM search_devnet_reviews(
    p_created_after := '2024-01-01',
    p_due_before := '2024-03-01',
    p_active_only := true
) LIMIT 50;

-- Search sale reviews (filters by kind)
SELECT * FROM search_devnet_reviews(
    p_kind := 'sale_review',
    p_entity_type := 'devnet_sales'
) LIMIT 25;

-- Get review counts by status
SELECT * FROM get_devnet_review_counts('{"kind": "sale_review"}'::jsonb);

-- Get all available filter options
SELECT get_devnet_filter_options();

-- Mass operations examples

-- Mass create assignments for multiple reviews and statuses
SELECT mass_create_devnet_assignments(
    ARRAY[1, 2, 3], -- review_ids
    ARRAY[2, 5], -- status_ids (field-assigned, entry-assigned)
    1, -- employee_id
    2, -- assigned_by_id
    '2024-02-01', -- due_date
    'Bulk assignment for priority reviews'
);

-- Mass reassign reviews from one employee to another
SELECT mass_reassign_devnet_reviews(
    ARRAY[1, 2, 3, 4], -- review_ids
    1, -- from_employee_id
    2, -- to_employee_id
    3, -- assigned_by_id
    '2024-02-15', -- new_due_date
    'Reassigned due to workload balancing'
);

-- Complete multiple assignments at once
SELECT mass_complete_devnet_assignments(
    ARRAY[10, 11, 12], -- assignment_ids
    1, -- completed_by_id
    'Completed field work for all assignments'
);

-- Update due dates for multiple assignments
SELECT mass_update_assignment_due_dates(
    ARRAY[5, 6, 7, 8], -- assignment_ids
    '2024-02-20', -- new_due_date
    2, -- updated_by_id
    'Extended due to complexity'
);

-- Complex search with custom sorting and limiting
SELECT 
    id,
    kind,
    title,
    status_name,
    assigned_to_name,
    neighborhood_name,
    parcel_address,
    priority,
    days_until_due,
    created_at
FROM search_devnet_reviews(
    p_search_text := 'Downtown',
    p_priority := 'high',
    p_active_only := true,
    p_requires_field_review := true
) 
ORDER BY days_until_due ASC NULLS LAST, created_at DESC
LIMIT 100;
*/