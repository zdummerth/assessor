-- ============================================================
-- SCHEMA-V2-ULTRA-SIMPLE.SQL: Simplified Parcel Data Tracking
-- ============================================================
-- Idempotent schema with _v2 suffix for all tables and functions
-- Focus: Track parcel data over time through reviews system

-- Drop and recreate enum types
DROP TYPE IF EXISTS public.review_kind_v2 CASCADE;
CREATE TYPE public.review_kind_v2 AS ENUM (
    'sale_review',
    'permit_review', 
    'appeal_review',
    'building_review',
    'land_review',
    'parcel_review'
);

-- ============================================================
-- EMPLOYEES
-- ============================================================

DROP TABLE IF EXISTS public.employees_v2 CASCADE;
CREATE TABLE public.employees_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid UNIQUE NULL, -- Links to Supabase auth
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text UNIQUE NULL,
    status text NOT NULL DEFAULT 'active',
    can_approve boolean NOT NULL DEFAULT false,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX employees_v2_user_id_idx ON public.employees_v2 (user_id);
CREATE INDEX employees_v2_status_idx ON public.employees_v2 (status);

-- ============================================================
-- LOOKUP TABLES
-- ============================================================

-- Neighborhoods lookup
DROP TABLE IF EXISTS public.neighborhoods_v2 CASCADE;
CREATE TABLE public.neighborhoods_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX neighborhoods_v2_name_idx ON public.neighborhoods_v2 (name);

-- Tax statuses lookup
DROP TABLE IF EXISTS public.tax_statuses_v2 CASCADE;
CREATE TABLE public.tax_statuses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NULL,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX tax_statuses_v2_name_idx ON public.tax_statuses_v2 (name);
CREATE INDEX tax_statuses_v2_active_idx ON public.tax_statuses_v2 (is_active);

-- Addresses lookup (for both site and owner addresses)
DROP TABLE IF EXISTS public.addresses_v2 CASCADE;
CREATE TABLE public.addresses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    street_address text NOT NULL,
    city text NULL,
    state text NULL,
    zip text NULL,
    latitude numeric NULL,
    longitude numeric NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX addresses_v2_street_idx ON public.addresses_v2 (street_address);
CREATE INDEX addresses_v2_city_idx ON public.addresses_v2 (city);
CREATE INDEX addresses_v2_location_idx ON public.addresses_v2 (latitude, longitude);
CREATE UNIQUE INDEX addresses_v2_full_address_idx ON public.addresses_v2 (street_address, city, state, zip);

-- ============================================================
-- REVIEW STATUSES
-- ============================================================

DROP TABLE IF EXISTS public.review_statuses_v2 CASCADE;
CREATE TABLE public.review_statuses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_kind public.review_kind_v2 NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    is_terminal boolean NOT NULL DEFAULT false,
    needs_approval boolean NOT NULL DEFAULT false,
    sort_order int NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (review_kind, slug)
);

-- ============================================================
-- REVIEWS (Central workflow)
-- ============================================================

DROP TABLE IF EXISTS public.reviews_v2 CASCADE;
CREATE TABLE public.reviews_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kind public.review_kind_v2 NOT NULL,
    title text NULL,
    due_date date NULL,
    current_status_id bigint REFERENCES public.review_statuses_v2 (id),
    assigned_to_id bigint REFERENCES public.employees_v2 (id),
    data jsonb NOT NULL DEFAULT '{}', -- All review-specific data
    created_at timestamptz NOT NULL DEFAULT now(),
    created_by uuid NOT NULL DEFAULT auth.uid(),
    completed_at timestamptz NULL
);

CREATE INDEX reviews_v2_kind_idx ON public.reviews_v2 (kind, created_at DESC);
CREATE INDEX reviews_v2_status_idx ON public.reviews_v2 (current_status_id);
CREATE INDEX reviews_v2_assigned_idx ON public.reviews_v2 (assigned_to_id);
CREATE INDEX reviews_v2_data_gin_idx ON public.reviews_v2 USING gin (data);

-- ============================================================
-- PARCELS (Core entity)
-- ============================================================

DROP TABLE IF EXISTS public.parcels_v2 CASCADE;
CREATE TABLE public.parcels_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- Basic parcel identifiers
    block integer NULL,
    lot integer NULL,
    ext integer NULL,
    parcel_number text NULL,
    
    -- Current data (updated through reviews)
    tax_status_id bigint REFERENCES public.tax_statuses_v2 (id),
    property_class text NULL,
    default_appraiser_id bigint REFERENCES public.employees_v2 (id),
    
    -- Owner information
    owner_name text NULL,
    owner_address_id bigint REFERENCES public.addresses_v2 (id),
    
    -- Site address (primary)
    site_address_id bigint REFERENCES public.addresses_v2 (id),
    
    -- Location
    neighborhood_id bigint REFERENCES public.neighborhoods_v2 (id),
    
    -- Flexible data storage
    parcel_data jsonb NOT NULL DEFAULT '{}',
    
    -- Tracking
    current_review_id bigint REFERENCES public.reviews_v2 (id),
    last_updated_at timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX parcels_v2_block_lot_ext_idx ON public.parcels_v2 (block, lot, ext);
CREATE INDEX parcels_v2_parcel_number_idx ON public.parcels_v2 (parcel_number);
CREATE INDEX parcels_v2_owner_idx ON public.parcels_v2 (owner_name);
CREATE INDEX parcels_v2_neighborhood_id_idx ON public.parcels_v2 (neighborhood_id);
CREATE INDEX parcels_v2_tax_status_id_idx ON public.parcels_v2 (tax_status_id);
CREATE INDEX parcels_v2_site_address_id_idx ON public.parcels_v2 (site_address_id);
CREATE INDEX parcels_v2_owner_address_id_idx ON public.parcels_v2 (owner_address_id);
CREATE INDEX parcels_v2_data_gin_idx ON public.parcels_v2 USING gin (parcel_data);

-- ============================================================
-- BUILDINGS (Parcel components)
-- ============================================================

DROP TABLE IF EXISTS public.buildings_v2 CASCADE;
CREATE TABLE public.buildings_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Basic building data
    year_built integer NULL,
    square_footage integer NULL,
    finished_area integer NULL,
    unfinished_area integer NULL,
    bedrooms integer NULL,
    bathrooms numeric(3,1) NULL,
    half_baths integer NULL,
    stories numeric(2,1) NULL,
    condition_rating integer NULL, -- 1-10 scale
    
    -- Building type and use
    building_type text NULL, -- 'single_family', 'multi_family', etc.
    occupancy_type text NULL,
    
    -- Construction details
    exterior_material text NULL,
    roof_type text NULL,
    foundation_type text NULL,
    heating_type text NULL,
    cooling_type text NULL,
    
    -- Additional features
    basement_area integer NULL,
    garage_area integer NULL,
    deck_area integer NULL,
    porch_area integer NULL,
    
    -- Flexible data for additional attributes
    building_data jsonb NOT NULL DEFAULT '{}',
    
    -- Tracking
    current_review_id bigint REFERENCES public.reviews_v2 (id),
    effective_date date NOT NULL DEFAULT current_date,
    created_at timestamptz NOT NULL DEFAULT now(),
    retired_at timestamptz NULL
);

CREATE INDEX buildings_v2_parcel_idx ON public.buildings_v2 (parcel_id);
CREATE INDEX buildings_v2_year_built_idx ON public.buildings_v2 (year_built);
CREATE INDEX buildings_v2_sqft_idx ON public.buildings_v2 (square_footage);
CREATE INDEX buildings_v2_data_gin_idx ON public.buildings_v2 USING gin (building_data);

-- ============================================================
-- LANDS (Parcel components)
-- ============================================================

DROP TABLE IF EXISTS public.lands_v2 CASCADE;
CREATE TABLE public.lands_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Land characteristics
    area_sqft integer NULL,
    frontage_ft integer NULL,
    depth_ft integer NULL,
    land_use text NULL, -- 'residential', 'commercial', etc.
    zoning text NULL,
    
    -- Physical characteristics
    topography text NULL, -- 'level', 'sloped', 'irregular'
    utilities text[] NULL, -- Array of available utilities
    access_type text NULL, -- 'paved_road', 'gravel', etc.
    
    -- Environmental factors
    flood_zone text NULL,
    wetlands boolean DEFAULT false,
    
    -- Flexible data storage
    land_data jsonb NOT NULL DEFAULT '{}',
    
    -- Tracking
    current_review_id bigint REFERENCES public.reviews_v2 (id),
    effective_date date NOT NULL DEFAULT current_date,
    created_at timestamptz NOT NULL DEFAULT now(),
    retired_at timestamptz NULL
);

CREATE INDEX lands_v2_parcel_idx ON public.lands_v2 (parcel_id);
CREATE INDEX lands_v2_land_use_idx ON public.lands_v2 (land_use);
CREATE INDEX lands_v2_area_idx ON public.lands_v2 (area_sqft);
CREATE INDEX lands_v2_data_gin_idx ON public.lands_v2 USING gin (land_data);

-- ============================================================
-- SALES (With building data at time of sale)
-- ============================================================

DROP TABLE IF EXISTS public.sales_v2 CASCADE;
CREATE TABLE public.sales_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- Sale information
    sale_date date NOT NULL,
    sale_price numeric(12,2) NOT NULL,
    sale_type text NOT NULL DEFAULT 'arms_length', -- 'arms_length', 'foreclosure', etc.
    grantor text NULL,
    grantee text NULL,
    
    -- Sale validity (determined through review)
    is_valid boolean NULL, -- NULL = under review, true/false = determined
    validity_reason text NULL,
    
    -- Building condition AT SALE (snapshot)
    building_condition_at_sale jsonb NULL, -- Store building data as it was at sale
    
    -- Market conditions
    market_conditions text NULL,
    financing_terms text NULL,
    
    -- Additional sale details
    sale_data jsonb NOT NULL DEFAULT '{}',
    
    -- Review tracking
    review_id bigint REFERENCES public.reviews_v2 (id),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX sales_v2_date_idx ON public.sales_v2 (sale_date DESC);
CREATE INDEX sales_v2_price_idx ON public.sales_v2 (sale_price);
CREATE INDEX sales_v2_valid_idx ON public.sales_v2 (is_valid);

-- ============================================================
-- SALES_PARCELS (Junction table for many-to-many relationship)
-- ============================================================

DROP TABLE IF EXISTS public.sales_parcels_v2 CASCADE;
CREATE TABLE public.sales_parcels_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id bigint NOT NULL REFERENCES public.sales_v2 (id) ON DELETE CASCADE,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    -- Optional: portion of sale price allocated to this parcel
    allocated_price numeric(12,2) NULL,
    -- Optional: percentage of total sale this parcel represents
    percentage numeric(5,2) NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (sale_id, parcel_id)
);

CREATE INDEX sales_parcels_v2_sale_idx ON public.sales_parcels_v2 (sale_id);
CREATE INDEX sales_parcels_v2_parcel_idx ON public.sales_parcels_v2 (parcel_id);

-- ============================================================
-- PERMITS
-- ============================================================

DROP TABLE IF EXISTS public.permits_v2 CASCADE;
CREATE TABLE public.permits_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Permit details
    permit_number text NOT NULL,
    permit_type text NOT NULL, -- 'building', 'demolition', 'renovation', etc.
    issued_date date NULL,
    completed_date date NULL,
    permit_value numeric(12,2) NULL,
    
    -- Work description
    work_description text NULL,
    contractor_name text NULL,
    
    -- Impact on assessment
    affects_value boolean DEFAULT true,
    estimated_value_impact numeric(12,2) NULL,
    
    -- Additional permit data
    permit_data jsonb NOT NULL DEFAULT '{}',
    
    -- Review tracking
    review_id bigint REFERENCES public.reviews_v2 (id),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX permits_v2_parcel_idx ON public.permits_v2 (parcel_id);
CREATE INDEX permits_v2_number_idx ON public.permits_v2 (permit_number);
CREATE INDEX permits_v2_type_idx ON public.permits_v2 (permit_type);
CREATE INDEX permits_v2_date_idx ON public.permits_v2 (issued_date DESC);

-- ============================================================
-- APPEALS
-- ============================================================

DROP TABLE IF EXISTS public.appeals_v2 CASCADE;
CREATE TABLE public.appeals_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Appeal information
    appeal_number text NOT NULL,
    filed_date date NOT NULL DEFAULT current_date,
    appeal_level text NOT NULL, -- 'informal', 'formal', 'board', 'court'
    
    -- Appellant information
    appellant_name text NOT NULL,
    appellant_address text NULL,
    appellant_phone text NULL,
    appellant_email text NULL,
    
    -- Appeal details
    current_assessment numeric(12,2) NULL,
    requested_assessment numeric(12,2) NULL,
    reason_for_appeal text NULL,
    
    -- Resolution
    final_assessment numeric(12,2) NULL,
    resolution_date date NULL,
    resolution_notes text NULL,
    
    -- Additional appeal data
    appeal_data jsonb NOT NULL DEFAULT '{}',
    
    -- Review tracking
    review_id bigint REFERENCES public.reviews_v2 (id),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX appeals_v2_parcel_idx ON public.appeals_v2 (parcel_id);
CREATE INDEX appeals_v2_number_idx ON public.appeals_v2 (appeal_number);
CREATE INDEX appeals_v2_filed_idx ON public.appeals_v2 (filed_date DESC);
CREATE INDEX appeals_v2_level_idx ON public.appeals_v2 (appeal_level);

-- ============================================================
-- PARCEL SNAPSHOTS (Historical data tracking)
-- ============================================================

DROP TABLE IF EXISTS public.parcel_snapshots_v2 CASCADE;
CREATE TABLE public.parcel_snapshots_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE RESTRICT,
    
    -- Snapshot of parcel data at this point in time
    snapshot_date date NOT NULL DEFAULT current_date,
    
    -- Copy of parcel fields at this time
    block integer,
    lot integer,
    ext integer,
    parcel_number text,
    tax_status_id bigint REFERENCES public.tax_statuses_v2 (id),
    property_class text,
    owner_name text,
    owner_address_id bigint REFERENCES public.addresses_v2 (id),
    site_address_id bigint REFERENCES public.addresses_v2 (id),
    neighborhood_id bigint REFERENCES public.neighborhoods_v2 (id),
    parcel_data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now(),
    created_by uuid DEFAULT auth.uid()
);

CREATE INDEX parcel_snapshots_v2_parcel_date_idx ON public.parcel_snapshots_v2 (parcel_id, snapshot_date DESC);
CREATE INDEX parcel_snapshots_v2_review_idx ON public.parcel_snapshots_v2 (review_id);
CREATE INDEX parcel_snapshots_v2_date_idx ON public.parcel_snapshots_v2 (snapshot_date DESC);

-- ============================================================
-- BUILDING SNAPSHOTS (Historical building data)
-- ============================================================

DROP TABLE IF EXISTS public.building_snapshots_v2 CASCADE;
CREATE TABLE public.building_snapshots_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    building_id bigint NOT NULL REFERENCES public.buildings_v2 (id) ON DELETE CASCADE,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE RESTRICT,
    snapshot_date date NOT NULL DEFAULT current_date,
    
    -- Building data at this time
    year_built integer,
    square_footage integer,
    finished_area integer,
    bedrooms integer,
    bathrooms numeric(3,1),
    condition_rating integer CHECK (condition_rating BETWEEN 1 AND 10),
    building_type text,
    building_data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX building_snapshots_v2_building_date_idx ON public.building_snapshots_v2 (building_id, snapshot_date DESC);
CREATE INDEX building_snapshots_v2_review_idx ON public.building_snapshots_v2 (review_id);
CREATE INDEX building_snapshots_v2_date_idx ON public.building_snapshots_v2 (snapshot_date DESC);

-- ============================================================
-- LAND SNAPSHOTS (Historical land data)
-- ============================================================

DROP TABLE IF EXISTS public.land_snapshots_v2 CASCADE;
CREATE TABLE public.land_snapshots_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_id bigint NOT NULL REFERENCES public.lands_v2 (id) ON DELETE CASCADE,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE RESTRICT,
    snapshot_date date NOT NULL DEFAULT current_date,
    
    -- Land data at this time
    area_sqft integer,
    frontage_ft integer,
    depth_ft integer,
    land_use text,
    topography text,
    land_data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX land_snapshots_v2_land_date_idx ON public.land_snapshots_v2 (land_id, snapshot_date DESC);
CREATE INDEX land_snapshots_v2_review_idx ON public.land_snapshots_v2 (review_id);
CREATE INDEX land_snapshots_v2_date_idx ON public.land_snapshots_v2 (snapshot_date DESC);

-- ============================================================
-- REVIEW HISTORY (Status changes)
-- ============================================================

DROP TABLE IF EXISTS public.review_history_v2 CASCADE;
CREATE TABLE public.review_history_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE CASCADE,
    status_id bigint NOT NULL REFERENCES public.review_statuses_v2 (id),
    note text NULL,
    changed_by uuid NOT NULL DEFAULT auth.uid(),
    changed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX review_history_v2_review_idx ON public.review_history_v2 (review_id, changed_at DESC);

-- ============================================================
-- AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-log status changes
DROP FUNCTION IF EXISTS log_review_status_change_v2();
CREATE OR REPLACE FUNCTION log_review_status_change_v2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF OLD.current_status_id IS DISTINCT FROM NEW.current_status_id THEN
        INSERT INTO public.review_history_v2 (review_id, status_id, note, changed_by)
        VALUES (
            NEW.id, 
            NEW.current_status_id, 
            'Status updated automatically',
            COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
        );
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS review_status_change_trigger_v2 ON public.reviews_v2;
CREATE TRIGGER review_status_change_trigger_v2
    AFTER UPDATE ON public.reviews_v2
    FOR EACH ROW 
    WHEN (OLD.current_status_id IS DISTINCT FROM NEW.current_status_id)
    EXECUTE FUNCTION log_review_status_change_v2();

-- Auto-update timestamps
DROP FUNCTION IF EXISTS update_timestamp_v2();
CREATE OR REPLACE FUNCTION update_timestamp_v2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS employees_timestamp_trigger_v2 ON public.employees_v2;
CREATE TRIGGER employees_timestamp_trigger_v2
    BEFORE UPDATE ON public.employees_v2
    FOR EACH ROW EXECUTE FUNCTION update_timestamp_v2();

-- ============================================================
-- MASS OPERATIONS FUNCTIONS
-- ============================================================

-- Mass create reviews
DROP FUNCTION IF EXISTS mass_create_reviews_v2(review_kind_v2, bigint[], text, date, jsonb);
CREATE OR REPLACE FUNCTION mass_create_reviews_v2(
    p_kind public.review_kind_v2,
    p_parcel_ids bigint[],
    p_title text DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_data jsonb DEFAULT '{}'
)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_ids bigint[] := '{}';
    v_parcel_id bigint;
    v_review_id bigint;
    v_default_status_id bigint;
BEGIN
    -- Get default status for this review kind
    SELECT id INTO v_default_status_id
    FROM public.review_statuses_v2
    WHERE review_kind = p_kind
    ORDER BY sort_order ASC
    LIMIT 1;
    
    -- Create review for each parcel
    FOREACH v_parcel_id IN ARRAY p_parcel_ids
    LOOP
        INSERT INTO public.reviews_v2 (kind, title, due_date, current_status_id, data, created_by)
        VALUES (
            p_kind, 
            p_title, 
            p_due_date, 
            v_default_status_id, 
            p_data || jsonb_build_object('parcel_id', v_parcel_id),
            COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
        )
        RETURNING id INTO v_review_id;
        
        v_review_ids := v_review_ids || v_review_id;
    END LOOP;
    
    RETURN v_review_ids;
END;
$$;

-- Mass assign reviews
DROP FUNCTION IF EXISTS mass_assign_reviews_v2(bigint[], bigint);
CREATE OR REPLACE FUNCTION mass_assign_reviews_v2(
    p_review_ids bigint[],
    p_employee_id bigint
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.reviews_v2
    SET assigned_to_id = p_employee_id
    WHERE id = ANY(p_review_ids);
    
    RETURN true;
END;
$$;

-- Mass update review status
DROP FUNCTION IF EXISTS mass_update_review_status_v2(bigint[], text, text);
CREATE OR REPLACE FUNCTION mass_update_review_status_v2(
    p_review_ids bigint[],
    p_status_slug text,
    p_note text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_status_id bigint;
    v_review_id bigint;
    v_kind public.review_kind_v2;
BEGIN
    -- Process each review
    FOREACH v_review_id IN ARRAY p_review_ids
    LOOP
        -- Get review kind
        SELECT kind INTO v_kind
        FROM public.reviews_v2
        WHERE id = v_review_id;
        
        -- Get status ID for this review kind
        SELECT id INTO v_status_id
        FROM public.review_statuses_v2
        WHERE review_kind = v_kind AND slug = p_status_slug;
        
        IF v_status_id IS NOT NULL THEN
            UPDATE public.reviews_v2
            SET current_status_id = v_status_id
            WHERE id = v_review_id;
            
            -- Add note if provided
            IF p_note IS NOT NULL THEN
                INSERT INTO public.review_history_v2 (review_id, status_id, note, changed_by)
                VALUES (
                    v_review_id, 
                    v_status_id, 
                    p_note,
                    COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
                );
            END IF;
        END IF;
    END LOOP;
    
    RETURN true;
END;
$$;

-- ============================================================
-- HISTORICAL QUERY FUNCTIONS
-- ============================================================

-- Get parcel data as of a specific date
DROP FUNCTION IF EXISTS get_parcel_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_parcel_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS TABLE (
    parcel_id bigint,
    block integer,
    lot integer,
    ext integer,
    parcel_number text,
    tax_status text,
    property_class text,
    owner_name text,
    owner_address text,
    site_address text,
    neighborhood text,
    snapshot_date date,
    parcel_data jsonb
)
LANGUAGE sql
STABLE
AS $$
    -- Get the most recent snapshot on or before the specified date
    SELECT 
        ps.parcel_id,
        ps.block,
        ps.lot,
        ps.ext,
        ps.parcel_number,
        ts.name as tax_status,
        ps.property_class,
        ps.owner_name,
        oa.street_address || COALESCE(', ' || oa.city, '') || COALESCE(', ' || oa.state, '') || COALESCE(' ' || oa.zip, '') as owner_address,
        sa.street_address || COALESCE(', ' || sa.city, '') || COALESCE(', ' || sa.state, '') || COALESCE(' ' || sa.zip, '') as site_address,
        n.name as neighborhood,
        ps.snapshot_date,
        ps.parcel_data
    FROM public.parcel_snapshots_v2 ps
    LEFT JOIN public.tax_statuses_v2 ts ON ps.tax_status_id = ts.id
    LEFT JOIN public.addresses_v2 oa ON ps.owner_address_id = oa.id
    LEFT JOIN public.addresses_v2 sa ON ps.site_address_id = sa.id
    LEFT JOIN public.neighborhoods_v2 n ON ps.neighborhood_id = n.id
    WHERE ps.parcel_id = p_parcel_id 
      AND ps.snapshot_date <= p_as_of_date
    ORDER BY ps.snapshot_date DESC
    LIMIT 1;
$$;

-- Get buildings as of a specific date
DROP FUNCTION IF EXISTS get_buildings_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_buildings_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS TABLE (
    building_id bigint,
    year_built integer,
    square_footage integer,
    finished_area integer,
    bedrooms integer,
    bathrooms numeric(3,1),
    condition_rating integer,
    building_type text,
    snapshot_date date,
    building_data jsonb
)
LANGUAGE sql
STABLE
AS $$
    SELECT DISTINCT ON (b.id)
        bs.building_id,
        bs.year_built,
        bs.square_footage,
        bs.finished_area,
        bs.bedrooms,
        bs.bathrooms,
        bs.condition_rating,
        bs.building_type,
        bs.snapshot_date,
        bs.building_data
    FROM public.buildings_v2 b
    JOIN public.building_snapshots_v2 bs ON b.id = bs.building_id
    WHERE b.parcel_id = p_parcel_id
      AND bs.snapshot_date <= p_as_of_date
      AND (b.retired_at IS NULL OR b.retired_at > p_as_of_date)
    ORDER BY b.id, bs.snapshot_date DESC;
$$;

-- Get land data as of a specific date
DROP FUNCTION IF EXISTS get_land_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_land_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS TABLE (
    land_id bigint,
    area_sqft integer,
    frontage_ft integer,
    depth_ft integer,
    land_use text,
    topography text,
    snapshot_date date,
    land_data jsonb
)
LANGUAGE sql
STABLE
AS $$
    SELECT DISTINCT ON (l.id)
        ls.land_id,
        ls.area_sqft,
        ls.frontage_ft,
        ls.depth_ft,
        ls.land_use,
        ls.topography,
        ls.snapshot_date,
        ls.land_data
    FROM public.lands_v2 l
    JOIN public.land_snapshots_v2 ls ON l.id = ls.land_id
    WHERE l.parcel_id = p_parcel_id
      AND ls.snapshot_date <= p_as_of_date
      AND (l.retired_at IS NULL OR l.retired_at > p_as_of_date)
    ORDER BY l.id, ls.snapshot_date DESC;
$$;

-- Get complete parcel with all components as of date
DROP FUNCTION IF EXISTS get_complete_parcel_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_complete_parcel_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_result jsonb := '{}';
    v_parcel record;
    v_buildings jsonb := '[]';
    v_lands jsonb := '[]';
BEGIN
    -- Get parcel data
    SELECT * INTO v_parcel
    FROM get_parcel_as_of_date_v2(p_parcel_id, p_as_of_date);
    
    IF v_parcel.parcel_id IS NOT NULL THEN
        v_result := jsonb_build_object(
            'parcel', row_to_json(v_parcel),
            'buildings', (
                SELECT jsonb_agg(row_to_json(b))
                FROM get_buildings_as_of_date_v2(p_parcel_id, p_as_of_date) b
            ),
            'lands', (
                SELECT jsonb_agg(row_to_json(l))
                FROM get_land_as_of_date_v2(p_parcel_id, p_as_of_date) l
            )
        );
    END IF;
    
    RETURN v_result;
END;
$$;

-- Get parcel change timeline
DROP FUNCTION IF EXISTS get_parcel_timeline_v2(bigint, date, date);
CREATE OR REPLACE FUNCTION get_parcel_timeline_v2(
    p_parcel_id bigint,
    p_start_date date DEFAULT '1900-01-01',
    p_end_date date DEFAULT current_date
)
RETURNS TABLE (
    snapshot_date date,
    review_id bigint,
    owner_name text,
    tax_status text,
    property_class text,
    changes jsonb
)
LANGUAGE sql
STABLE
AS $$
    SELECT 
        ps.snapshot_date,
        ps.review_id,
        ps.owner_name,
        ts.name as tax_status,
        ps.property_class,
        ps.parcel_data AS changes
    FROM public.parcel_snapshots_v2 ps
    LEFT JOIN public.tax_statuses_v2 ts ON ps.tax_status_id = ts.id
    WHERE ps.parcel_id = p_parcel_id
      AND ps.snapshot_date BETWEEN p_start_date AND p_end_date
    ORDER BY ps.snapshot_date DESC;
$$;

-- ============================================================
-- SNAPSHOT AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-create snapshots when reviews are completed
DROP FUNCTION IF EXISTS create_snapshots_on_review_completion_v2();
CREATE OR REPLACE FUNCTION create_snapshots_on_review_completion_v2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_parcel_id bigint;
    v_building_id bigint;
    v_land_id bigint;
BEGIN
    -- Only create snapshots when review is marked as completed
    IF OLD.completed_at IS NULL AND NEW.completed_at IS NOT NULL THEN
        
        -- Get parcel ID from review data
        v_parcel_id := (NEW.data->>'parcel_id')::bigint;
        
        IF v_parcel_id IS NOT NULL THEN
            -- Create parcel snapshot
            INSERT INTO public.parcel_snapshots_v2 (
                parcel_id, review_id, snapshot_date, block, lot, ext, parcel_number,
                tax_status_id, property_class, owner_name, owner_address_id, 
                site_address_id, neighborhood_id, parcel_data
            )
            SELECT 
                p.id, NEW.id, current_date, p.block, p.lot, p.ext, p.parcel_number,
                p.tax_status_id, p.property_class, p.owner_name, p.owner_address_id,
                p.site_address_id, p.neighborhood_id, p.parcel_data
            FROM public.parcels_v2 p
            WHERE p.id = v_parcel_id;
            
            -- Create building snapshots for all active buildings on this parcel
            INSERT INTO public.building_snapshots_v2 (
                building_id, review_id, snapshot_date, year_built, square_footage,
                finished_area, bedrooms, bathrooms, condition_rating, 
                building_type, building_data
            )
            SELECT 
                b.id, NEW.id, current_date, b.year_built, b.square_footage,
                b.finished_area, b.bedrooms, b.bathrooms, b.condition_rating,
                b.building_type, b.building_data
            FROM public.buildings_v2 b
            WHERE b.parcel_id = v_parcel_id AND b.retired_at IS NULL;
            
            -- Create land snapshots for all active land records on this parcel
            INSERT INTO public.land_snapshots_v2 (
                land_id, review_id, snapshot_date, area_sqft, frontage_ft,
                depth_ft, land_use, topography, land_data
            )
            SELECT 
                l.id, NEW.id, current_date, l.area_sqft, l.frontage_ft,
                l.depth_ft, l.land_use, l.topography, l.land_data
            FROM public.lands_v2 l
            WHERE l.parcel_id = v_parcel_id AND l.retired_at IS NULL;
        END IF;
        
        -- Handle specific entity snapshots based on review kind
        CASE NEW.kind
            WHEN 'building_review' THEN
                v_building_id := (NEW.data->>'building_id')::bigint;
                IF v_building_id IS NOT NULL THEN
                    INSERT INTO public.building_snapshots_v2 (
                        building_id, review_id, snapshot_date, year_built, square_footage,
                        finished_area, bedrooms, bathrooms, condition_rating,
                        building_type, building_data
                    )
                    SELECT 
                        b.id, NEW.id, current_date, b.year_built, b.square_footage,
                        b.finished_area, b.bedrooms, b.bathrooms, b.condition_rating,
                        b.building_type, b.building_data
                    FROM public.buildings_v2 b
                    WHERE b.id = v_building_id;
                END IF;
                
            WHEN 'land_review' THEN
                v_land_id := (NEW.data->>'land_id')::bigint;
                IF v_land_id IS NOT NULL THEN
                    INSERT INTO public.land_snapshots_v2 (
                        land_id, review_id, snapshot_date, area_sqft, frontage_ft,
                        depth_ft, land_use, topography, land_data
                    )
                    SELECT 
                        l.id, NEW.id, current_date, l.area_sqft, l.frontage_ft,
                        l.depth_ft, l.land_use, l.topography, l.land_data
                    FROM public.lands_v2 l
                    WHERE l.id = v_land_id;
                END IF;
                
            ELSE
                -- Default case handled above with parcel-level snapshots
                NULL;
        END CASE;
    END IF;
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS create_snapshots_trigger_v2 ON public.reviews_v2;
CREATE TRIGGER create_snapshots_trigger_v2
    AFTER UPDATE ON public.reviews_v2
    FOR EACH ROW
    EXECUTE FUNCTION create_snapshots_on_review_completion_v2();

-- ============================================================
-- UTILITY FUNCTIONS
-- ============================================================

-- Get employee permissions
DROP FUNCTION IF EXISTS get_employee_permissions_v2(uuid);
CREATE OR REPLACE FUNCTION get_employee_permissions_v2(p_user_id uuid)
RETURNS TABLE (
    employee_id bigint,
    full_name text,
    can_approve boolean
)
LANGUAGE sql
STABLE
AS $$
    SELECT 
        e.id,
        e.first_name || ' ' || e.last_name,
        e.can_approve
    FROM public.employees_v2 e
    WHERE e.user_id = p_user_id 
      AND e.status = 'active';
$$;

-- Get parcel summary with current reviews
DROP FUNCTION IF EXISTS get_parcel_summary_v2(bigint);
CREATE OR REPLACE FUNCTION get_parcel_summary_v2(p_parcel_id bigint)
RETURNS TABLE (
    parcel_id bigint,
    parcel_number text,
    site_address text,
    owner_name text,
    building_count bigint,
    land_count bigint,
    current_review_kind public.review_kind_v2,
    current_review_status text,
    last_sale_date date,
    last_sale_price numeric
)
LANGUAGE sql
STABLE
AS $$
    SELECT 
        p.id,
        p.parcel_number,
        sa.street_address || COALESCE(', ' || sa.city, '') || COALESCE(', ' || sa.state, '') || COALESCE(' ' || sa.zip, '') as site_address,
        p.owner_name,
        (SELECT COUNT(*) FROM public.buildings_v2 b WHERE b.parcel_id = p.id AND b.retired_at IS NULL),
        (SELECT COUNT(*) FROM public.lands_v2 l WHERE l.parcel_id = p.id AND l.retired_at IS NULL),
        r.kind,
        rs.name,
        s.sale_date,
        s.sale_price
    FROM public.parcels_v2 p
    LEFT JOIN public.addresses_v2 sa ON p.site_address_id = sa.id
    LEFT JOIN public.reviews_v2 r ON p.current_review_id = r.id
    LEFT JOIN public.review_statuses_v2 rs ON r.current_status_id = rs.id
    LEFT JOIN LATERAL (
        SELECT sp.sale_id, s.sale_date, s.sale_price
        FROM public.sales_parcels_v2 sp
        JOIN public.sales_v2 s ON sp.sale_id = s.id
        WHERE sp.parcel_id = p.id 
        ORDER BY s.sale_date DESC 
        LIMIT 1
    ) s ON true
    WHERE p.id = p_parcel_id;
$$;

-- ============================================================
-- VIEWS
-- ============================================================

-- Active reviews summary
DROP VIEW IF EXISTS active_reviews_v2;
CREATE VIEW active_reviews_v2 AS
SELECT 
    r.id,
    r.kind,
    r.title,
    r.due_date,
    rs.name as status_name,
    rs.needs_approval,
    e.first_name || ' ' || e.last_name as assigned_to,
    r.created_at,
    (COALESCE(r.due_date, CURRENT_DATE) - CURRENT_DATE) as days_until_due
FROM public.reviews_v2 r
LEFT JOIN public.review_statuses_v2 rs ON r.current_status_id = rs.id
LEFT JOIN public.employees_v2 e ON r.assigned_to_id = e.id
WHERE r.completed_at IS NULL;

-- Parcel overview
DROP VIEW IF EXISTS parcel_overview_v2;
CREATE VIEW parcel_overview_v2 AS
SELECT 
    p.id,
    p.block,
    p.lot, 
    p.ext,
    p.parcel_number,
    sa.street_address || COALESCE(', ' || sa.city, '') || COALESCE(', ' || sa.state, '') || COALESCE(' ' || sa.zip, '') as site_address,
    p.owner_name,
    n.name as neighborhood,
    ts.name as tax_status,
    COUNT(DISTINCT b.id) as building_count,
    COUNT(DISTINCT l.id) as land_count,
    COUNT(DISTINCT sp.sale_id) as sale_count,
    MAX(s.sale_date) as last_sale_date,
    r.kind as current_review_kind,
    rs.name as current_review_status
FROM public.parcels_v2 p
LEFT JOIN public.addresses_v2 sa ON p.site_address_id = sa.id
LEFT JOIN public.neighborhoods_v2 n ON p.neighborhood_id = n.id
LEFT JOIN public.tax_statuses_v2 ts ON p.tax_status_id = ts.id
LEFT JOIN public.buildings_v2 b ON p.id = b.parcel_id AND b.retired_at IS NULL
LEFT JOIN public.lands_v2 l ON p.id = l.parcel_id AND l.retired_at IS NULL
LEFT JOIN public.sales_parcels_v2 sp ON p.id = sp.parcel_id
LEFT JOIN public.sales_v2 s ON sp.sale_id = s.id
LEFT JOIN public.reviews_v2 r ON p.current_review_id = r.id
LEFT JOIN public.review_statuses_v2 rs ON r.current_status_id = rs.id
GROUP BY p.id, p.block, p.lot, p.ext, p.parcel_number, sa.street_address, sa.city, sa.state, sa.zip, 
         p.owner_name, n.name, ts.name, r.kind, rs.name;

-- ============================================================
-- END SCHEMA-V2-ULTRA-SIMPLE.SQL
-- ============================================================