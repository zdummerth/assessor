-- ============================================================
-- SCHEMA-V2-ULTRA-SIMPLE.SQL: Simplified Parcel Data Tracking
-- ============================================================
-- Idempotent schema with _v2 suffix for all tables and functions
-- Focus: Track parcel data over time through reviews system

-- Drop and recreate enum types
DROP TYPE IF EXISTS public.review_kind_v2 CASCADE;
CREATE TYPE public.review_kind_v2 AS ENUM (
    'sale_review',
    'permit_review', 
    'appeal_review',
    'building_review',
    'land_review',
    'parcel_review',
    'building_valuation',
    'land_valuation',
    'value_calculation',
    'use_conversion'
);

-- ============================================================
-- EMPLOYEES
-- ============================================================

DROP TABLE IF EXISTS public.employees_v2 CASCADE;
CREATE TABLE public.employees_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid UNIQUE NULL, -- Links to Supabase auth
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text UNIQUE NULL,
    status text NOT NULL DEFAULT 'active',
    can_approve boolean NOT NULL DEFAULT false,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX employees_v2_user_id_idx ON public.employees_v2 (user_id);
CREATE INDEX employees_v2_status_idx ON public.employees_v2 (status);

-- ============================================================
-- LOOKUP TABLES
-- ============================================================

-- Neighborhoods lookup
DROP TABLE IF EXISTS public.neighborhoods_v2 CASCADE;
CREATE TABLE public.neighborhoods_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX neighborhoods_v2_name_idx ON public.neighborhoods_v2 (name);

-- Tax statuses lookup
DROP TABLE IF EXISTS public.tax_statuses_v2 CASCADE;
CREATE TABLE public.tax_statuses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NULL,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX tax_statuses_v2_name_idx ON public.tax_statuses_v2 (name);
CREATE INDEX tax_statuses_v2_active_idx ON public.tax_statuses_v2 (is_active);

-- Addresses lookup (for both site and owner addresses)
DROP TABLE IF EXISTS public.addresses_v2 CASCADE;
CREATE TABLE public.addresses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    street_address text NOT NULL,
    city text NULL,
    state text NULL,
    zip text NULL,
    latitude numeric NULL,
    longitude numeric NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX addresses_v2_street_idx ON public.addresses_v2 (street_address);
CREATE INDEX addresses_v2_city_idx ON public.addresses_v2 (city);
CREATE INDEX addresses_v2_location_idx ON public.addresses_v2 (latitude, longitude);
CREATE UNIQUE INDEX addresses_v2_full_address_idx ON public.addresses_v2 (street_address, city, state, zip);

-- Assessment cycles for value calculations
DROP TABLE IF EXISTS public.assessment_cycles_v2 CASCADE;
CREATE TABLE public.assessment_cycles_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tax_year integer NOT NULL UNIQUE,
    start_date date NOT NULL,
    end_date date NOT NULL,
    is_active boolean DEFAULT false NOT NULL,
    description text,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT valid_cycle_dates CHECK (end_date > start_date)
);

CREATE INDEX assessment_cycles_v2_tax_year_idx ON public.assessment_cycles_v2 (tax_year);
CREATE INDEX assessment_cycles_v2_active_idx ON public.assessment_cycles_v2 (is_active);

-- Property uses for buildings and land
DROP TABLE IF EXISTS public.property_uses_v2 CASCADE;
CREATE TABLE public.property_uses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text,
    category text NOT NULL, -- residential, commercial, industrial, agricultural
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX property_uses_v2_name_idx ON public.property_uses_v2 (name);
CREATE INDEX property_uses_v2_category_idx ON public.property_uses_v2 (category);
CREATE INDEX property_uses_v2_active_idx ON public.property_uses_v2 (is_active);

-- Valuation methods
DROP TABLE IF EXISTS public.valuation_methods_v2 CASCADE;
CREATE TABLE public.valuation_methods_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text,
    calculation_formula text, -- Optional formula for automated calculations
    requires_comparables boolean DEFAULT false NOT NULL,
    requires_income_data boolean DEFAULT false NOT NULL,
    requires_cost_data boolean DEFAULT false NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX valuation_methods_v2_name_idx ON public.valuation_methods_v2 (name);
CREATE INDEX valuation_methods_v2_active_idx ON public.valuation_methods_v2 (is_active);

-- Value types for mixed-use properties
DROP TABLE IF EXISTS public.value_types_v2 CASCADE;
CREATE TABLE public.value_types_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE, -- commercial, residential, agricultural
    description text,
    tax_category text, -- For tax calculation purposes
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX value_types_v2_name_idx ON public.value_types_v2 (name);
CREATE INDEX value_types_v2_active_idx ON public.value_types_v2 (is_active);

-- Standardized value components
DROP TABLE IF EXISTS public.value_components_v2 CASCADE;
CREATE TABLE public.value_components_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text,
    component_category text NOT NULL, -- foundation, structure, mechanical, exterior, interior
    applies_to text NOT NULL CHECK (applies_to IN ('building', 'land', 'both')),
    calculation_method text, -- Optional method description
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX value_components_v2_name_idx ON public.value_components_v2 (name);
CREATE INDEX value_components_v2_category_idx ON public.value_components_v2 (component_category);
CREATE INDEX value_components_v2_applies_to_idx ON public.value_components_v2 (applies_to);
CREATE INDEX value_components_v2_active_idx ON public.value_components_v2 (is_active);

-- ============================================================
-- REVIEW STATUSES
-- ============================================================

DROP TABLE IF EXISTS public.review_statuses_v2 CASCADE;
CREATE TABLE public.review_statuses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_kind public.review_kind_v2 NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    is_terminal boolean NOT NULL DEFAULT false,
    needs_approval boolean NOT NULL DEFAULT false,
    sort_order int NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (review_kind, slug)
);

-- Insert default review statuses for new review types
INSERT INTO public.review_statuses_v2 (review_kind, slug, name, is_terminal, needs_approval, sort_order) VALUES
-- Building valuation statuses
('building_valuation', 'scheduled', 'Scheduled', false, false, 1),
('building_valuation', 'in-progress', 'In Progress', false, false, 2),
('building_valuation', 'needs-approval', 'Needs Approval', false, true, 3),
('building_valuation', 'approved', 'Approved', true, false, 4),
('building_valuation', 'rejected', 'Rejected', true, false, 5),

-- Land valuation statuses
('land_valuation', 'scheduled', 'Scheduled', false, false, 1),
('land_valuation', 'in-progress', 'In Progress', false, false, 2),
('land_valuation', 'needs-approval', 'Needs Approval', false, true, 3),
('land_valuation', 'approved', 'Approved', true, false, 4),
('land_valuation', 'rejected', 'Rejected', true, false, 5),

-- Value calculation statuses
('value_calculation', 'draft', 'Draft', false, false, 1),
('value_calculation', 'calculating', 'Calculating', false, false, 2),
('value_calculation', 'needs-approval', 'Needs Approval', false, true, 3),
('value_calculation', 'approved', 'Approved', true, false, 4),
('value_calculation', 'rejected', 'Rejected', true, false, 5),

-- Use conversion statuses
('use_conversion', 'requested', 'Requested', false, false, 1),
('use_conversion', 'investigating', 'Investigating', false, false, 2),
('use_conversion', 'needs-approval', 'Needs Approval', false, true, 3),
('use_conversion', 'approved', 'Approved', true, false, 4),
('use_conversion', 'rejected', 'Rejected', true, false, 5)
ON CONFLICT (review_kind, slug) DO NOTHING;

-- ============================================================
-- REVIEWS (Central workflow)
-- ============================================================

DROP TABLE IF EXISTS public.reviews_v2 CASCADE;
CREATE TABLE public.reviews_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kind public.review_kind_v2 NOT NULL,
    title text NULL,
    due_date date NULL,
    current_status_id bigint REFERENCES public.review_statuses_v2 (id),
    assigned_to_id bigint REFERENCES public.employees_v2 (id),
    data jsonb NOT NULL DEFAULT '{}', -- All review-specific data
    created_at timestamptz NOT NULL DEFAULT now(),
    created_by uuid NOT NULL DEFAULT auth.uid(),
    completed_at timestamptz NULL
);

CREATE INDEX reviews_v2_kind_idx ON public.reviews_v2 (kind, created_at DESC);
CREATE INDEX reviews_v2_status_idx ON public.reviews_v2 (current_status_id);
CREATE INDEX reviews_v2_assigned_idx ON public.reviews_v2 (assigned_to_id);
CREATE INDEX reviews_v2_data_gin_idx ON public.reviews_v2 USING gin (data);

-- ============================================================
-- PARCELS (Core entity)
-- ============================================================

DROP TABLE IF EXISTS public.parcels_v2 CASCADE;
CREATE TABLE public.parcels_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- Basic parcel identifiers
    block integer NULL,
    lot integer NULL,
    ext integer NULL,
    parcel_number text NULL,
    
    -- Current data (updated through reviews)
    tax_status_id bigint REFERENCES public.tax_statuses_v2 (id),
    property_class text NULL,
    default_appraiser_id bigint REFERENCES public.employees_v2 (id),
    
    -- Owner information
    owner_name text NULL,
    owner_address_id bigint REFERENCES public.addresses_v2 (id),
    
    -- Site address (primary)
    site_address_id bigint REFERENCES public.addresses_v2 (id),
    
    -- Location
    neighborhood_id bigint REFERENCES public.neighborhoods_v2 (id),
    
    -- Flexible data storage
    parcel_data jsonb NOT NULL DEFAULT '{}',
    
    -- Tracking
    current_review_id bigint REFERENCES public.reviews_v2 (id),
    last_updated_at timestamptz NOT NULL DEFAULT now(),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX parcels_v2_block_lot_ext_idx ON public.parcels_v2 (block, lot, ext);
CREATE INDEX parcels_v2_parcel_number_idx ON public.parcels_v2 (parcel_number);
CREATE INDEX parcels_v2_owner_idx ON public.parcels_v2 (owner_name);
CREATE INDEX parcels_v2_neighborhood_id_idx ON public.parcels_v2 (neighborhood_id);
CREATE INDEX parcels_v2_tax_status_id_idx ON public.parcels_v2 (tax_status_id);
CREATE INDEX parcels_v2_site_address_id_idx ON public.parcels_v2 (site_address_id);
CREATE INDEX parcels_v2_owner_address_id_idx ON public.parcels_v2 (owner_address_id);
CREATE INDEX parcels_v2_data_gin_idx ON public.parcels_v2 USING gin (parcel_data);

-- Performance optimization indexes
CREATE INDEX IF NOT EXISTS parcels_v2_search_composite_idx 
    ON public.parcels_v2 (neighborhood_id, property_class, owner_name);
CREATE INDEX IF NOT EXISTS parcel_snapshots_v2_lookup_idx 
    ON public.parcel_snapshots_v2 (parcel_id, snapshot_date DESC) 
    WHERE snapshot_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS building_values_v2_active_lookup_idx 
    ON public.building_values_v2 (building_id, is_active, total_value) 
    WHERE is_active = true;
CREATE INDEX IF NOT EXISTS land_values_v2_active_lookup_idx 
    ON public.land_values_v2 (land_id, is_active, total_value) 
    WHERE is_active = true;

-- ============================================================
-- BUILDINGS (Parcel components)
-- ============================================================

DROP TABLE IF EXISTS public.buildings_v2 CASCADE;
CREATE TABLE public.buildings_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Basic building data
    year_built integer NULL,
    square_footage integer NULL,
    finished_area integer NULL,
    unfinished_area integer NULL,
    bedrooms integer NULL,
    bathrooms numeric(3,1) NULL,
    half_baths integer NULL,
    stories numeric(2,1) NULL,
    condition_rating integer NULL, -- 1-10 scale
    
    -- Building type and use
    building_type text NULL, -- 'single_family', 'multi_family', etc.
    occupancy_type text NULL,
    best_use_id bigint REFERENCES public.property_uses_v2 (id),
    best_use_updated_at timestamptz NULL,
    best_use_reason text NULL,
    
    -- Construction details
    exterior_material text NULL,
    roof_type text NULL,
    foundation_type text NULL,
    heating_type text NULL,
    cooling_type text NULL,
    
    -- Additional features
    basement_area integer NULL,
    garage_area integer NULL,
    deck_area integer NULL,
    porch_area integer NULL,
    
    -- Flexible data for additional attributes
    building_data jsonb NOT NULL DEFAULT '{}',
    
    -- Tracking
    current_review_id bigint REFERENCES public.reviews_v2 (id),
    effective_date date NOT NULL DEFAULT current_date,
    created_at timestamptz NOT NULL DEFAULT now(),
    retired_at timestamptz NULL
);

CREATE INDEX buildings_v2_parcel_idx ON public.buildings_v2 (parcel_id);
CREATE INDEX buildings_v2_year_built_idx ON public.buildings_v2 (year_built);
CREATE INDEX buildings_v2_sqft_idx ON public.buildings_v2 (square_footage);
CREATE INDEX buildings_v2_data_gin_idx ON public.buildings_v2 USING gin (building_data);

-- ============================================================
-- LANDS (Parcel components)
-- ============================================================

DROP TABLE IF EXISTS public.lands_v2 CASCADE;
CREATE TABLE public.lands_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Land characteristics
    area_sqft integer NULL,
    frontage_ft integer NULL,
    depth_ft integer NULL,
    land_use text NULL, -- 'residential', 'commercial', etc.
    zoning text NULL,
    best_use_id bigint REFERENCES public.property_uses_v2 (id),
    best_use_updated_at timestamptz NULL,
    best_use_reason text NULL,
    
    -- Physical characteristics
    topography text NULL, -- 'level', 'sloped', 'irregular'
    utilities text[] NULL, -- Array of available utilities
    access_type text NULL, -- 'paved_road', 'gravel', etc.
    
    -- Environmental factors
    flood_zone text NULL,
    wetlands boolean DEFAULT false,
    
    -- Flexible data storage
    land_data jsonb NOT NULL DEFAULT '{}',
    
    -- Tracking
    current_review_id bigint REFERENCES public.reviews_v2 (id),
    effective_date date NOT NULL DEFAULT current_date,
    created_at timestamptz NOT NULL DEFAULT now(),
    retired_at timestamptz NULL
);

CREATE INDEX lands_v2_parcel_idx ON public.lands_v2 (parcel_id);
CREATE INDEX lands_v2_land_use_idx ON public.lands_v2 (land_use);
CREATE INDEX lands_v2_area_idx ON public.lands_v2 (area_sqft);
CREATE INDEX lands_v2_data_gin_idx ON public.lands_v2 USING gin (land_data);

-- ============================================================
-- MULTIPLE USE TRACKING (Junction Tables)
-- ============================================================

-- Building current uses (supports multiple concurrent uses)
DROP TABLE IF EXISTS public.building_current_uses_v2 CASCADE;
CREATE TABLE public.building_current_uses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    building_id bigint NOT NULL REFERENCES public.buildings_v2 (id) ON DELETE CASCADE,
    use_id bigint NOT NULL REFERENCES public.property_uses_v2 (id),
    percentage_allocation numeric(5,2) NULL, -- Percentage of building used for this purpose
    effective_date date NOT NULL DEFAULT current_date,
    retired_date date NULL,
    use_notes text NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    
    CONSTRAINT valid_percentage CHECK (percentage_allocation IS NULL OR (percentage_allocation >= 0 AND percentage_allocation <= 100)),
    CONSTRAINT valid_dates CHECK (retired_date IS NULL OR retired_date > effective_date),
    UNIQUE (building_id, use_id, effective_date)
);

CREATE INDEX building_current_uses_v2_building_idx ON public.building_current_uses_v2 (building_id);
CREATE INDEX building_current_uses_v2_use_idx ON public.building_current_uses_v2 (use_id);
CREATE INDEX building_current_uses_v2_effective_idx ON public.building_current_uses_v2 (effective_date);
CREATE INDEX building_current_uses_v2_active_idx ON public.building_current_uses_v2 (retired_date) WHERE retired_date IS NULL;

-- Land current uses (supports multiple concurrent uses)
DROP TABLE IF EXISTS public.land_current_uses_v2 CASCADE;
CREATE TABLE public.land_current_uses_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_id bigint NOT NULL REFERENCES public.lands_v2 (id) ON DELETE CASCADE,
    use_id bigint NOT NULL REFERENCES public.property_uses_v2 (id),
    percentage_allocation numeric(5,2) NULL, -- Percentage of land used for this purpose
    effective_date date NOT NULL DEFAULT current_date,
    retired_date date NULL,
    use_notes text NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    
    CONSTRAINT valid_percentage CHECK (percentage_allocation IS NULL OR (percentage_allocation >= 0 AND percentage_allocation <= 100)),
    CONSTRAINT valid_dates CHECK (retired_date IS NULL OR retired_date > effective_date),
    UNIQUE (land_id, use_id, effective_date)
);

CREATE INDEX land_current_uses_v2_land_idx ON public.land_current_uses_v2 (land_id);
CREATE INDEX land_current_uses_v2_use_idx ON public.land_current_uses_v2 (use_id);
CREATE INDEX land_current_uses_v2_effective_idx ON public.land_current_uses_v2 (effective_date);
CREATE INDEX land_current_uses_v2_active_idx ON public.land_current_uses_v2 (retired_date) WHERE retired_date IS NULL;

-- ============================================================
-- SALES (With building data at time of sale)
-- ============================================================

DROP TABLE IF EXISTS public.sales_v2 CASCADE;
CREATE TABLE public.sales_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- Sale information
    sale_date date NOT NULL,
    sale_price numeric(12,2) NOT NULL,
    sale_type text NOT NULL DEFAULT 'arms_length', -- 'arms_length', 'foreclosure', etc.
    grantor text NULL,
    grantee text NULL,
    
    -- Sale validity (determined through review)
    is_valid boolean NULL, -- NULL = under review, true/false = determined
    validity_reason text NULL,
    
    -- Building condition AT SALE (snapshot)
    building_condition_at_sale jsonb NULL, -- Store building data as it was at sale
    
    -- Market conditions
    market_conditions text NULL,
    financing_terms text NULL,
    
    -- Additional sale details
    sale_data jsonb NOT NULL DEFAULT '{}',
    
    -- Review tracking
    review_id bigint REFERENCES public.reviews_v2 (id),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX sales_v2_date_idx ON public.sales_v2 (sale_date DESC);
CREATE INDEX sales_v2_price_idx ON public.sales_v2 (sale_price);
CREATE INDEX sales_v2_valid_idx ON public.sales_v2 (is_valid);

-- ============================================================
-- SALES_PARCELS (Junction table for many-to-many relationship)
-- ============================================================

DROP TABLE IF EXISTS public.sales_parcels_v2 CASCADE;
CREATE TABLE public.sales_parcels_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sale_id bigint NOT NULL REFERENCES public.sales_v2 (id) ON DELETE CASCADE,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    -- Optional: portion of sale price allocated to this parcel
    allocated_price numeric(12,2) NULL,
    -- Optional: percentage of total sale this parcel represents
    percentage numeric(5,2) NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (sale_id, parcel_id)
);

CREATE INDEX sales_parcels_v2_sale_idx ON public.sales_parcels_v2 (sale_id);
CREATE INDEX sales_parcels_v2_parcel_idx ON public.sales_parcels_v2 (parcel_id);

-- ============================================================
-- PERMITS
-- ============================================================

DROP TABLE IF EXISTS public.permits_v2 CASCADE;
CREATE TABLE public.permits_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Permit details
    permit_number text NOT NULL,
    permit_type text NOT NULL, -- 'building', 'demolition', 'renovation', etc.
    issued_date date NULL,
    completed_date date NULL,
    permit_value numeric(12,2) NULL,
    
    -- Work description
    work_description text NULL,
    contractor_name text NULL,
    
    -- Impact on assessment
    affects_value boolean DEFAULT true,
    estimated_value_impact numeric(12,2) NULL,
    
    -- Additional permit data
    permit_data jsonb NOT NULL DEFAULT '{}',
    
    -- Review tracking
    review_id bigint REFERENCES public.reviews_v2 (id),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX permits_v2_parcel_idx ON public.permits_v2 (parcel_id);
CREATE INDEX permits_v2_number_idx ON public.permits_v2 (permit_number);
CREATE INDEX permits_v2_type_idx ON public.permits_v2 (permit_type);
CREATE INDEX permits_v2_date_idx ON public.permits_v2 (issued_date DESC);

-- ============================================================
-- APPEALS
-- ============================================================

DROP TABLE IF EXISTS public.appeals_v2 CASCADE;
CREATE TABLE public.appeals_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    
    -- Appeal information
    appeal_number text NOT NULL,
    filed_date date NOT NULL DEFAULT current_date,
    appeal_level text NOT NULL, -- 'informal', 'formal', 'board', 'court'
    
    -- Appellant information
    appellant_name text NOT NULL,
    appellant_address text NULL,
    appellant_phone text NULL,
    appellant_email text NULL,
    
    -- Appeal details
    current_assessment numeric(12,2) NULL,
    requested_assessment numeric(12,2) NULL,
    reason_for_appeal text NULL,
    
    -- Resolution
    final_assessment numeric(12,2) NULL,
    resolution_date date NULL,
    resolution_notes text NULL,
    
    -- Additional appeal data
    appeal_data jsonb NOT NULL DEFAULT '{}',
    
    -- Review tracking
    review_id bigint REFERENCES public.reviews_v2 (id),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX appeals_v2_parcel_idx ON public.appeals_v2 (parcel_id);
CREATE INDEX appeals_v2_number_idx ON public.appeals_v2 (appeal_number);
CREATE INDEX appeals_v2_filed_idx ON public.appeals_v2 (filed_date DESC);
CREATE INDEX appeals_v2_level_idx ON public.appeals_v2 (appeal_level);

-- ============================================================
-- VALUES (Building and Land Valuations)
-- ============================================================

-- Building values with multiple methods and scheduling
DROP TABLE IF EXISTS public.building_values_v2 CASCADE;
CREATE TABLE public.building_values_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    building_id bigint NOT NULL REFERENCES public.buildings_v2 (id) ON DELETE CASCADE,
    assessment_cycle_id bigint NOT NULL REFERENCES public.assessment_cycles_v2 (id),
    method_id bigint NOT NULL REFERENCES public.valuation_methods_v2 (id),
    
    -- Current use context for this valuation
    current_use_id bigint REFERENCES public.property_uses_v2 (id),
    best_use_id bigint REFERENCES public.property_uses_v2 (id),
    
    -- Scheduling and status
    scheduled_calculation_date date NOT NULL,
    calculation_trigger text NOT NULL DEFAULT 'manual' CHECK (calculation_trigger IN ('immediate', 'next_cycle', 'custom_date', 'manual')),
    status text NOT NULL DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'calculating', 'draft', 'pending_approval', 'approved', 'rejected')),
    
    -- Values and calculation
    total_value numeric(12,2) NULL,
    calculation_completed_at timestamptz NULL,
    approved_at timestamptz NULL,
    approved_by bigint REFERENCES public.employees_v2 (id),
    
    -- Activation
    is_active boolean DEFAULT false NOT NULL,
    activated_at timestamptz NULL,
    
    -- Change tracking
    triggered_by_changes jsonb DEFAULT '{}' NOT NULL, -- Track what changes prompted this valuation
    calculation_metadata jsonb DEFAULT '{}' NOT NULL, -- Method-specific calculation details
    approval_notes text NULL,
    
    -- Audit trail
    created_by uuid NOT NULL DEFAULT COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    
    UNIQUE (building_id, assessment_cycle_id, method_id, current_use_id),
    CONSTRAINT one_active_per_method CHECK (NOT is_active OR approved_at IS NOT NULL)
);

CREATE INDEX building_values_v2_building_idx ON public.building_values_v2 (building_id);
CREATE INDEX building_values_v2_cycle_idx ON public.building_values_v2 (assessment_cycle_id);
CREATE INDEX building_values_v2_method_idx ON public.building_values_v2 (method_id);
CREATE INDEX building_values_v2_status_idx ON public.building_values_v2 (status);
CREATE INDEX building_values_v2_active_idx ON public.building_values_v2 (is_active) WHERE is_active = true;
CREATE INDEX building_values_v2_scheduled_idx ON public.building_values_v2 (scheduled_calculation_date);
CREATE INDEX building_values_v2_metadata_gin_idx ON public.building_values_v2 USING gin (calculation_metadata);

-- Land values with multiple methods and scheduling
DROP TABLE IF EXISTS public.land_values_v2 CASCADE;
CREATE TABLE public.land_values_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_id bigint NOT NULL REFERENCES public.lands_v2 (id) ON DELETE CASCADE,
    assessment_cycle_id bigint NOT NULL REFERENCES public.assessment_cycles_v2 (id),
    method_id bigint NOT NULL REFERENCES public.valuation_methods_v2 (id),
    
    -- Current use context for this valuation
    current_use_id bigint REFERENCES public.property_uses_v2 (id),
    best_use_id bigint REFERENCES public.property_uses_v2 (id),
    
    -- Scheduling and status
    scheduled_calculation_date date NOT NULL,
    calculation_trigger text NOT NULL DEFAULT 'manual' CHECK (calculation_trigger IN ('immediate', 'next_cycle', 'custom_date', 'manual')),
    status text NOT NULL DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'calculating', 'draft', 'pending_approval', 'approved', 'rejected')),
    
    -- Values and calculation
    total_value numeric(12,2) NULL,
    calculation_completed_at timestamptz NULL,
    approved_at timestamptz NULL,
    approved_by bigint REFERENCES public.employees_v2 (id),
    
    -- Activation
    is_active boolean DEFAULT false NOT NULL,
    activated_at timestamptz NULL,
    
    -- Change tracking
    triggered_by_changes jsonb DEFAULT '{}' NOT NULL, -- Track what changes prompted this valuation
    calculation_metadata jsonb DEFAULT '{}' NOT NULL, -- Method-specific calculation details
    approval_notes text NULL,
    
    -- Audit trail
    created_by uuid NOT NULL DEFAULT COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    
    UNIQUE (land_id, assessment_cycle_id, method_id, current_use_id),
    CONSTRAINT one_active_per_method CHECK (NOT is_active OR approved_at IS NOT NULL)
);

CREATE INDEX land_values_v2_land_idx ON public.land_values_v2 (land_id);
CREATE INDEX land_values_v2_cycle_idx ON public.land_values_v2 (assessment_cycle_id);
CREATE INDEX land_values_v2_method_idx ON public.land_values_v2 (method_id);
CREATE INDEX land_values_v2_status_idx ON public.land_values_v2 (status);
CREATE INDEX land_values_v2_active_idx ON public.land_values_v2 (is_active) WHERE is_active = true;
CREATE INDEX land_values_v2_scheduled_idx ON public.land_values_v2 (scheduled_calculation_date);
CREATE INDEX land_values_v2_metadata_gin_idx ON public.land_values_v2 USING gin (calculation_metadata);

-- ============================================================
-- VALUE COMPONENTS AND ALLOCATIONS
-- ============================================================

-- Building value components breakdown
DROP TABLE IF EXISTS public.building_value_components_v2 CASCADE;
CREATE TABLE public.building_value_components_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    building_value_id bigint NOT NULL REFERENCES public.building_values_v2 (id) ON DELETE CASCADE,
    component_id bigint NOT NULL REFERENCES public.value_components_v2 (id),
    
    component_value numeric(12,2) NOT NULL,
    percentage_of_total numeric(5,2) NULL,
    calculation_notes text NULL,
    component_data jsonb DEFAULT '{}' NOT NULL, -- Component-specific details
    
    created_at timestamptz NOT NULL DEFAULT now(),
    
    UNIQUE (building_value_id, component_id)
);

CREATE INDEX building_value_components_v2_value_idx ON public.building_value_components_v2 (building_value_id);
CREATE INDEX building_value_components_v2_component_idx ON public.building_value_components_v2 (component_id);

-- Land value components breakdown  
DROP TABLE IF EXISTS public.land_value_components_v2 CASCADE;
CREATE TABLE public.land_value_components_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_value_id bigint NOT NULL REFERENCES public.land_values_v2 (id) ON DELETE CASCADE,
    component_id bigint NOT NULL REFERENCES public.value_components_v2 (id),
    
    component_value numeric(12,2) NOT NULL,
    percentage_of_total numeric(5,2) NULL,
    calculation_notes text NULL,
    component_data jsonb DEFAULT '{}' NOT NULL, -- Component-specific details
    
    created_at timestamptz NOT NULL DEFAULT now(),
    
    UNIQUE (land_value_id, component_id)
);

CREATE INDEX land_value_components_v2_value_idx ON public.land_value_components_v2 (land_value_id);
CREATE INDEX land_value_components_v2_component_idx ON public.land_value_components_v2 (component_id);

-- Value type allocations (for mixed-use properties)
DROP TABLE IF EXISTS public.value_type_allocations_v2 CASCADE;
CREATE TABLE public.value_type_allocations_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    value_id bigint NOT NULL, -- Can link to either building_values_v2 or land_values_v2
    value_table text NOT NULL CHECK (value_table IN ('building_values_v2', 'land_values_v2')),
    value_type_id bigint NOT NULL REFERENCES public.value_types_v2 (id),
    
    percentage_allocation numeric(5,2) NULL, -- Percentage-based allocation
    custom_value_override numeric(12,2) NULL, -- Custom value override
    allocation_notes text NULL,
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    
    CONSTRAINT allocation_method CHECK (
        (percentage_allocation IS NOT NULL AND custom_value_override IS NULL) OR
        (percentage_allocation IS NULL AND custom_value_override IS NOT NULL)
    ),
    CONSTRAINT valid_percentage CHECK (percentage_allocation IS NULL OR (percentage_allocation >= 0 AND percentage_allocation <= 100)),
    UNIQUE (value_id, value_table, value_type_id)
);

CREATE INDEX value_type_allocations_v2_value_idx ON public.value_type_allocations_v2 (value_id, value_table);
CREATE INDEX value_type_allocations_v2_type_idx ON public.value_type_allocations_v2 (value_type_id);

-- ============================================================
-- PARCEL SNAPSHOTS (Historical data tracking)
-- ============================================================

DROP TABLE IF EXISTS public.parcel_snapshots_v2 CASCADE;
CREATE TABLE public.parcel_snapshots_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parcel_id bigint NOT NULL REFERENCES public.parcels_v2 (id) ON DELETE CASCADE,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE RESTRICT,
    
    -- Snapshot of parcel data at this point in time
    snapshot_date date NOT NULL DEFAULT current_date,
    
    -- Copy of parcel fields at this time
    block integer,
    lot integer,
    ext integer,
    parcel_number text,
    tax_status_id bigint REFERENCES public.tax_statuses_v2 (id),
    property_class text,
    owner_name text,
    owner_address_id bigint REFERENCES public.addresses_v2 (id),
    site_address_id bigint REFERENCES public.addresses_v2 (id),
    neighborhood_id bigint REFERENCES public.neighborhoods_v2 (id),
    parcel_data jsonb NOT NULL DEFAULT '{}',
    
    created_at timestamptz NOT NULL DEFAULT now(),
    created_by uuid DEFAULT auth.uid()
);

CREATE INDEX parcel_snapshots_v2_parcel_date_idx ON public.parcel_snapshots_v2 (parcel_id, snapshot_date DESC);
CREATE INDEX parcel_snapshots_v2_review_idx ON public.parcel_snapshots_v2 (review_id);
CREATE INDEX parcel_snapshots_v2_date_idx ON public.parcel_snapshots_v2 (snapshot_date DESC);

-- ============================================================
-- BUILDING SNAPSHOTS (Historical building data)
-- ============================================================

DROP TABLE IF EXISTS public.building_snapshots_v2 CASCADE;
CREATE TABLE public.building_snapshots_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    building_id bigint NOT NULL REFERENCES public.buildings_v2 (id) ON DELETE CASCADE,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE RESTRICT,
    snapshot_date date NOT NULL DEFAULT current_date,
    
    -- Building data at this time
    year_built integer,
    square_footage integer,
    finished_area integer,
    bedrooms integer,
    bathrooms numeric(3,1),
    condition_rating integer CHECK (condition_rating BETWEEN 1 AND 10),
    building_type text,
    building_data jsonb NOT NULL DEFAULT '{}',
    
    -- Use tracking at snapshot time
    best_use_at_snapshot text, -- Use name at time of snapshot
    current_uses_at_snapshot jsonb DEFAULT '[]'::jsonb, -- Array of current uses with percentages
    
    -- Active values at snapshot time  
    active_values_at_snapshot jsonb DEFAULT '{}'::jsonb, -- Active value breakdown by method/type
    
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX building_snapshots_v2_building_date_idx ON public.building_snapshots_v2 (building_id, snapshot_date DESC);
CREATE INDEX building_snapshots_v2_review_idx ON public.building_snapshots_v2 (review_id);
CREATE INDEX building_snapshots_v2_date_idx ON public.building_snapshots_v2 (snapshot_date DESC);

-- ============================================================
-- LAND SNAPSHOTS (Historical land data)
-- ============================================================

DROP TABLE IF EXISTS public.land_snapshots_v2 CASCADE;
CREATE TABLE public.land_snapshots_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_id bigint NOT NULL REFERENCES public.lands_v2 (id) ON DELETE CASCADE,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE RESTRICT,
    snapshot_date date NOT NULL DEFAULT current_date,
    
    -- Land data at this time
    area_sqft integer,
    frontage_ft integer,
    depth_ft integer,
    land_use text,
    topography text,
    land_data jsonb NOT NULL DEFAULT '{}',
    
    -- Use tracking at snapshot time
    best_use_at_snapshot text, -- Use name at time of snapshot
    current_uses_at_snapshot jsonb DEFAULT '[]'::jsonb, -- Array of current uses with percentages
    
    -- Active values at snapshot time
    active_values_at_snapshot jsonb DEFAULT '{}'::jsonb, -- Active value breakdown by method/type
    
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX land_snapshots_v2_land_date_idx ON public.land_snapshots_v2 (land_id, snapshot_date DESC);
CREATE INDEX land_snapshots_v2_review_idx ON public.land_snapshots_v2 (review_id);
CREATE INDEX land_snapshots_v2_date_idx ON public.land_snapshots_v2 (snapshot_date DESC);

-- ============================================================
-- REVIEW HISTORY (Status changes)
-- ============================================================

DROP TABLE IF EXISTS public.review_history_v2 CASCADE;
CREATE TABLE public.review_history_v2 (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_id bigint NOT NULL REFERENCES public.reviews_v2 (id) ON DELETE CASCADE,
    status_id bigint NOT NULL REFERENCES public.review_statuses_v2 (id),
    note text NULL,
    changed_by uuid NOT NULL DEFAULT auth.uid(),
    changed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX review_history_v2_review_idx ON public.review_history_v2 (review_id, changed_at DESC);

-- ============================================================
-- AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-log status changes
DROP FUNCTION IF EXISTS log_review_status_change_v2();
CREATE OR REPLACE FUNCTION log_review_status_change_v2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF OLD.current_status_id IS DISTINCT FROM NEW.current_status_id THEN
        INSERT INTO public.review_history_v2 (review_id, status_id, note, changed_by)
        VALUES (
            NEW.id, 
            NEW.current_status_id, 
            'Status updated automatically',
            COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
        );
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS review_status_change_trigger_v2 ON public.reviews_v2;
CREATE TRIGGER review_status_change_trigger_v2
    AFTER UPDATE ON public.reviews_v2
    FOR EACH ROW 
    WHEN (OLD.current_status_id IS DISTINCT FROM NEW.current_status_id)
    EXECUTE FUNCTION log_review_status_change_v2();

-- Auto-update timestamps
DROP FUNCTION IF EXISTS update_timestamp_v2();
CREATE OR REPLACE FUNCTION update_timestamp_v2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS employees_timestamp_trigger_v2 ON public.employees_v2;
CREATE TRIGGER employees_timestamp_trigger_v2
    BEFORE UPDATE ON public.employees_v2
    FOR EACH ROW EXECUTE FUNCTION update_timestamp_v2();

-- ============================================================
-- MASS OPERATIONS FUNCTIONS
-- ============================================================

-- Mass create reviews
DROP FUNCTION IF EXISTS mass_create_reviews_v2(review_kind_v2, bigint[], text, date, jsonb);
CREATE OR REPLACE FUNCTION mass_create_reviews_v2(
    p_kind public.review_kind_v2,
    p_parcel_ids bigint[],
    p_title text DEFAULT NULL,
    p_due_date date DEFAULT NULL,
    p_data jsonb DEFAULT '{}'
)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    v_review_ids bigint[] := '{}';
    v_parcel_id bigint;
    v_review_id bigint;
    v_default_status_id bigint;
BEGIN
    -- Get default status for this review kind
    SELECT id INTO v_default_status_id
    FROM public.review_statuses_v2
    WHERE review_kind = p_kind
    ORDER BY sort_order ASC
    LIMIT 1;
    
    -- Create review for each parcel
    FOREACH v_parcel_id IN ARRAY p_parcel_ids
    LOOP
        INSERT INTO public.reviews_v2 (kind, title, due_date, current_status_id, data, created_by)
        VALUES (
            p_kind, 
            p_title, 
            p_due_date, 
            v_default_status_id, 
            p_data || jsonb_build_object('parcel_id', v_parcel_id),
            COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
        )
        RETURNING id INTO v_review_id;
        
        v_review_ids := v_review_ids || v_review_id;
    END LOOP;
    
    RETURN v_review_ids;
END;
$$;

-- Mass assign reviews
DROP FUNCTION IF EXISTS mass_assign_reviews_v2(bigint[], bigint);
CREATE OR REPLACE FUNCTION mass_assign_reviews_v2(
    p_review_ids bigint[],
    p_employee_id bigint
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.reviews_v2
    SET assigned_to_id = p_employee_id
    WHERE id = ANY(p_review_ids);
    
    RETURN true;
END;
$$;

-- Mass update review status
DROP FUNCTION IF EXISTS mass_update_review_status_v2(bigint[], text, text);
CREATE OR REPLACE FUNCTION mass_update_review_status_v2(
    p_review_ids bigint[],
    p_status_slug text,
    p_note text DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_status_id bigint;
    v_review_id bigint;
    v_kind public.review_kind_v2;
BEGIN
    -- Process each review
    FOREACH v_review_id IN ARRAY p_review_ids
    LOOP
        -- Get review kind
        SELECT kind INTO v_kind
        FROM public.reviews_v2
        WHERE id = v_review_id;
        
        -- Get status ID for this review kind
        SELECT id INTO v_status_id
        FROM public.review_statuses_v2
        WHERE review_kind = v_kind AND slug = p_status_slug;
        
        IF v_status_id IS NOT NULL THEN
            UPDATE public.reviews_v2
            SET current_status_id = v_status_id
            WHERE id = v_review_id;
            
            -- Add note if provided
            IF p_note IS NOT NULL THEN
                INSERT INTO public.review_history_v2 (review_id, status_id, note, changed_by)
                VALUES (
                    v_review_id, 
                    v_status_id, 
                    p_note,
                    COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
                );
            END IF;
        END IF;
    END LOOP;
    
    RETURN true;
END;
$$;

-- ============================================================
-- HISTORICAL QUERY FUNCTIONS
-- ============================================================

-- Get parcel data as of a specific date
DROP FUNCTION IF EXISTS get_parcel_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_parcel_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS TABLE (
    parcel_id bigint,
    block integer,
    lot integer,
    ext integer,
    parcel_number text,
    tax_status text,
    property_class text,
    owner_name text,
    owner_address text,
    site_address text,
    neighborhood text,
    snapshot_date date,
    parcel_data jsonb
)
LANGUAGE sql
STABLE
AS $$
    -- Get the most recent snapshot on or before the specified date
    SELECT 
        ps.parcel_id,
        ps.block,
        ps.lot,
        ps.ext,
        ps.parcel_number,
        ts.name as tax_status,
        ps.property_class,
        ps.owner_name,
        oa.street_address || COALESCE(', ' || oa.city, '') || COALESCE(', ' || oa.state, '') || COALESCE(' ' || oa.zip, '') as owner_address,
        sa.street_address || COALESCE(', ' || sa.city, '') || COALESCE(', ' || sa.state, '') || COALESCE(' ' || sa.zip, '') as site_address,
        n.name as neighborhood,
        ps.snapshot_date,
        ps.parcel_data
    FROM public.parcel_snapshots_v2 ps
    LEFT JOIN public.tax_statuses_v2 ts ON ps.tax_status_id = ts.id
    LEFT JOIN public.addresses_v2 oa ON ps.owner_address_id = oa.id
    LEFT JOIN public.addresses_v2 sa ON ps.site_address_id = sa.id
    LEFT JOIN public.neighborhoods_v2 n ON ps.neighborhood_id = n.id
    WHERE ps.parcel_id = p_parcel_id 
      AND ps.snapshot_date <= p_as_of_date
    ORDER BY ps.snapshot_date DESC
    LIMIT 1;
$$;

-- Get buildings as of a specific date
DROP FUNCTION IF EXISTS get_buildings_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_buildings_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS TABLE (
    building_id bigint,
    year_built integer,
    square_footage integer,
    finished_area integer,
    bedrooms integer,
    bathrooms numeric(3,1),
    condition_rating integer,
    building_type text,
    snapshot_date date,
    building_data jsonb
)
LANGUAGE sql
STABLE
AS $$
    SELECT DISTINCT ON (b.id)
        bs.building_id,
        bs.year_built,
        bs.square_footage,
        bs.finished_area,
        bs.bedrooms,
        bs.bathrooms,
        bs.condition_rating,
        bs.building_type,
        bs.snapshot_date,
        bs.building_data
    FROM public.buildings_v2 b
    JOIN public.building_snapshots_v2 bs ON b.id = bs.building_id
    WHERE b.parcel_id = p_parcel_id
      AND bs.snapshot_date <= p_as_of_date
      AND (b.retired_at IS NULL OR b.retired_at > p_as_of_date)
    ORDER BY b.id, bs.snapshot_date DESC;
$$;

-- Get land data as of a specific date
DROP FUNCTION IF EXISTS get_land_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_land_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS TABLE (
    land_id bigint,
    area_sqft integer,
    frontage_ft integer,
    depth_ft integer,
    land_use text,
    topography text,
    snapshot_date date,
    land_data jsonb
)
LANGUAGE sql
STABLE
AS $$
    SELECT DISTINCT ON (l.id)
        ls.land_id,
        ls.area_sqft,
        ls.frontage_ft,
        ls.depth_ft,
        ls.land_use,
        ls.topography,
        ls.snapshot_date,
        ls.land_data
    FROM public.lands_v2 l
    JOIN public.land_snapshots_v2 ls ON l.id = ls.land_id
    WHERE l.parcel_id = p_parcel_id
      AND ls.snapshot_date <= p_as_of_date
      AND (l.retired_at IS NULL OR l.retired_at > p_as_of_date)
    ORDER BY l.id, ls.snapshot_date DESC;
$$;

-- Get complete parcel with all components as of date
DROP FUNCTION IF EXISTS get_complete_parcel_as_of_date_v2(bigint, date);
CREATE OR REPLACE FUNCTION get_complete_parcel_as_of_date_v2(
    p_parcel_id bigint,
    p_as_of_date date
)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_result jsonb := '{}';
    v_parcel record;
    v_buildings jsonb := '[]';
    v_lands jsonb := '[]';
BEGIN
    -- Get parcel data
    SELECT * INTO v_parcel
    FROM get_parcel_as_of_date_v2(p_parcel_id, p_as_of_date);
    
    IF v_parcel.parcel_id IS NOT NULL THEN
        v_result := jsonb_build_object(
            'parcel', row_to_json(v_parcel),
            'buildings', (
                SELECT jsonb_agg(row_to_json(b))
                FROM get_buildings_as_of_date_v2(p_parcel_id, p_as_of_date) b
            ),
            'lands', (
                SELECT jsonb_agg(row_to_json(l))
                FROM get_land_as_of_date_v2(p_parcel_id, p_as_of_date) l
            )
        );
    END IF;
    
    RETURN v_result;
END;
$$;

-- Get parcel change timeline
DROP FUNCTION IF EXISTS get_parcel_timeline_v2(bigint, date, date);
CREATE OR REPLACE FUNCTION get_parcel_timeline_v2(
    p_parcel_id bigint,
    p_start_date date DEFAULT '1900-01-01',
    p_end_date date DEFAULT current_date
)
RETURNS TABLE (
    snapshot_date date,
    review_id bigint,
    owner_name text,
    tax_status text,
    property_class text,
    changes jsonb
)
LANGUAGE sql
STABLE
AS $$
    SELECT 
        ps.snapshot_date,
        ps.review_id,
        ps.owner_name,
        ts.name as tax_status,
        ps.property_class,
        ps.parcel_data AS changes
    FROM public.parcel_snapshots_v2 ps
    LEFT JOIN public.tax_statuses_v2 ts ON ps.tax_status_id = ts.id
    WHERE ps.parcel_id = p_parcel_id
      AND ps.snapshot_date BETWEEN p_start_date AND p_end_date
    ORDER BY ps.snapshot_date DESC;
$$;

-- ============================================================
-- SNAPSHOT AUTOMATION FUNCTIONS
-- ============================================================

-- Auto-create snapshots when reviews are completed
DROP FUNCTION IF EXISTS create_snapshots_on_review_completion_v2();
CREATE OR REPLACE FUNCTION create_snapshots_on_review_completion_v2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_parcel_id bigint;
    v_building_id bigint;
    v_land_id bigint;
    v_best_use_name text;
    v_current_uses jsonb;
    v_active_values jsonb;
BEGIN
    -- Only create snapshots when review is marked as completed
    IF OLD.completed_at IS NULL AND NEW.completed_at IS NOT NULL THEN
        
        -- Get parcel ID from review data
        v_parcel_id := (NEW.data->>'parcel_id')::bigint;
        
        IF v_parcel_id IS NOT NULL THEN
            -- Create parcel snapshot
            INSERT INTO public.parcel_snapshots_v2 (
                parcel_id, review_id, snapshot_date, block, lot, ext, parcel_number,
                tax_status_id, property_class, owner_name, owner_address_id, 
                site_address_id, neighborhood_id, parcel_data
            )
            SELECT 
                p.id, NEW.id, current_date, p.block, p.lot, p.ext, p.parcel_number,
                p.tax_status_id, p.property_class, p.owner_name, p.owner_address_id,
                p.site_address_id, p.neighborhood_id, p.parcel_data
            FROM public.parcels_v2 p
            WHERE p.id = v_parcel_id;
            
            -- Create building snapshots for all active buildings on this parcel
            FOR v_building_id IN 
                SELECT id FROM public.buildings_v2 
                WHERE parcel_id = v_parcel_id AND retired_at IS NULL
            LOOP
                -- Get best use name
                SELECT pu.name INTO v_best_use_name
                FROM public.buildings_v2 b
                LEFT JOIN public.property_uses_v2 pu ON b.best_use_id = pu.id
                WHERE b.id = v_building_id;
                
                -- Get current uses array
                SELECT json_agg(
                    json_build_object(
                        'use_name', pu.name,
                        'percentage', bcu.percentage_allocation,
                        'effective_date', bcu.effective_date
                    )
                ) INTO v_current_uses
                FROM public.building_current_uses_v2 bcu
                LEFT JOIN public.property_uses_v2 pu ON bcu.use_id = pu.id
                WHERE bcu.building_id = v_building_id 
                  AND bcu.retired_date IS NULL;
                
                -- Get active values
                SELECT json_build_object(
                    'methods', json_agg(
                        json_build_object(
                            'method_name', vm.name,
                            'total_value', bv.total_value,
                            'approved_at', bv.approved_at,
                            'value_types', (
                                SELECT json_agg(
                                    json_build_object(
                                        'type_name', vt.name,
                                        'allocation', COALESCE(vta.percentage_allocation, 0),
                                        'custom_value', vta.custom_value_override
                                    )
                                )
                                FROM public.value_type_allocations_v2 vta
                                LEFT JOIN public.value_types_v2 vt ON vta.value_type_id = vt.id
                                WHERE vta.value_id = bv.id AND vta.value_table = 'building_values_v2'
                            )
                        )
                    )
                ) INTO v_active_values
                FROM public.building_values_v2 bv
                LEFT JOIN public.valuation_methods_v2 vm ON bv.method_id = vm.id
                WHERE bv.building_id = v_building_id AND bv.is_active = true;
                
                -- Insert building snapshot with use and value data
                INSERT INTO public.building_snapshots_v2 (
                    building_id, review_id, snapshot_date, year_built, square_footage,
                    finished_area, bedrooms, bathrooms, condition_rating, 
                    building_type, building_data,
                    best_use_at_snapshot, current_uses_at_snapshot, active_values_at_snapshot
                )
                SELECT 
                    b.id, NEW.id, current_date, b.year_built, b.square_footage,
                    b.finished_area, b.bedrooms, b.bathrooms, b.condition_rating,
                    b.building_type, b.building_data,
                    v_best_use_name, COALESCE(v_current_uses, '[]'::jsonb), COALESCE(v_active_values, '{}'::jsonb)
                FROM public.buildings_v2 b
                WHERE b.id = v_building_id;
            END LOOP;
            
            -- Create land snapshots for all active land records on this parcel
            FOR v_land_id IN 
                SELECT id FROM public.lands_v2 
                WHERE parcel_id = v_parcel_id AND retired_at IS NULL
            LOOP
                -- Get best use name
                SELECT pu.name INTO v_best_use_name
                FROM public.lands_v2 l
                LEFT JOIN public.property_uses_v2 pu ON l.best_use_id = pu.id
                WHERE l.id = v_land_id;
                
                -- Get current uses array
                SELECT json_agg(
                    json_build_object(
                        'use_name', pu.name,
                        'percentage', lcu.percentage_allocation,
                        'effective_date', lcu.effective_date
                    )
                ) INTO v_current_uses
                FROM public.land_current_uses_v2 lcu
                LEFT JOIN public.property_uses_v2 pu ON lcu.use_id = pu.id
                WHERE lcu.land_id = v_land_id 
                  AND lcu.retired_date IS NULL;
                
                -- Get active values
                SELECT json_build_object(
                    'methods', json_agg(
                        json_build_object(
                            'method_name', vm.name,
                            'total_value', lv.total_value,
                            'approved_at', lv.approved_at,
                            'value_types', (
                                SELECT json_agg(
                                    json_build_object(
                                        'type_name', vt.name,
                                        'allocation', COALESCE(vta.percentage_allocation, 0),
                                        'custom_value', vta.custom_value_override
                                    )
                                )
                                FROM public.value_type_allocations_v2 vta
                                LEFT JOIN public.value_types_v2 vt ON vta.value_type_id = vt.id
                                WHERE vta.value_id = lv.id AND vta.value_table = 'land_values_v2'
                            )
                        )
                    )
                ) INTO v_active_values
                FROM public.land_values_v2 lv
                LEFT JOIN public.valuation_methods_v2 vm ON lv.method_id = vm.id
                WHERE lv.land_id = v_land_id AND lv.is_active = true;
                
                -- Insert land snapshot with use and value data
                INSERT INTO public.land_snapshots_v2 (
                    land_id, review_id, snapshot_date, area_sqft, frontage_ft,
                    depth_ft, land_use, topography, land_data,
                    best_use_at_snapshot, current_uses_at_snapshot, active_values_at_snapshot
                )
                SELECT 
                    l.id, NEW.id, current_date, l.area_sqft, l.frontage_ft,
                    l.depth_ft, l.land_use, l.topography, l.land_data,
                    v_best_use_name, COALESCE(v_current_uses, '[]'::jsonb), COALESCE(v_active_values, '{}'::jsonb)
                FROM public.lands_v2 l
                WHERE l.id = v_land_id;
            END LOOP;
        END IF;
        
        -- Handle specific entity snapshots based on review kind
        CASE NEW.kind
            WHEN 'building_review', 'building_valuation', 'use_conversion' THEN
                v_building_id := (NEW.data->>'building_id')::bigint;
                IF v_building_id IS NOT NULL THEN
                    -- Get use and value data for building
                    SELECT pu.name INTO v_best_use_name
                    FROM public.buildings_v2 b
                    LEFT JOIN public.property_uses_v2 pu ON b.best_use_id = pu.id
                    WHERE b.id = v_building_id;
                    
                    -- Build current uses and active values as above
                    -- (Implementation similar to parcel-level logic)
                END IF;
                
            WHEN 'land_review', 'land_valuation' THEN
                v_land_id := (NEW.data->>'land_id')::bigint;
                IF v_land_id IS NOT NULL THEN
                    -- Get use and value data for land
                    SELECT pu.name INTO v_best_use_name
                    FROM public.lands_v2 l
                    LEFT JOIN public.property_uses_v2 pu ON l.best_use_id = pu.id
                    WHERE l.id = v_land_id;
                    
                    -- Build current uses and active values as above
                    -- (Implementation similar to parcel-level logic)
                END IF;
                
            ELSE
                -- Default case handled above with parcel-level snapshots
                NULL;
        END CASE;
    END IF;
    
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS create_snapshots_trigger_v2 ON public.reviews_v2;
CREATE TRIGGER create_snapshots_trigger_v2
    AFTER UPDATE ON public.reviews_v2
    FOR EACH ROW
    EXECUTE FUNCTION create_snapshots_on_review_completion_v2();

-- ============================================================
-- UTILITY FUNCTIONS
-- ============================================================

-- Get employee permissions
DROP FUNCTION IF EXISTS get_employee_permissions_v2(uuid);
CREATE OR REPLACE FUNCTION get_employee_permissions_v2(p_user_id uuid)
RETURNS TABLE (
    employee_id bigint,
    full_name text,
    can_approve boolean
)
LANGUAGE sql
STABLE
AS $$
    SELECT 
        e.id,
        e.first_name || ' ' || e.last_name,
        e.can_approve
    FROM public.employees_v2 e
    WHERE e.user_id = p_user_id 
      AND e.status = 'active';
$$;

-- Get parcel summary with current reviews
DROP FUNCTION IF EXISTS get_parcel_summary_v2(bigint);
CREATE OR REPLACE FUNCTION get_parcel_summary_v2(p_parcel_id bigint)
RETURNS TABLE (
    parcel_id bigint,
    parcel_number text,
    site_address text,
    owner_name text,
    building_count bigint,
    land_count bigint,
    current_review_kind public.review_kind_v2,
    current_review_status text,
    last_sale_date date,
    last_sale_price numeric
)
LANGUAGE sql
STABLE
AS $$
    SELECT 
        p.id,
        p.parcel_number,
        sa.street_address || COALESCE(', ' || sa.city, '') || COALESCE(', ' || sa.state, '') || COALESCE(' ' || sa.zip, '') as site_address,
        p.owner_name,
        (SELECT COUNT(*) FROM public.buildings_v2 b WHERE b.parcel_id = p.id AND b.retired_at IS NULL),
        (SELECT COUNT(*) FROM public.lands_v2 l WHERE l.parcel_id = p.id AND l.retired_at IS NULL),
        r.kind,
        rs.name,
        s.sale_date,
        s.sale_price
    FROM public.parcels_v2 p
    LEFT JOIN public.addresses_v2 sa ON p.site_address_id = sa.id
    LEFT JOIN public.reviews_v2 r ON p.current_review_id = r.id
    LEFT JOIN public.review_statuses_v2 rs ON r.current_status_id = rs.id
    LEFT JOIN LATERAL (
        SELECT sp.sale_id, s.sale_date, s.sale_price
        FROM public.sales_parcels_v2 sp
        JOIN public.sales_v2 s ON sp.sale_id = s.id
        WHERE sp.parcel_id = p.id 
        ORDER BY s.sale_date DESC 
        LIMIT 1
    ) s ON true
    WHERE p.id = p_parcel_id;
$$;

-- ============================================================
-- VIEWS
-- ============================================================

-- Active reviews summary
DROP VIEW IF EXISTS active_reviews_v2;
CREATE VIEW active_reviews_v2 AS
SELECT 
    r.id,
    r.kind,
    r.title,
    r.due_date,
    rs.name as status_name,
    rs.needs_approval,
    e.first_name || ' ' || e.last_name as assigned_to,
    r.created_at,
    (COALESCE(r.due_date, CURRENT_DATE) - CURRENT_DATE) as days_until_due
FROM public.reviews_v2 r
LEFT JOIN public.review_statuses_v2 rs ON r.current_status_id = rs.id
LEFT JOIN public.employees_v2 e ON r.assigned_to_id = e.id
WHERE r.completed_at IS NULL;

-- Parcel overview
DROP VIEW IF EXISTS parcel_overview_v2;
CREATE VIEW parcel_overview_v2 AS
SELECT 
    p.id,
    p.block,
    p.lot, 
    p.ext,
    p.parcel_number,
    sa.street_address || COALESCE(', ' || sa.city, '') || COALESCE(', ' || sa.state, '') || COALESCE(' ' || sa.zip, '') as site_address,
    p.owner_name,
    n.name as neighborhood,
    ts.name as tax_status,
    COUNT(DISTINCT b.id) as building_count,
    COUNT(DISTINCT l.id) as land_count,
    COUNT(DISTINCT sp.sale_id) as sale_count,
    MAX(s.sale_date) as last_sale_date,
    r.kind as current_review_kind,
    rs.name as current_review_status
FROM public.parcels_v2 p
LEFT JOIN public.addresses_v2 sa ON p.site_address_id = sa.id
LEFT JOIN public.neighborhoods_v2 n ON p.neighborhood_id = n.id
LEFT JOIN public.tax_statuses_v2 ts ON p.tax_status_id = ts.id
LEFT JOIN public.buildings_v2 b ON p.id = b.parcel_id AND b.retired_at IS NULL
LEFT JOIN public.lands_v2 l ON p.id = l.parcel_id AND l.retired_at IS NULL
LEFT JOIN public.sales_parcels_v2 sp ON p.id = sp.parcel_id
LEFT JOIN public.sales_v2 s ON sp.sale_id = s.id
LEFT JOIN public.reviews_v2 r ON p.current_review_id = r.id
LEFT JOIN public.review_statuses_v2 rs ON r.current_status_id = rs.id
GROUP BY p.id, p.block, p.lot, p.ext, p.parcel_number, sa.street_address, sa.city, sa.state, sa.zip, 
         p.owner_name, n.name, ts.name, r.kind, rs.name;

-- ============================================================
-- VALUE MANAGEMENT FUNCTIONS
-- ============================================================

-- Schedule value recalculation for building or land
CREATE OR REPLACE FUNCTION schedule_value_recalculation_v2(
    p_entity_type text, -- 'building' or 'land'
    p_entity_id bigint,
    p_assessment_cycle_id bigint,
    p_trigger_type text DEFAULT 'manual', -- 'immediate', 'next_cycle', 'custom_date', 'manual'
    p_scheduled_date date DEFAULT NULL,
    p_triggered_by_changes jsonb DEFAULT '{}'::jsonb
)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    method_ids bigint[];
    value_ids bigint[];
    method_id bigint;
    new_value_id bigint;
    calc_date date;
BEGIN
    -- Determine calculation date
    calc_date := CASE 
        WHEN p_trigger_type = 'immediate' THEN CURRENT_DATE
        WHEN p_trigger_type = 'next_cycle' THEN (
            SELECT start_date FROM public.assessment_cycles_v2 
            WHERE id = p_assessment_cycle_id
        )
        WHEN p_trigger_type = 'custom_date' THEN p_scheduled_date
        ELSE CURRENT_DATE
    END;
    
    -- Get all active valuation methods
    SELECT array_agg(id) INTO method_ids 
    FROM public.valuation_methods_v2 
    WHERE is_active = true;
    
    value_ids := ARRAY[]::bigint[];
    
    -- Create value records for each method
    FOREACH method_id IN ARRAY method_ids
    LOOP
        IF p_entity_type = 'building' THEN
            INSERT INTO public.building_values_v2 (
                building_id, assessment_cycle_id, method_id,
                scheduled_calculation_date, calculation_trigger,
                triggered_by_changes, created_by
            ) VALUES (
                p_entity_id, p_assessment_cycle_id, method_id,
                calc_date, p_trigger_type,
                p_triggered_by_changes, 
                COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
            )
            ON CONFLICT (building_id, assessment_cycle_id, method_id, current_use_id) 
            DO UPDATE SET 
                scheduled_calculation_date = calc_date,
                calculation_trigger = p_trigger_type,
                triggered_by_changes = p_triggered_by_changes,
                updated_at = now()
            RETURNING id INTO new_value_id;
        ELSE
            INSERT INTO public.land_values_v2 (
                land_id, assessment_cycle_id, method_id,
                scheduled_calculation_date, calculation_trigger,
                triggered_by_changes, created_by
            ) VALUES (
                p_entity_id, p_assessment_cycle_id, method_id,
                calc_date, p_trigger_type,
                p_triggered_by_changes,
                COALESCE(auth.uid(), '4be94f1c-078e-4810-8b6c-f2800a3c02f8'::uuid)
            )
            ON CONFLICT (land_id, assessment_cycle_id, method_id, current_use_id) 
            DO UPDATE SET 
                scheduled_calculation_date = calc_date,
                calculation_trigger = p_trigger_type,
                triggered_by_changes = p_triggered_by_changes,
                updated_at = now()
            RETURNING id INTO new_value_id;
        END IF;
        
        value_ids := array_append(value_ids, new_value_id);
    END LOOP;
    
    RETURN value_ids;
END;
$$;

-- Approve value calculation and activate if specified
CREATE OR REPLACE FUNCTION approve_value_calculation_v2(
    p_value_ids bigint[],
    p_entity_type text, -- 'building' or 'land'
    p_approve boolean DEFAULT true,
    p_activate boolean DEFAULT false,
    p_approval_notes text DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    value_id bigint;
    employee_id bigint;
BEGIN
    -- Get approving employee
    SELECT id INTO employee_id 
    FROM public.employees_v2 
    WHERE user_id = auth.uid() AND can_approve = true
    LIMIT 1;
    
    IF employee_id IS NULL THEN
        RAISE EXCEPTION 'User does not have approval permissions';
    END IF;
    
    FOREACH value_id IN ARRAY p_value_ids
    LOOP
        IF p_entity_type = 'building' THEN
            UPDATE public.building_values_v2 
            SET 
                status = CASE WHEN p_approve THEN 'approved' ELSE 'rejected' END,
                approved_at = CASE WHEN p_approve THEN now() ELSE NULL END,
                approved_by = CASE WHEN p_approve THEN employee_id ELSE NULL END,
                is_active = CASE WHEN p_approve AND p_activate THEN true ELSE false END,
                activated_at = CASE WHEN p_approve AND p_activate THEN now() ELSE NULL END,
                approval_notes = p_approval_notes,
                updated_at = now()
            WHERE id = value_id;
            
            -- Deactivate other values for same building/method if activating
            IF p_approve AND p_activate THEN
                UPDATE public.building_values_v2 
                SET is_active = false, activated_at = NULL
                WHERE building_id = (SELECT building_id FROM public.building_values_v2 WHERE id = value_id)
                  AND method_id = (SELECT method_id FROM public.building_values_v2 WHERE id = value_id)
                  AND id != value_id;
            END IF;
        ELSE
            UPDATE public.land_values_v2 
            SET 
                status = CASE WHEN p_approve THEN 'approved' ELSE 'rejected' END,
                approved_at = CASE WHEN p_approve THEN now() ELSE NULL END,
                approved_by = CASE WHEN p_approve THEN employee_id ELSE NULL END,
                is_active = CASE WHEN p_approve AND p_activate THEN true ELSE false END,
                activated_at = CASE WHEN p_approve AND p_activate THEN now() ELSE NULL END,
                approval_notes = p_approval_notes,
                updated_at = now()
            WHERE id = value_id;
            
            -- Deactivate other values for same land/method if activating
            IF p_approve AND p_activate THEN
                UPDATE public.land_values_v2 
                SET is_active = false, activated_at = NULL
                WHERE land_id = (SELECT land_id FROM public.land_values_v2 WHERE id = value_id)
                  AND method_id = (SELECT method_id FROM public.land_values_v2 WHERE id = value_id)
                  AND id != value_id;
            END IF;
        END IF;
    END LOOP;
END;
$$;

-- Get current active values for a parcel
CREATE OR REPLACE FUNCTION get_parcel_current_values_v2(p_parcel_id bigint)
RETURNS TABLE (
    entity_type text,
    entity_id bigint,
    method_name text,
    value_type_name text,
    total_value numeric,
    calculation_date timestamptz,
    approved_date timestamptz
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    -- Building values
    SELECT 
        'building'::text as entity_type,
        bv.building_id as entity_id,
        vm.name as method_name,
        COALESCE(vt.name, 'Mixed Use') as value_type_name,
        bv.total_value,
        bv.calculation_completed_at as calculation_date,
        bv.approved_at as approved_date
    FROM public.building_values_v2 bv
    JOIN public.buildings_v2 b ON bv.building_id = b.id
    JOIN public.valuation_methods_v2 vm ON bv.method_id = vm.id
    LEFT JOIN public.value_type_allocations_v2 vta ON vta.value_id = bv.id AND vta.value_table = 'building_values_v2'
    LEFT JOIN public.value_types_v2 vt ON vta.value_type_id = vt.id
    WHERE b.parcel_id = p_parcel_id 
      AND bv.is_active = true
      AND b.retired_at IS NULL
    
    UNION ALL
    
    -- Land values
    SELECT 
        'land'::text as entity_type,
        lv.land_id as entity_id,
        vm.name as method_name,
        COALESCE(vt.name, 'Mixed Use') as value_type_name,
        lv.total_value,
        lv.calculation_completed_at as calculation_date,
        lv.approved_at as approved_date
    FROM public.land_values_v2 lv
    JOIN public.lands_v2 l ON lv.land_id = l.id
    JOIN public.valuation_methods_v2 vm ON lv.method_id = vm.id
    LEFT JOIN public.value_type_allocations_v2 vta ON vta.value_id = lv.id AND vta.value_table = 'land_values_v2'
    LEFT JOIN public.value_types_v2 vt ON vta.value_type_id = vt.id
    WHERE l.parcel_id = p_parcel_id 
      AND lv.is_active = true
      AND l.retired_at IS NULL
    
    ORDER BY entity_type, method_name, value_type_name;
END;
$$;

-- Detect changes that require value recalculation
CREATE OR REPLACE FUNCTION detect_value_triggering_changes_v2(
    p_entity_type text, -- 'building' or 'land'
    p_old_data jsonb,
    p_new_data jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    changes jsonb := '{}'::jsonb;
    triggering_fields text[];
BEGIN
    -- Define fields that trigger value recalculation
    IF p_entity_type = 'building' THEN
        triggering_fields := ARRAY[
            'square_footage', 'finished_area', 'unfinished_area',
            'condition_rating', 'year_built', 'stories',
            'basement_area', 'garage_area', 'deck_area', 'porch_area'
        ];
    ELSE -- land
        triggering_fields := ARRAY[
            'area_sqft', 'frontage_ft', 'depth_ft',
            'land_use', 'zoning', 'topography', 'flood_zone'
        ];
    END IF;
    
    -- Check each triggering field for changes
    FOR i IN 1..array_length(triggering_fields, 1)
    LOOP
        IF (p_old_data->>triggering_fields[i]) IS DISTINCT FROM (p_new_data->>triggering_fields[i]) THEN
            changes := changes || jsonb_build_object(
                triggering_fields[i], 
                jsonb_build_object(
                    'old_value', p_old_data->>triggering_fields[i],
                    'new_value', p_new_data->>triggering_fields[i],
                    'changed_at', extract(epoch from now())
                )
            );
        END IF;
    END LOOP;
    
    RETURN changes;
END;
$$;

-- ============================================================
-- COMPREHENSIVE PARCEL SEARCH FUNCTION
-- ============================================================

-- Main parcel search function with filtering, sorting, and pagination
DROP FUNCTION search_parcels_v2(date,jsonb,text,text,integer,integer);
CREATE OR REPLACE FUNCTION search_parcels_v2(
    p_as_of_date date DEFAULT CURRENT_DATE,
    p_filters jsonb DEFAULT '{}'::jsonb,
    p_sort_by text DEFAULT 'parcel_number',
    p_sort_direction text DEFAULT 'ASC',
    p_limit integer DEFAULT 50,
    p_offset integer DEFAULT 0
)
RETURNS TABLE (
    total_count bigint,
    parcel_id bigint,
    block integer,
    lot integer,
    ext integer,
    parcel_number text,
    owner_name text,
    property_class text,
    site_address text,
    neighborhood_name text,
    tax_status_name text,
    total_buildings integer,
    current_building_value numeric,
    current_land_value numeric,
    total_property_value numeric,
    parcel_data jsonb,
    building_summary jsonb,
    value_summary jsonb
)
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    base_query text;
    where_conditions text[];
    count_query text;
    total_rows bigint;
BEGIN
    -- Build optimized query with early filtering
    base_query := '
    WITH filtered_parcels AS (
        SELECT DISTINCT ON (p.id)
            p.id,
            COALESCE(ps.block, p.block) as block,
            COALESCE(ps.lot, p.lot) as lot,
            COALESCE(ps.ext, p.ext) as ext,
            COALESCE(ps.parcel_number, p.parcel_number) as parcel_number,
            COALESCE(ps.owner_name, p.owner_name) as owner_name,
            COALESCE(ps.property_class, p.property_class) as property_class,
            p.site_address_id,
            p.neighborhood_id,
            p.tax_status_id,
            COALESCE(ps.parcel_data, p.parcel_data) as parcel_data,
            ps.snapshot_date
        FROM public.parcels_v2 p
        LEFT JOIN public.parcel_snapshots_v2 ps ON p.id = ps.parcel_id 
            AND ps.snapshot_date <= $1
        WHERE 1=1';

    -- Build WHERE conditions for early filtering
    where_conditions := ARRAY[]::text[];

    -- Apply basic parcel filters early
    IF p_filters ? 'parcel_number' THEN
        where_conditions := where_conditions || ('COALESCE(ps.parcel_number, p.parcel_number) ILIKE ''%' || (p_filters->>'parcel_number') || '%''');
    END IF;
    
    IF p_filters ? 'owner_name' THEN
        where_conditions := where_conditions || ('COALESCE(ps.owner_name, p.owner_name) ILIKE ''%' || (p_filters->>'owner_name') || '%''');
    END IF;
    
    IF p_filters ? 'property_class' THEN
        where_conditions := where_conditions || ('COALESCE(ps.property_class, p.property_class) = ''' || (p_filters->>'property_class') || '''');
    END IF;
    
    IF p_filters ? 'neighborhood_id' THEN
        where_conditions := where_conditions || ('p.neighborhood_id = ' || (p_filters->>'neighborhood_id'));
    END IF;
    
    IF p_filters ? 'block' THEN
        where_conditions := where_conditions || ('COALESCE(ps.block, p.block) = ' || (p_filters->>'block'));
    END IF;

    -- Add early filtering conditions
    IF array_length(where_conditions, 1) > 0 THEN
        base_query := base_query || ' AND ' || array_to_string(where_conditions, ' AND ');
    END IF;

    base_query := base_query || '
        ORDER BY p.id, ps.snapshot_date DESC NULLS LAST
    ),
    building_agg AS (
        SELECT 
            fp.id as parcel_id,
            COUNT(b.id)::integer as total_buildings,
            SUM(COALESCE(bv.total_value, 0)) as current_building_value
        FROM filtered_parcels fp
        LEFT JOIN public.buildings_v2 b ON fp.id = b.parcel_id AND b.retired_at IS NULL
        LEFT JOIN public.building_values_v2 bv ON b.id = bv.building_id AND bv.is_active = true
        GROUP BY fp.id
    ),
    land_agg AS (
        SELECT 
            fp.id as parcel_id,
            SUM(COALESCE(lv.total_value, 0)) as current_land_value
        FROM filtered_parcels fp
        LEFT JOIN public.lands_v2 l ON fp.id = l.parcel_id AND l.retired_at IS NULL
        LEFT JOIN public.land_values_v2 lv ON l.id = lv.land_id AND lv.is_active = true
        GROUP BY fp.id
    )
    SELECT 
        $2::bigint as total_count,
        fp.id,
        fp.block,
        fp.lot,
        fp.ext,
        fp.parcel_number,
        fp.owner_name,
        fp.property_class,
        COALESCE(sa.street_address, '''') || COALESCE('', '' || sa.city, '''') || COALESCE('', '' || sa.state, '''') as site_address,
        n.name as neighborhood_name,
        ts.name as tax_status_name,
        COALESCE(ba.total_buildings, 0) as total_buildings,
        COALESCE(ba.current_building_value, 0) as current_building_value,
        COALESCE(la.current_land_value, 0) as current_land_value,
        COALESCE(ba.current_building_value, 0) + COALESCE(la.current_land_value, 0) as total_property_value,
        fp.parcel_data,
        ''[]''::jsonb as building_summary,
        jsonb_build_object(
            ''building_value'', COALESCE(ba.current_building_value, 0),
            ''land_value'', COALESCE(la.current_land_value, 0),
            ''total_value'', COALESCE(ba.current_building_value, 0) + COALESCE(la.current_land_value, 0)
        ) as value_summary
    FROM filtered_parcels fp
    LEFT JOIN public.addresses_v2 sa ON fp.site_address_id = sa.id
    LEFT JOIN public.neighborhoods_v2 n ON fp.neighborhood_id = n.id
    LEFT JOIN public.tax_statuses_v2 ts ON fp.tax_status_id = ts.id
    LEFT JOIN building_agg ba ON fp.id = ba.parcel_id
    LEFT JOIN land_agg la ON fp.id = la.parcel_id
    WHERE 1=1';

    -- Add value-based filters (applied after aggregation)
    where_conditions := ARRAY[]::text[];
    
    IF p_filters ? 'min_value' THEN
        where_conditions := where_conditions || ('(COALESCE(ba.current_building_value, 0) + COALESCE(la.current_land_value, 0)) >= ' || (p_filters->>'min_value'));
    END IF;
    
    IF p_filters ? 'max_value' THEN
        where_conditions := where_conditions || ('(COALESCE(ba.current_building_value, 0) + COALESCE(la.current_land_value, 0)) <= ' || (p_filters->>'max_value'));
    END IF;

    IF p_filters ? 'building_type' THEN
        where_conditions := where_conditions || ('EXISTS (SELECT 1 FROM public.buildings_v2 b WHERE b.parcel_id = fp.id AND b.building_type = ''' || (p_filters->>'building_type') || ''')');
    END IF;

    IF array_length(where_conditions, 1) > 0 THEN
        base_query := base_query || ' AND ' || array_to_string(where_conditions, ' AND ');
    END IF;

    -- Get total count first (simplified)
    count_query := 'SELECT COUNT(*) FROM (' || base_query || ') as count_subquery';
    EXECUTE count_query USING p_as_of_date, 0 INTO total_rows;

    -- Add ORDER BY clause
    base_query := base_query || ' ORDER BY ' || p_sort_by || ' ' || p_sort_direction;

    -- Add LIMIT and OFFSET (cap at reasonable maximum)
    base_query := base_query || ' LIMIT ' || LEAST(p_limit, 1000) || ' OFFSET ' || p_offset;

    -- Execute the query with total count
    RETURN QUERY EXECUTE base_query USING p_as_of_date, total_rows;
END;
$$;

-- ============================================================
-- END SCHEMA-V2-ULTRA-SIMPLE.SQL
-- ============================================================